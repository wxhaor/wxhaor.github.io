[{"title":"springboot 部署","date":"2017-04-02T16:00:00.000Z","path":"2017/04/03/springboot/2017-04-05-springboot/","text":"springboot 服务部署 目录结构项目名称├─app 应用目录├─bin 脚本目录└─conf 配置目录 windows 下启动脚本start.bat1start java -jar ../app/st-wxhao-r-oos-0.0.1-SNAPSHOT.jar --spring.config.location=../conf/application.yml 配置文件","tags":[{"name":"springboot","slug":"springboot","permalink":"http://wxhaor.me/tags/springboot/"}]},{"title":"springboot入门","date":"2017-04-02T16:00:00.000Z","path":"2017/04/03/springboot/2017-04-03-springboot-study/","text":"springboot入门 使用@valid表单验证123@valid 在controller的参数之前要加实体里也要添加相应的验证如@min 还有msg 使用aop处理请求aop 是一种编程范式 与语言无关 是一种程序设计思想 OOP 面向切面编程 添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.wxhao.aspect;import javax.servlet.http.HttpServletRequest;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;@Aspect@Componentpublic class ControllerAspect &#123; private final static Logger logger = LoggerFactory.getLogger(ControllerAspect.class); @Pointcut(\"execution(public * com.wxhao.controller.*.*(..))\") public void log()&#123; &#125; @Before(\"log()\") public void logBefore(JoinPoint joinPoint)&#123; logger.info(\"--------@Before\"); ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); logger.info(\"url=&#123;&#125;\" , request.getRequestURI()); logger.info(\"method=&#123;&#125;\" , request.getMethod()); logger.info(\"ip=&#123;&#125;\" , request.getRemoteAddr()); logger.info(\"class_method =&#123;&#125;\" , joinPoint.getSignature().getDeclaringTypeName() + \".\" + joinPoint.getSignature().getName()); logger.info(\"args=&#123;&#125;\",joinPoint.getArgs()); &#125; // @After(\"execution(public * com.wxhao.controller.*(..))\") @After(\"log()\") public void logAfter()&#123; logger.info(\"--------@After\"); &#125; @AfterReturning(returning = \"obj\" , pointcut = \"log()\") public void doAfterReturning(Object obj)&#123; logger.info(\"return=&#123;&#125;\" , obj); &#125; &#125; 统一的异常处理spring 默认捕获runtimeexception 才能回滚异常 12345678910@ControllerAdvicepublic class ExpectionHandle &#123; @ExceptionHandler(value = Exception.class) @ResponseBody public String defaultErrorHandler(HttpServletRequest req, Exception e) &#123; if( e instanceof MyException)&#123; &#125; return \"...\"; &#125;&#125; 1234567891011121314public class MyException extends RuntimeException&#123; private Integer code ; public MyException(Integer code , String msg) &#123; super(msg); this.code = code; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125;&#125; 单元测试service测试12345678910111213141516171819package com.wxhao;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootGirlApplicationTests &#123; @Test public void contextLoads() &#123; Assert.assertEquals(\"\",\"\"); &#125;&#125; api测试123456789101112131415161718192021222324252627282930package com.wxhao;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcpublic class SpringBootGirlApplicationTests &#123; @Autowired private MockMvc mvc; @Test public void contextLoads() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(\"/girls\")) //匹配状态码 .andExpect(MockMvcResultMatchers.status().isOk()) //匹配返回值内容 .andExpect(MockMvcResultMatchers.content().string(\"abc\")); &#125;&#125; mvn clean package 会先测试再打包 mvn clean package -Dmaven.test.skip=true 跳过单元测试 附录12345678910# 项目contextPath，一般在正式发布版本中，我们不配置server.context-path=/myspringboot# 错误页，指定发生错误时，跳转的URL。请查看BasicErrorController源码便知server.error.path=/error# 服务端口server.port=9090# session最大超时时间(分钟)，默认为30server.session-timeout=60# 该服务绑定IP地址，启动服务器时如本机不是该IP地址则抛出异常启动失败，只有特殊需求的情况下才配置# server.address=192.168.16.11 123456789101112131415# tomcat最大线程数，默认为200server.tomcat.max-threads=800# tomcat的URI编码server.tomcat.uri-encoding=UTF-8# 存放Tomcat的日志、Dump等文件的临时文件夹，默认为系统的tmp文件夹（如：C:\\Users\\Shanhy\\AppData\\Local\\Temp）server.tomcat.basedir=H:/springboot-tomcat-tmp# 打开Tomcat的Access日志，并可以设置日志格式的方法：#server.tomcat.access-log-enabled=true#server.tomcat.access-log-pattern=# accesslog目录，默认在basedir/logs#server.tomcat.accesslog.directory=# 日志文件目录logging.path=H:/springboot-tomcat-tmp# 日志文件名称，默认为spring.loglogging.file=myapp.log CMD进入项目目录，使用 mvn clean package 命令打包，以我的项目工程为例：可以追加参数 -Dmaven.test.skip=true 跳过测试。打包后的文件存放于项目下的target目录中，如：spring-boot-sample-0.0.1-SNAPSHOT.jar如果pom配置的是war包，则为spring-boot-sample-0.0.1-SNAPSHOT.war 部署到JavaEE容器12345678910public class SpringBootSampleApplication extends SpringBootServletInitializer&#123; private static final Logger logger = LoggerFactory.getLogger(SpringBootSampleApplication.class); @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(this.getClass()); &#125;&#125; 修改pom文件中jar 为 war12&lt;!-- &lt;packaging&gt;jar&lt;/packaging&gt; --&gt;&lt;packaging&gt;war&lt;/packaging&gt; 指定外部的配置文件 有些系统，关于一些数据库或其他第三方账户等信息，由于安全问题，其配置并不会提前配置在项目中暴露给开发人员。对于这种情况，我们在运行程序的时候，可以通过参数指定一个外部配置文件。以 demo.jar 为例，方法如下：1java -jar demo.jar --spring.config.location=/opt/config/application.properties 其中文件名随便定义，无固定要求。","tags":[{"name":"springboot","slug":"springboot","permalink":"http://wxhaor.me/tags/springboot/"}]},{"title":"thymeleaf","date":"2017-01-14T16:00:00.000Z","path":"2017/01/15/wxhao/2017-01-15-thymeleaf/","text":"thymeleaf thymeleaf标准方言&lt;span th:text=&quot;...&quot;&gt; &lt;span data-th-text=&quot;...&quot;&gt; 标准表达式变量表达式语法: ${...} 消息表达式语法: #{...} 选择表达式语法: *{...} 链接表达式语法: @{...} 分段表达式语法: th:insert 或 th:replace 无操作语法: _ 设置属性值设置任意属性语法: th:attr 设置指定属性语法: th:text 迭代器状态变量1234567891011121314下标index 计数count总数size 当前变量current奇数还是偶数even/odd 是不是第一个frist是不是最后一个last 条件语句语法: th:if th:unless switch,case 模版布局定义和引用片段 th:fragment=&quot;copy&quot; th:insert=&quot;~{footer :: copy}&quot; 或id引用th:insert=&quot;~{footer :: #copy}&quot; 属性优先级同行先后顺序不影响优先级 注释&lt;!-- --&gt; 解析器级注释块删除&lt;!--/* 和 */--&gt; 之间的所有内容 原型注释块解析后不注释&lt;!--/*/ 和 /*/--&gt; 之间的所有内容 内联转义[[]] th:text不转义[()] wh:utext 禁用内联表达式th:inline=&quot;none&quot; 基本对象#ctx 上下文对象 #locale 相关联的当前请求 #request 相关联的request#session 相关联的session#servletContext 相关联的servletContext 工具对象执行信息#execInfo 表达式对象提供有关在thymeleaf 标准表达式内正在处理的模版的有用信息 消息#messages 获取外部消息使用方法 URI/URL#uris 转义取消转义 转换#conversions 日期#date 对应java.util.Date对象实用方法 日历#calendars 数字#numbers 字符串#strings 对象#objects 布尔#bools 数组#arrays 链表#lists set#sets map#maps 聚合#aggregates id#ids 其他springboot集成thymeleaf","tags":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://wxhaor.me/tags/thymeleaf/"}]},{"title":"ElasticSearch","date":"2017-01-14T16:00:00.000Z","path":"2017/01/15/wxhao/2017-01-31-elastic-search/","text":"ElasticSearch ElasticSearch","tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://wxhaor.me/tags/ElasticSearch/"}]},{"title":"gradle","date":"2017-01-14T16:00:00.000Z","path":"2017/01/15/wxhao/2017-01-25-gradle/","text":"gradle gradle","tags":[{"name":"gradle","slug":"gradle","permalink":"http://wxhaor.me/tags/gradle/"}]},{"title":"Nginx 常用命令","date":"2016-12-31T16:00:00.000Z","path":"2017/01/01/wxhao/2016-01-02-nginx/","text":"Nginx 常用命令 和常见问题 Nginx 常用配置配置片断12345678910111213141516171819 server &#123; # Nginx 端口 listen 7777; server_name localhost; location / &#123;# 项目地址 root D:/server/_war/wxhaor-html;# 默认页面index /html/index.html; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 负载均衡配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354events &#123; #单个进程最大连接数(最大连接数=连接数*进程数) worker_connections 1024;&#125;http &#123; # 文件扩展名与文件类型映射表 include mime.types; # 默认文件类型 default_type application/octet-stream; # 开启高效文件传输模式,sendfile指令指定nginx是否调用sendfile函数来输出文件,对于普通应用设为 on,如果用来进行下载等应用磁盘IO重负载应用,可设置为off,以平衡磁盘与网络I/O处理速度,降低系统的负载.注意:如果图片显示不正常把这个改成off sendfile on; #tcp_nopush on; # 长连接超时时间，单位是秒 #keepalive_timeout 0; keepalive_timeout 65; # 启用Gizp压缩 #gzip on; # 负载均衡配置 upstream server-client.58bcc.com &#123; # 服务器集群名字 # 开启ip_hash保证同一个用户访问到同一台服务器 ip_hash; # 服务器配置 weight是权重的意思,权重越大,分配的概率越大 server 127.0.0.1:8080 weight=1; server 127.0.0.1:8081 weight=1; &#125; #当前的Nginx的配置 server &#123; # 监听80端口,可以改成其他端口 listen 80; # 当前服务的域名 server_name server-client.58bcc.com; location / &#123; proxy_pass http://server-client.58bcc.com; proxy_redirect default; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; windows常用命令启动双击应用程序或者1start nginx 重启1nginx -s reload 停止1nginx -s stop 注意事项在powershell命令下 1234567nginx : 无法将“nginx”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ nginx -s reload+ ~~~~~ + CategoryInfo : ObjectNotFound: (nginx:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException 需要在nginx命令前加上 ./1./nginx -s reload error[error] OpenEvent(“Global\\ngx_reload_3420”) failed (2: The system cannot find the file specified)原因是Nginx没打开就执行nginx -s reload","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://wxhaor.me/tags/Nginx/"},{"name":"cmd","slug":"cmd","permalink":"http://wxhaor.me/tags/cmd/"}]},{"title":"windows 常用命令","date":"2016-12-31T16:00:00.000Z","path":"2017/01/01/wxhao/2015-06-06-windows-cmd/","text":"windows 常用命令 portproxywindows自带的端口转发 新增1netsh interface portproxy add v4tov4 listenaddress=127.0.0.1 listenport=8888 connectaddress=192.168.99.100 connectport=8888 删除1netsh interface portproxy delete v4tov4 listenaddress=192.168.1.8 listenport=33891 查寻1netsh interface portproxy show v4tov4 tree生成树形结构 在需要生成目录的文件夹下运行命令,并把字符写入txt保存1tree /f &gt; tree.txt","tags":[{"name":"cmd","slug":"cmd","permalink":"http://wxhaor.me/tags/cmd/"},{"name":"windows","slug":"windows","permalink":"http://wxhaor.me/tags/windows/"}]},{"title":"Java8","date":"2016-12-31T16:00:00.000Z","path":"2017/01/01/java-senior/2017-03-03-java8/","text":"Java8 的新特性 Java8新特性概要2014年3月发布正式版 函数式接口 lambda 集合的流式操作 注解的更新 安全性增强 io/nio改进 函数式接口在接口中添加抽象方法,来实现函数式接口 在一个接口中定一个唯一的抽象方法,那么这个接口就是函数式接口 通过注解@FunctionalInterface 特性 允许定义静态方法 允许定义java.lang.Object里的public方法 泛型和继承的关系 一个父接口是函数式接口,那他的子接口也有可能是函数式接口 lambda表达式 一定和函数接口一起使用 语法: (param1 , param2) -&gt; {method body} 一个括号内用逗号分隔形式参数(在函数式接口中定义的方法里面的参数) -&gt; (固定语法) 方法体或者表达式 方法引用 引用静态方法例 String::valueOf 引用对象的实例方法例 x::toString 引用某个类型的任意对象的实例方法例 String::toString 引用类构造器方法例 String::new java.util.function 函数包装 Supplier 类似于工厂操作 Function 12 接口增强可以允许static声明的实现方法 default方法 集合流式操作","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"java-senior","slug":"java-senior","permalink":"http://wxhaor.me/tags/java-senior/"}]},{"title":"hexo 构建和常用命令","date":"2016-12-31T16:00:00.000Z","path":"2017/01/01/wxhao/2017-01-01-hexo-build/","text":"hexo 构建和常用命令 hexo构建 下载node.js 并安装 安装hexo 1npm install -g hexo-cli 新建文件夹 初始化此文件夹 1hexo init 在/soucre/_post目录下新建md文件 启动hexo服务,默认端口4000 1hexo server 安装hexo部署插件 1npm install hexo-deployer-git --save 部署到GitHub仓库 清空 1hexo clean 编译 1hexo generate 部署 1hexo deploy 建议每次部署都按上面的命令执行 next 主题next 官网 初始化头信息 12345678910---title: 标题date: 2017-01-01tags: - 标签1 - 标签2---&#123;% cq %&#125; 我在这里面居中显示,下面的是更多信息 &#123;% endcq %&#125;&lt;!-- more --&gt;","tags":[{"name":"cmd","slug":"cmd","permalink":"http://wxhaor.me/tags/cmd/"},{"name":"hexo","slug":"hexo","permalink":"http://wxhaor.me/tags/hexo/"},{"name":"build","slug":"build","permalink":"http://wxhaor.me/tags/build/"}]},{"title":"chrome","date":"2016-11-24T16:00:00.000Z","path":"2016/11/25/wxhao/2016-11-25-chrome/","text":"chrome 插件新建标签页插件1Aurora Dashboard 清理内存1OneTab 右键扩展1右键搜 网页收藏1收趣 网页工具json格式化代码美化代码压缩二维码正则时间错 12web前端助手FE助手 接口调试1restlet client","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://wxhaor.me/tags/Nginx/"},{"name":"cmd","slug":"cmd","permalink":"http://wxhaor.me/tags/cmd/"}]},{"title":"sourcetree 常见异常","date":"2016-06-04T16:00:00.000Z","path":"2016/06/05/exception/2016-06-05-source-tree/","text":"sourcetree git 常见异常 文件过大,上传失败解决办法：打开项目中隐藏的.git文件夹，找到config配置文件，在最后添加如下配置: 12[http] postBuffer = 524288000","tags":[{"name":"exception","slug":"exception","permalink":"http://wxhaor.me/tags/exception/"},{"name":"git","slug":"git","permalink":"http://wxhaor.me/tags/git/"}]},{"title":"正则表达式","date":"2015-09-22T16:00:00.000Z","path":"2015/09/23/wxhao/2015-09-23-regex/","text":"正则表达式 简述1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081.由数字、26个英文字母或者下划线组成的字符串: ^[0-9a-zA-Z_]&#123;1,&#125;$2.非负整数（正整数 + 0 ）: ^/d+$3. 正整数: ^[0-9]*[1-9][0-9]*$4.非正整数（负整数 + 0）： ^((-/d+)|(0+))$5. 负整数 : ^-[0-9]*[1-9][0-9]*$6.整数: ^-?/d+$7.非负浮点数（正浮点数 + 0）: ^/d+(/./d+)?$8.正浮点数 : ^(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*))$9. 非正浮点数（负浮点数 + 0）: ^((-/d+(/./d+)?)|(0+(/.0+)?))$10.负浮点数 : ^(-(([0-9]+/.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*/.[0-9]+)|([0-9]*[1-9][0-9]*)))$11. 浮点数 : ^(-?/d+)(/./d+)?$12.由26个英文字母组成的字符串 : ^[A-Za-z]+$13. 由26个英文字母的大写组成的字符串 : ^[A-Z]+$14.由26个英文字母的小写组成的字符串 : ^[a-z]+$15. 由数字和26个英文字母组成的字符串 : ^[A-Za-z0-9]+$16.由数字、26个英文字母或者下划线组成的字符串 : ^/w+$17.email地址 : ^[/w-]+(/.[/w-]+)*@[/w-]+(/.[/w-]+)+$18.url: ^[a-zA-z]+://(/w+(-/w+)*)(/.(/w+(-/w+)*))*(/?/S*)?$19. 年-月-日: /^(d&#123;2&#125;|d&#123;4&#125;)-((0([1-9]&#123;1&#125;))|(1[1|2]))-(([0-2]([1-9]&#123;1&#125;))|(3[0|1]))$/20.月/日/年: /^((0([1-9]&#123;1&#125;))|(1[1|2]))/(([0-2]([1-9]&#123;1&#125;))|(3[0|1]))/(d&#123;2&#125;|d&#123;4&#125;)$/21.Emil: ^([w-.]+)@(([[0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;.)|(([w-]+.)+))([a-zA-Z]&#123;2,4&#125;|[0-9]&#123;1,3&#125;)(]?)$22. 电话号码: (d+-)?(d&#123;4&#125;-?d&#123;7&#125;|d&#123;3&#125;-?d&#123;8&#125;|^d&#123;7,8&#125;)(-d+)?23.IP地址: ^(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5]).(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5]).(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5]).(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5])$24. 匹配中文字符的正则表达式： [/u4e00-/u9fa5]25.匹配双字节字符(包括汉字在内)： [^/x00-/xff]26. 匹配空行的正则表达式： /n[/s| ]*/r27.匹配HTML标记的正则表达式： /&lt;(.*)&gt;.*&lt;///1&gt;|&lt;(.*) //&gt;/28.匹配首尾空格的正则表达式： (^/s*)|(/s*$)29.匹配Email地址的正则表达式： /w+([-+.]/w+)*@/w+([-.]/w+)*/./w+([-.]/w+)*30. 匹配网址URL的正则表达式： ^[a-zA-z]+://(//w+(-//w+)*)(//.(//w+(-//w+)*))*(//?//S*)?$31. 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)： ^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$32. 匹配国内电话号码： (/d&#123;3&#125;-|/d&#123;4&#125;-)?(/d&#123;8&#125;|/d&#123;7&#125;)?33.匹配腾讯QQ号： ^[1-9]*[1-9][0-9]*$34. 只能输入数字： ^[0-9]*$35.只能输入n位的数字： ^/d&#123;n&#125;$36.只能输入至少n位的数字： ^/d&#123;n,&#125;$37.只能输入m~n位的数字： ^/d&#123;m,n&#125;$38.只能输入零和非零开头的数字： ^(0|[1-9][0-9]*)$39.只能输入有两位小数的正实数： ^[0-9]+(.[0-9]&#123;2&#125;)?$40. 只能输入有1~3位小数的正实数： ^[0-9]+(.[0-9]&#123;1,3&#125;)?$41.只能输入非零的正整数： ^/+?[1-9][0-9]*$42. 只能输入非零的负整数： ^/-[1-9][0-9]*$43.只能输入长度为3的字符： ^.&#123;3&#125;$44. 只能输入由26个英文字母组成的字符串： ^[A-Za-z]+$45.只能输入由26个大写英文字母组成的字符串： ^[A-Z]+$46. 只能输入由26个小写英文字母组成的字符串： ^[a-z]+$47.只能输入由数字和26个英文字母组成的字符串： ^[A-Za-z0-9]+$48. 只能输入由数字和26个英文字母或者下划线组成的字符串： ^/w+$49.验证用户密码(正确格式为： 以字母开头，长度在5~17 之间，只能包含字符、数字和下划线) ^[a-zA-Z]/w&#123;5,17&#125;$50.验证是否包含有 ^%&amp;&apos;,;=?$/&quot;等字符： [^%&amp;&apos;,;=?$/x22]+51.只能输入汉字： ^[\\u4e00-\\u9fa5]&#123;0,&#125;$52、只含有汉字、数字、字母、下划线不能以下划线开头和结尾 ^(?!_)(?!.*?_$)[a-zA-Z0-9_\\u4e00-\\u9fa5]+$53、只含有汉字、数字、字母、下划线，下划线位置不限 ^[a-zA-Z0-9_\\u4e00-\\u9fa5]+$54、2~4个汉字 @&quot;^[\\u4E00-\\u9FA5]&#123;2,4&#125;$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271（1） &quot;^\\d+$&quot; //非负整数（正整数 + 0）（2） &quot;^[0-9]*[1-9][0-9]*$&quot; //正整数（3） &quot;^((-\\d+)|(0+))$&quot; //非正整数（负整数 + 0）（4） &quot;^-[0-9]*[1-9][0-9]*$&quot; //负整数（5） &quot;^-?\\d+$&quot; //整数（6） &quot;^\\d+(\\.\\d+)?$&quot; //非负浮点数（正浮点数 + 0）（7） &quot;^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$&quot; //正浮点数（8） &quot;^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$&quot; //非正浮点数（负浮点数 + 0）（9） &quot;^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$&quot; //负浮点数（10） &quot;^(-?\\d+)(\\.\\d+)?$&quot; //浮点数（11） &quot;^[A-Za-z]+$&quot; //由26个英文字母组成的字符串（12） &quot;^[A-Z]+$&quot; //由26个英文字母的大写组成的字符串（13） &quot;^[a-z]+$&quot; //由26个英文字母的小写组成的字符串（14） &quot;^[A-Za-z0-9]+$&quot; //由数字和26个英文字母组成的字符串（15） &quot;^\\w+$&quot; //由数字、26个英文字母或者下划线组成的字符串（16） &quot;^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$&quot; //email地址（17） &quot;^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$&quot; //url（18） /^(d&#123;2&#125;|d&#123;4&#125;)-((0([1-9]&#123;1&#125;))|(1[1|2]))-(([0-2]([1-9]&#123;1&#125;))|(3[0|1]))$/ // 年-月-日（19） /^((0([1-9]&#123;1&#125;))|(1[1|2]))/(([0-2]([1-9]&#123;1&#125;))|(3[0|1]))/(d&#123;2&#125;|d&#123;4&#125;)$/ // 月/日/年（20） &quot;^([w-.]+)@(([[0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;.[0-9]&#123;1,3&#125;.)|(([w-]+.)+))([a-zA-Z]&#123;2,4&#125;|[0-9]&#123;1,3&#125;)(]?)$&quot; //Emil（21） /^((\\+?[0-9]&#123;2,4&#125;\\-[0-9]&#123;3,4&#125;\\-)|([0-9]&#123;3,4&#125;\\-))?([0-9]&#123;7,8&#125;)(\\-[0-9]+)?$/ //电话号码（22） &quot;^(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5]).(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5]).(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5]).(d&#123;1,2&#125;|1dd|2[0-4]d|25[0-5])$&quot; //IP地址（23） （24） 匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]（25） 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]（26） 匹配空行的正则表达式：\\n[\\s| ]*\\r（27） 匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*&lt;\\/\\1&gt;|&lt;(.*) \\/&gt;/（28） 匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)（29） 匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*（30） 匹配网址URL的正则表达式：^[a-zA-z]+://(\\\\w+(-\\\\w+)*)(\\\\.(\\\\w+(-\\\\w+)*))*(\\\\?\\\\S*)?$（31） 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$（32） 匹配国内电话号码：(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?（33） 匹配腾讯QQ号：^[1-9]*[1-9][0-9]*$（34） 元字符及其在正则表达式上下文中的行为：（35） \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个后向引用、或一个八进制转义符。（36） ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的Multiline 属性，^ 也匹配 ’\\n’ 或 ’\\r’ 之后的位置。（37） $ 匹配输入字符串的结束位置。如果设置了 RegExp 对象的Multiline 属性，$ 也匹配 ’\\n’ 或 ’\\r’ 之前的位置。（38） * 匹配前面的子表达式零次或多次。（39） + 匹配前面的子表达式一次或多次。+ 等价于 &#123;1,&#125;。（40） ? 匹配前面的子表达式零次或一次。? 等价于 &#123;0,1&#125;。（41） &#123;n&#125; n 是一个非负整数，匹配确定的n 次。（42） &#123;n,&#125; n 是一个非负整数，至少匹配n 次。（43） &#123;n,m&#125; m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。在逗号和两个数之间不能有空格。（44） ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。（45） . 匹配除 &quot;\\n&quot; 之外的任何单个字符。要匹配包括 ’\\n’ 在内的任何字符，请使用象 ’[.\\n]’ 的模式。（46） (pattern) 匹配pattern 并获取这一匹配。（47） (?:pattern) 匹配pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。（48） (?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。（49） (?!pattern) 负向预查，与(?=pattern)作用相反（50） x|y 匹配 x 或 y。（51） [xyz] 字符集合。（52） [^xyz] 负值字符集合。（53） [a-z] 字符范围，匹配指定范围内的任意字符。（54） [^a-z] 负值字符范围，匹配任何不在指定范围内的任意字符。（55） \\b 匹配一个单词边界，也就是指单词和空格间的位置。（56） \\B 匹配非单词边界。（57） \\cx 匹配由x指明的控制字符。（58） \\d 匹配一个数字字符。等价于 [0-9]。（59） \\D 匹配一个非数字字符。等价于 [^0-9]。（60） \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。（61） \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。（62） \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。（63） \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。（64） \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。（65） \\t 匹配一个制表符。等价于 \\x09 和 \\cI。（66） \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。（67） \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。（68） \\W 匹配任何非单词字符。等价于 ’[^A-Za-z0-9_]’。（69） \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。（70） \\num 匹配 num，其中num是一个正整数。对所获取的匹配的引用。（71） \\n 标识一个八进制转义值或一个后向引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。（72） \\nm 标识一个八进制转义值或一个后向引用。如果 \\nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。（73） \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。（74） \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的Unicode字符。（75） 匹配中文字符的正则表达式： [u4e00-u9fa5]（76） 匹配双字节字符(包括汉字在内)：[^x00-xff]（77） 匹配空行的正则表达式：n[s| ]*r（78） 匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*&lt;/1&gt;|&lt;(.*) /&gt;/（79） 匹配首尾空格的正则表达式：(^s*)|(s*$)（80） 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*（81） 匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?（82） 利用正则表达式限制网页表单里的文本框输入内容：（83） 用正则表达式限制只能输入中文：onkeyup=&quot;value=value.replace(/[^u4E00-u9FA5]/g,&apos;&apos;)&quot; onbeforepaste=&quot;clipboardData.setData(&apos;text&apos;,clipboardData.getData(&apos;text&apos;).replace(/[^u4E00-u9FA5]/g,&apos;&apos;))&quot;（84） 用正则表达式限制只能输入全角字符： onkeyup=&quot;value=value.replace(/[^uFF00-uFFFF]/g,&apos;&apos;)&quot; onbeforepaste=&quot;clipboardData.setData(&apos;text&apos;,clipboardData.getData(&apos;text&apos;).replace(/[^uFF00-uFFFF]/g,&apos;&apos;))&quot;（85） 用正则表达式限制只能输入数字：onkeyup=&quot;value=value.replace(/[^d]/g,&apos;&apos;) &quot;onbeforepaste=&quot;clipboardData.setData(&apos;text&apos;,clipboardData.getData(&apos;text&apos;).replace(/[^d]/g,&apos;&apos;))&quot;（86） 用正则表达式限制只能输入数字和英文：onkeyup=&quot;value=value.replace(/[W]/g,&apos;&apos;) &quot;onbeforepaste=&quot;clipboardData.setData(&apos;text&apos;,clipboardData.getData(&apos;text&apos;).replace(/[^d]/g,&apos;&apos;))&quot;（87） 整理：（88） 匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]（89） 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]（90） 匹配空行的正则表达式：\\n[\\s| ]*\\r（91） 匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*&lt;\\/\\1&gt;|&lt;(.*) \\/&gt;/（92） 匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)（93） 匹配IP地址的正则表达式：/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g //（94） 匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*（95） 匹配网址URL的正则表达式：http://(/[\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?（96） sql语句：^(select|drop|delete|create|update|insert).*$（97） 非负整数：^\\d+$（98） 正整数：^[0-9]*[1-9][0-9]*$（99） 非正整数：^((-\\d+)|(0+))$（100） 负整数：^-[0-9]*[1-9][0-9]*$（101） 整数：^-?\\d+$（102） 非负浮点数：^\\d+(\\.\\d+)?$（103） 正浮点数：^((0-9)+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$（104） 非正浮点数：^((-\\d+\\.\\d+)?)|(0+(\\.0+)?))$（105） 负浮点数：^(-((正浮点数正则式)))$（106） 英文字符串：^[A-Za-z]+$（107） 英文大写串：^[A-Z]+$（108） 英文小写串：^[a-z]+$（109） 英文字符数字串：^[A-Za-z0-9]+$（110） 英数字加下划线串：^\\w+$（111） E-mail地址：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$（112） URL：^[a-zA-Z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\s*)?$或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\&apos;:+!]*([^&lt;&gt;\\&quot;\\&quot;])*$（113） 邮政编码：^[1-9]\\d&#123;5&#125;$（114） 中文：^[\\u0391-\\uFFE5]+$（115） 电话号码：^((\\(\\d&#123;2,3&#125;\\))|(\\d&#123;3&#125;\\-))?(\\(0\\d&#123;2,3&#125;\\)|0\\d&#123;2,3&#125;-)?[1-9]\\d&#123;6,7&#125;(\\-\\d&#123;1,4&#125;)?$（116） 手机号码：^((\\(\\d&#123;2,3&#125;\\))|(\\d&#123;3&#125;\\-))?13\\d&#123;9&#125;$（117） 双字节字符(包括汉字在内)：^\\x00-\\xff（118） 匹配首尾空格：(^\\s*)|(\\s*$)（像vbscript那样的trim函数）（119） 匹配HTML标记：&lt;(.*)&gt;.*&lt;\\/\\1&gt;|&lt;(.*) \\/&gt;（120） 匹配空行：\\n[\\s| ]*\\r（121） 提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) *= *(&apos;|&quot;)?(\\w|\\\\|\\/|\\.)+(&apos;|&quot;| *|&gt;)?（122） 提取信息中的邮件地址：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*（123） 提取信息中的图片链接：(s|S)(r|R)(c|C) *= *(&apos;|&quot;)?(\\w|\\\\|\\/|\\.)+(&apos;|&quot;| *|&gt;)?（124） 提取信息中的IP地址：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)（125） 提取信息中的中国手机号码：(86)*0*13\\d&#123;9&#125;（126） 提取信息中的中国固定电话号码：(\\(\\d&#123;3,4&#125;\\)|\\d&#123;3,4&#125;-|\\s)?\\d&#123;8&#125;（127） 提取信息中的中国电话号码（包括移动和固定电话）：(\\(\\d&#123;3,4&#125;\\)|\\d&#123;3,4&#125;-|\\s)?\\d&#123;7,14&#125;（128） 提取信息中的中国邮政编码：[1-9]&#123;1&#125;(\\d+)&#123;5&#125;（129） 提取信息中的浮点数（即小数）：(-?\\d*)\\.?\\d+（130） 提取信息中的任何数字 ：(-?\\d*)(\\.\\d+)?（131） IP：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)（132） 电话区号：/^0\\d&#123;2,3&#125;$/（133） 腾讯QQ号：^[1-9]*[1-9][0-9]*$（134） 帐号(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$（135） 中文、英文、数字及下划线：^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$","tags":[{"name":"regex","slug":"regex","permalink":"http://wxhaor.me/tags/regex/"}]},{"title":"eclipse","date":"2015-05-14T16:00:00.000Z","path":"2015/05/15/wxhao/2015-05-15-eclipse/","text":"eclipse 问题汇总 常用命令批量修改变量名双击变量1Alt+Shift+R 可以同时修改这个变量名","tags":[{"name":"IDE","slug":"IDE","permalink":"http://wxhaor.me/tags/IDE/"}]},{"title":"MySQL","date":"2015-05-05T16:00:00.000Z","path":"2015/05/06/wxhao/2015-05-06-mysql/","text":"MySQL 问题汇总 常用命令查看数据库编码1SHOW VARIABLES LIKE &apos;char%&apos; 问题汇总springboot 插入mysql乱码修改character_set_server的encode:1set global character_set_server = utf8 如果执行之后不可以则 修改 C:\\Program Files\\MySQL\\MySQL Server 5.5\\my.ini 123default-character-set=utf8character-set-server=utf8 重启mysql服务","tags":[{"name":"database","slug":"database","permalink":"http://wxhaor.me/tags/database/"}]},{"title":"tomcat","date":"2014-03-01T16:00:00.000Z","path":"2014/03/02/wxhao/2014-03-02-tomcat/","text":"tomcat 攻略 tomcat 常用配置指定项目发布路径在tomcat\\conf\\Catalina\\localhost目录下新建ROOT.xml 123&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Context path=\"\" docBase=\"C:\\_zyhl\\webapp\\running\" reloadable=\"true\"&gt;&lt;/Context&gt; 多tomcat配置需要修改tomcat\\conf目录下的server.xml 3处需要修改 代码片段11&lt;Server port=\"8006\" shutdown=\"SHUTDOWN\"&gt; 代码片段2123&lt;Connector port=\"8081\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 代码片段312&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;&lt;Connector port=\"8010\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://wxhaor.me/tags/tomcat/"}]},{"title":"JavaSE - 反射","date":"2013-10-30T16:00:00.000Z","path":"2013/10/31/2013-10-31-reflex/","text":"JavaSE - 反射 类的加载概述和加载时机 类的加载概述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 加载 就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 连接 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化 就是我们以前讲过的初始化步骤 B:加载时机 创建类的实例 访问类的静态变量，或者为静态变量赋值 调用类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 类加载器的概述和分类 类加载器的概述 负责将.class文件加载到内存中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。 类加载器的分类 Bootstrap ClassLoader 根类加载器 Extension ClassLoader 扩展类加载器 Sysetm ClassLoader 系统类加载器 类加载器的作用 Bootstrap ClassLoader 根类加载器 也被称为引导类加载器，负责Java核心类的加载 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中 Extension ClassLoader 扩展类加载器 负责JRE的扩展目录中jar包的加载。 在JDK中JRE的lib目录下ext目录 Sysetm ClassLoader 系统类加载器 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径 反射概述 反射概述 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。 而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。 三种方式 a:Object类的getClass()方法,判断两个对象是否是同一个字节码文件 b:静态属性class,锁对象 c:Class类中静态方法forName(),读取配置文件 获取class文件对象的三种方式 12345678Class clazz1 = Class.forName(\"com.wxhao.bean.Person\");Class clazz2 = Person.class;Person p = new Person();Class clazz3 = p.getClass();System.out.println(clazz1 == clazz2);System.out.println(clazz2 == clazz3); Class.forName()读取配置文件举例 榨汁机(Juicer)榨汁的案例 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze) 123456789101112131415161718192021222324252627282930313233343536373839public class Demo2_Reflect &#123; /** * 榨汁机(Juicer)榨汁的案例 * 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze) * @throws Exception */ public static void main(String[] args) throws Exception &#123; /*Juicer j = new Juicer(); //j.run(new Apple()); j.run(new Orange());*/ BufferedReader br = new BufferedReader(new FileReader(\"config.properties\")); //创建输入流对象,关联配置文件 Class&lt;?&gt; clazz = Class.forName(br.readLine()); //读取配置文件一行内容,获取该类的字节码对象 Fruit f = (Fruit) clazz.newInstance(); //通过字节码对象创建实例对象 Juicer j = new Juicer(); j.run(f); &#125;&#125;interface Fruit &#123; public void squeeze();&#125;class Apple implements Fruit &#123; public void squeeze() &#123; System.out.println(\"榨出一杯苹果汁儿\"); &#125;&#125;class Orange implements Fruit &#123; public void squeeze() &#123; System.out.println(\"榨出一杯桔子汁儿\"); &#125;&#125;class Juicer &#123; public void run(Fruit f) &#123; f.squeeze(); &#125;&#125; 通过反射获取带参构造方法并使用 Constructor Class类的newInstance()方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, 就不能这样创建了,可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance(“张三”,20)方法创建对象 123456Class clazz = Class.forName(\"com.wxhao.bean.Person\");//Person p = (Person) clazz.newInstance(); 通过无餐构造创建对象//System.out.println(p);Constructor c = clazz.getConstructor(String.class,int.class); //获取有参构造Person p = (Person) c.newInstance(\"张三\",23); //通过有参构造创建对象System.out.println(p); 通过反射获取成员变量并使用 Field Class.getField(String)方法可以获取类中的指定字段(可见的), 如果是私有的可以用getDeclaedField(“name”)方法获取,通过set(obj, “李四”)方法可以设置指定对象上该字段的值, 如果是私有的需要先调用setAccessible(true)设置访问权限,用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值 1234567891011Class clazz = Class.forName(\"com.heima.bean.Person\");Constructor c = clazz.getConstructor(String.class,int.class);//获取有参构造Person p = (Person) c.newInstance(\"张三\",23); //通过有参构造创建对象//Field f = clazz.getField(\"name\"); //获取姓名字段//f.set(p, \"李四\"); //修改姓名的值Field f = clazz.getDeclaredField(\"name\"); //暴力反射获取字段f.setAccessible(true); //去除私有权限f.set(p, \"李四\"); System.out.println(p); 通过反射获取方法并使用 Method Class.getMethod(String, Class…) 和 Class.getDeclaredMethod(String, Class…)方法可以获取类中的指定方法,调用invoke(Object, Object…)可以调用该方法,Class.getMethod(“eat”) invoke(obj) Class.getMethod(“eat”,int.class) invoke(obj,10) 123456789Class clazz = Class.forName(\"com.wxhao.bean.Person\");Constructor c = clazz.getConstructor(String.class,int.class);//获取有参构造Person p = (Person) c.newInstance(\"张三\",23); //通过有参构造创建对象Method m = clazz.getMethod(\"eat\"); //获取eat方法m.invoke(p);Method m2 = clazz.getMethod(\"eat\", int.class); //获取有参的eat方法m2.invoke(p, 10); 通过反射越过泛型检查 ArrayList的一个对象，在这个集合中添加一个字符串数据，如何实现呢？ 123456789101112131415/** * ArrayList&lt;Integer&gt;的一个对象，在这个集合中添加一个字符串数据，如何实现呢？ * 泛型只在编译期有效,在运行期会被擦除掉 */public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(111); list.add(222); Class clazz = Class.forName(\"java.util.ArrayList\"); //获取字节码对象 Method m = clazz.getMethod(\"add\", Object.class); //获取add方法 m.invoke(list, \"abc\"); System.out.println(list);&#125; 通过反射写一个通用的设置某个对象的某个属性为指定的值 public void setProperty(Object obj, String propertyName, Object value){}，此方法可将obj对象中名为propertyName的属性的值设置为value。 123456789public class Tool &#123; //此方法可将obj对象中名为propertyName的属性的值设置为value。 public static void setProperty(Object obj, String propertyName, Object value) throws Exception &#123; Class clazz = obj.getClass(); //获取字节码对象 Field f = clazz.getDeclaredField(propertyName); //暴力反射获取字段 f.setAccessible(true); //去除权限 f.set(obj, value); &#125;&#125; Main方法1234567Student s = new Student(\"张三\", 23);System.out.println(s);Tool t = new Tool();Tool.setProperty(s, \"name\", \"李四\");System.out.println(s);&#125; 反射(练习) 已知一个类，定义如下： 123456package cn.wxhao.blog; public class DemoClass &#123; public void run() &#123; System.out.println(&quot;welcome to my blog!&quot;); &#125;&#125; (1) 写一个Properties格式的配置文件，配置类的完整名称。 (2) 写一个程序，读取这个Properties配置文件，获得类的完整名称并加载这个类，用反射的方式运行run方法。 12345BufferedReader br = new BufferedReader(new FileReader(\"xxx.properties\")); //创建输入流关联xxx.propertiesClass clazz = Class.forName(br.readLine()); //读取配置文件中类名,获取字节码对象DemoClass dc = (DemoClass) clazz.newInstance(); //通过字节码对象创建对象dc.run(); 动态代理的概述和实现 动态代理概述 代理：本来应该自己做的事情，请了别人来做，被请的人就是代理对象。 举例：春节回家买票让人代买 动态代理：在程序运行过程中产生的这个对象,而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理 在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象 public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 最终会调用InvocationHandler的方法 InvocationHandler Object invoke(Object proxy,Method method,Object[] args) 1234567891011121314151617181920package com.wxhao.动态代理;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"权限校验\"); method.invoke(target, args); //执行被代理target对象的方法 System.out.println(\"日志记录\"); return null; &#125;&#125; 1234567package com.wxhao.动态代理;public interface User &#123; public void add(); public void delete();&#125; 12345678910111213141516171819package com.wxhao.动态代理;public class UserImp implements User &#123; @Override public void add() &#123; //System.out.println(\"权限校验\"); System.out.println(\"添加功能\"); //System.out.println(\"日志记录\"); &#125; @Override public void delete() &#123; //System.out.println(\"权限校验\"); System.out.println(\"删除功能\"); //System.out.println(\"日志记录\"); &#125;&#125; 1234MyInvocationHandler m = new MyInvocationHandler(ui);User u = (User)Proxy.newProxyInstance(ui.getClass().getClassLoader(), ui.getClass().getInterfaces(), m);u.add();u.delete(); 模版(Template)设计模式概述和使用) 模版设计模式概述 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现 优点和缺点 优点使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求 缺点如果算法骨架有修改的话，则需要修改抽象类 123456789101112131415161718192021222324252627282930313233343536373839package com.wxhao.模版方法设计模式;public class Demo1_Template &#123; public static void main(String[] args) &#123; /*long start = System.currentTimeMillis(); for(int i = 0; i &lt; 1000000; i++) &#123; System.out.println(\"x\"); &#125; long end = System.currentTimeMillis(); System.out.println(end - start);*/ Demo d = new Demo(); System.out.println(d.getTime()); &#125;&#125;abstract class GetTime &#123; public final long getTime() &#123; long start = System.currentTimeMillis(); code(); long end = System.currentTimeMillis(); return end - start; &#125; public abstract void code();&#125;class Demo extends GetTime &#123; @Override public void code() &#123; int i = 0; while(i &lt; 100000) &#123; System.out.println(\"x\"); i++; &#125; &#125;&#125; 1,装饰2,单例3,简单工厂4,工厂方法5,适配器6,模版 JDK5新特性(自己实现枚举类) 枚举概述 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。 回想单例设计模式：单例类是一个类只有一个实例 那么多例类就是一个类有多个实例，但不是无限个数的实例，而是有限个数的实例。这才能是枚举类。 自己实现枚举类 123456789101112131415161718192021222324252627282930package com.wxhao.枚举;public abstract class Week3 &#123; public static final Week3 MON = new Week3(\"星期一\") &#123; public void show() &#123; System.out.println(\"星期一\"); &#125; &#125;; public static final Week3 TUE = new Week3(\"星期二\")&#123; public void show() &#123; System.out.println(\"星期二\"); &#125; &#125;; public static final Week3 WED = new Week3(\"星期三\")&#123; public void show() &#123; System.out.println(\"星期三\"); &#125; &#125;; private String name; private Week3(String name)&#123; this.name = name; &#125; //私有构造,不让其他类创建本类对象 public String getName() &#123; return name; &#125; public abstract void show();&#125; 1,自动拆装箱2,泛型3,可变参数4,静态导入5,增强for循环6,互斥锁7,枚举 JDK5新特性(通过enum实现枚举类) 通过enum实现枚举类 123456789101112131415161718192021222324252627package com.wxhao.枚举2;public enum Week3 &#123; MON(\"星期一\")&#123; public void show() &#123; System.out.println(\"星期一\"); &#125; &#125;,TUE(\"星期二\")&#123; public void show() &#123; System.out.println(\"星期二\"); &#125; &#125;,WED(\"星期三\")&#123; public void show() &#123; System.out.println(\"星期三\"); &#125; &#125;; private String name; private Week3(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public abstract void show();&#125; 123456789Week3 mon = Week3.TUE;switch (mon) &#123;case MON: System.out.println(&quot;星期一&quot;); break;case TUE: System.out.println(&quot;星期二&quot;); break;&#125; JDK5新特性(枚举的注意事项) 定义枚举类要用关键字enum 所有枚举类都是Enum的子类 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略 枚举类可以有构造器，但必须是private的，它默认的也是private的。 枚举类也可以有抽象方法，但是枚举项必须重写该方法 枚举在switch语句中的使用 JDK5新特性(枚举类的常见方法) 枚举类的常见方法 int ordinal() int compareTo(E o) String name() String toString() T valueOf(Class type,String name) values() 此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便 枚举类的常见方法 12345678910111213Week2 mon = Week2.MON;Week2 tue = Week2.TUE;Week2 wed = Week2.WED;/*System.out.println(mon.ordinal()); //枚举项都是有编号的System.out.println(tue.ordinal());System.out.println(wed.ordinal());System.out.println(mon.compareTo(tue)); //比较的是编号System.out.println(mon.compareTo(wed));*/System.out.println(mon.name()); //获取实例名称System.out.println(mon.toString()); //调用重写之后的toString方法 1234567// Week2 mon = Week2.valueOf(Week2.class, &quot;MON&quot;); //通过字节码对象获取枚举项// System.out.println(mon);Week2[] arr = Week2.values();for (Week2 week2 : arr) &#123; System.out.println(week2);&#125; JDK7新特性(JDK7的六个新特性回顾和讲解) 二进制字面量 数字字面量可以出现下划线 switch 语句可以用字符串 泛型简化,菱形泛型 异常的多个catch合并,每个异常用或| try-with-resources 语句 12System.out.println(0b110);//6System.out.println(100_000);//100000 JDK8新特性(JDK8的新特性) 接口中可以定义有方法体的方法,如果是非静态,必须用default修饰 如果是静态的就不用了 1234567891011121314class Test &#123; public void run() &#123; final int x = 10; class Inner &#123; public void method() &#123; System.out.println(x); &#125; &#125; Inner i = new Inner(); i.method(); &#125; &#125; 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么?因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用 1234567891011121314151617181920212223242526272829303132333435class Demo1 &#123; public static void main(String[] args) &#123; /*Demo d = new Demo(); d.print(); Inter.method();*/ Demo d = new Demo(); d.run(); &#125;&#125;interface Inter &#123; public default void print() &#123; System.out.println(\"Hello World\"); &#125; public static void method() &#123; System.out.println(\"static method\"); &#125;&#125;class Demo implements Inter &#123; public void run() &#123; int num = 10; //JDK8,前面的final可以省略 class Inner &#123; public void fun() &#123; System.out.println(num); &#125; &#125; Inner i = new Inner(); i.fun(); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - 网络编程","date":"2013-10-24T16:00:00.000Z","path":"2013/10/25/2013-10-25-socket/","text":"JavaSE - 网络编程 网络编程概述 计算机网络 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 网络编程 就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。 网络编程三要素之IP概述 每个设备在网络中的唯一标识 每台网络终端在网络中都有一个独立的地址，我们在网络中传输数据就是使用这个地址。 ipconfig：查看本机IP192.168.12.42 ping：测试连接192.168.40.62 本地回路地址：127.0.0.1 255.255.255.255是广播地址 IPv4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。 IPv6：8组，每组4个16进制数。 中间的有4个0就可以省略,但是同一个IPV6地址只能省略一处 1a2b:0000:aaaa:0000:0000:0000:aabb:1f2f 1a2b::aaaa:0000:0000:0000:aabb:1f2f 1a2b:0000:aaaa::aabb:1f2f 1a2b:0000:aaaa::0000:aabb:1f2f 1a2b:0000:aaaa:0000::aabb:1f2f 网络编程三要素之端口号概述 每个程序在设备上的唯一标识 每个网络程序都需要绑定一个端口号，传输数据的时候除了确定发到哪台机器上，还要明确发到哪个程序。 端口号范围从0-65535 编写网络应用就需要绑定一个端口号，尽量使用1024以上的，1024以下的基本上都被系统程序占用了。 常用端口 mysql: 3306 oracle: 1521 web: 80 tomcat: 8080 QQ: 4000 feiQ: 2425 网络编程三要素协议 为计算机网络中进行数据交换而建立的规则、标准或约定的集合。 UDP(类似发短息,不管你开不开机都可以给你发) 面向无连接，数据不安全，速度快。不区分客户端与服务端。 TCP(类似打电话,你必须要接听,才能打) 面向连接（三次握手），数据安全，速度略低。分为客户端和服务端。 三次握手: 客户端先向服务端发起请求, 服务端响应请求, 传输数据 Socket通信原理图解 A:Socket套接字概述： 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 通信的两端都有Socket。 网络通信其实就是Socket间的通信。 数据在两个Socket间通过IO流传输。 Socket在应用程序中创建，通过一种绑定机制与驱动程序建立关系，告诉自己所对应的IP和port。 UDP传输 1.发送Send 创建DatagramSocket, 随机端口号 创建DatagramPacket, 指定数据, 长度, 地址, 端口 使用DatagramSocket发送DatagramPacket 关闭DatagramSocket 2.接收Receive 创建DatagramSocket, 指定端口号 创建DatagramPacket, 指定数组, 长度 使用DatagramSocket接收DatagramPacket 关闭DatagramSocket 从DatagramPacket中获取数据 3.接收方获取ip和端口号 String ip = packet.getAddress().getHostAddress(); int port = packet.getPort(); 12345678910111213141516171819202122232425262728package com.wxhao.socket;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import java.net.UnknownHostException;public class Demo1_Send &#123; /** * * 1.发送Send * 创建DatagramSocket, 随机端口号 * 创建DatagramPacket, 指定数据, 长度, 地址, 端口 * 使用DatagramSocket发送DatagramPacket * 关闭DatagramSocket * @throws SocketException * @throws UnknownHostException */ public static void main(String[] args) throws Exception &#123; String str = \"what are you 弄啥呢?\"; DatagramSocket socket = new DatagramSocket(); //创建Socket相当于创建码头 DatagramPacket packet = //创建Packet相当于集装箱 new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName(\"127.0.0.1\"), 6666); socket.send(packet); //发货,将数据发出去 socket.close(); //关闭码头 &#125;&#125; 123456789101112131415161718192021222324252627package com.wxhao.socket;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;public class Demo1_Receive &#123; /** ** 2.接收Receive * 创建DatagramSocket, 指定端口号 * 创建DatagramPacket, 指定数组, 长度 * 使用DatagramSocket接收DatagramPacket * 关闭DatagramSocket * 从DatagramPacket中获取数据 * @throws Exception */ public static void main(String[] args) throws Exception &#123; DatagramSocket socket = new DatagramSocket(6666);//创建Socket相当于创建码头 DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);//创建Packet相当于创建集装箱 socket.receive(packet); //接货,接收数据 byte[] arr = packet.getData(); //获取数据 int len = packet.getLength(); //获取有效的字节个数 System.out.println(new String(arr,0,len)); socket.close(); &#125;&#125; UDP传输优化 接收端Receive 1234567891011DatagramSocket socket = new DatagramSocket(6666);//创建Socket相当于创建码头DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);//创建Packet相当于创建集装箱while(true) &#123; socket.receive(packet); //接货,接收数据 byte[] arr = packet.getData(); //获取数据 int len = packet.getLength(); //获取有效的字节个数 String ip = packet.getAddress().getHostAddress();//获取ip地址 int port = packet.getPort(); //获取端口号 System.out.println(ip + \":\" + port + \":\" + new String(arr,0,len));&#125; 发送端Send 123456789101112Scanner sc = new Scanner(System.in); //创建键盘录入对象DatagramSocket socket = new DatagramSocket();//创建Socket相当于创建码头while(true) &#123; String line = sc.nextLine(); //获取键盘录入的字符串 if(\"quit\".equals(line)) &#123; break; &#125; DatagramPacket packet = //创建Packet相当于集装箱 new DatagramPacket(line.getBytes(), line.getBytes().length, InetAddress.getByName(\"127.0.0.1\"), 6666); socket.send(packet); //发货,将数据发出去&#125;socket.close(); //关闭码头 UDP传输多线程 A发送和接收在一个窗口完成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.wxhao.socket;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import java.net.UnknownHostException;import java.util.Scanner;public class Demo3_MoreThread &#123; public static void main(String[] args) &#123; new Receive().start(); new Send().start(); &#125;&#125;class Receive extends Thread &#123; public void run() &#123; try &#123; DatagramSocket socket = new DatagramSocket(6666);//创建Socket相当于创建码头 DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);//创建Packet相当于创建集装箱 while(true) &#123; socket.receive(packet); //接货,接收数据 byte[] arr = packet.getData(); //获取数据 int len = packet.getLength(); //获取有效的字节个数 String ip = packet.getAddress().getHostAddress();//获取ip地址 int port = packet.getPort(); //获取端口号 System.out.println(ip + \":\" + port + \":\" + new String(arr,0,len)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Send extends Thread &#123; public void run() &#123; try &#123; Scanner sc = new Scanner(System.in); //创建键盘录入对象 DatagramSocket socket = new DatagramSocket(); //创建Socket相当于创建码头 while(true) &#123; String line = sc.nextLine(); //获取键盘录入的字符串 if(\"quit\".equals(line)) &#123; break; &#125; DatagramPacket packet = //创建Packet相当于集装箱 new DatagramPacket(line.getBytes(), line.getBytes().length, InetAddress.getByName(\"127.0.0.1\"), 6666); socket.send(packet); //发货,将数据发出去 &#125; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; UDP聊天图形化界面 UDP聊天发送功能UDP聊天记录功能UDP聊天清屏功能UDP聊天震动功能UDP聊天快捷键和代码优化UDP聊天生成jar文件 可以用eclipse生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275package com.wxhao.socket;import java.awt.BorderLayout;import java.awt.Button;import java.awt.Color;import java.awt.Font;import java.awt.Frame;import java.awt.Panel;import java.awt.TextArea;import java.awt.TextField;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.BufferedWriter;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileWriter;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import java.net.UnknownHostException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo4_GUIChat extends Frame &#123; private TextField tf; private Button send; private Button log; private Button clear; private Button shake; private TextArea viewText; private TextArea sendText; private DatagramSocket socket; private BufferedWriter bw; /** * GUI聊天 */ public Demo4_GUIChat() &#123; init(); southPanel(); centerPanel(); event(); &#125; public void event() &#123; this.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; try &#123; socket.close(); bw.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; System.exit(0); &#125; &#125;); send.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; try &#123; send(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125;); log.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; try &#123; logFile(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125;); clear.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; viewText.setText(\"\"); &#125; &#125;); shake.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; try &#123; send(new byte[]&#123;-1&#125;,tf.getText()); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125;); sendText.addKeyListener(new KeyAdapter() &#123; @Override public void keyReleased(KeyEvent e) &#123; //if(e.getKeyCode() == KeyEvent.VK_ENTER &amp;&amp; e.isControlDown()) &#123; //isControlDown ctrl是否被按下 if(e.getKeyCode() == KeyEvent.VK_ENTER) &#123; try &#123; send(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; &#125;); &#125; private void shake() &#123; int x = this.getLocation().x; //获取横坐标位置 int y = this.getLocation().y; //获取纵坐标位置 for(int i = 0; i &lt; 20; i++) &#123; try &#123; this.setLocation(x + 20, y + 20); Thread.sleep(20); this.setLocation(x + 20, y - 20); Thread.sleep(20); this.setLocation(x - 20, y + 20); Thread.sleep(20); this.setLocation(x - 20, y - 20); Thread.sleep(20); this.setLocation(x, y); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void logFile() throws IOException &#123; bw.flush(); //刷新缓冲区 FileInputStream fis = new FileInputStream(\"config.txt\"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); //在内存中创建缓冲区 int len; byte[] arr = new byte[8192]; while((len = fis.read(arr)) != -1) &#123; baos.write(arr, 0, len); &#125; String str = baos.toString(); //将内存中的内容转换成了字符串 viewText.setText(str); fis.close(); &#125; private void send(byte[] arr, String ip) throws IOException &#123; DatagramPacket packet = new DatagramPacket(arr, arr.length, InetAddress.getByName(ip), 9999); socket.send(packet); //发送数据 &#125; private void send() throws IOException &#123; String message = sendText.getText(); //获取发送区域的内容 String ip = tf.getText(); //获取ip地址; ip = ip.trim().length() == 0 ? \"255.255.255.255\" : ip; send(message.getBytes(),ip); String time = getCurrentTime(); //获取当前时间 String str = time + \" 我对:\" + (ip.equals(\"255.255.255.255\") ? \"所有人\" : ip) + \"说\\r\\n\" + message + \"\\r\\n\\r\\n\"; //alt + shift + l 抽取局部变量 viewText.append(str); //将信息添加到显示区域中 bw.write(str); //将信息写到数据库中 sendText.setText(\"\"); &#125; private String getCurrentTime() &#123; Date d = new Date(); //创建当前日期对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); return sdf.format(d); //将时间格式化 &#125; public void centerPanel() &#123; Panel center = new Panel(); //创建中间的Panel viewText = new TextArea(); sendText = new TextArea(5,1); center.setLayout(new BorderLayout()); //设置为边界布局管理器 center.add(sendText,BorderLayout.SOUTH); //发送的文本区域放在南边 center.add(viewText,BorderLayout.CENTER); //显示区域放在中间 viewText.setEditable(false); //设置不可以编辑 viewText.setBackground(Color.WHITE); //设置背景颜色 sendText.setFont(new Font(\"xxx\", Font.PLAIN, 15)); viewText.setFont(new Font(\"xxx\", Font.PLAIN, 15)); this.add(center,BorderLayout.CENTER); &#125; public void southPanel() &#123; Panel south = new Panel(); //创建南边的Panel tf = new TextField(15); tf.setText(\"127.0.0.1\"); send = new Button(\"发 送\"); log = new Button(\"记 录\"); clear = new Button(\"清 屏\"); shake = new Button(\"震 动\"); south.add(tf); south.add(send); south.add(log); south.add(clear); south.add(shake); this.add(south,BorderLayout.SOUTH); //将Panel放在Frame的南边 &#125; public void init() &#123; this.setLocation(500, 50); this.setSize(400, 600); new Receive().start(); try &#123; socket = new DatagramSocket(); bw = new BufferedWriter(new FileWriter(\"config.txt\",true)); //需要在尾部追加 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; this.setVisible(true); &#125; private class Receive extends Thread &#123; //接收和发送需要同时执行,所以定义成多线程的 public void run() &#123; try &#123; DatagramSocket socket = new DatagramSocket(9999); DatagramPacket packet = new DatagramPacket(new byte[8192], 8192); while(true) &#123; socket.receive(packet); //接收信息 byte[] arr = packet.getData(); //获取字节数据 int len = packet.getLength(); //获取有效的字节数据 if(arr[0] == -1 &amp;&amp; len == 1) &#123; //如果发过来的数组第一个存储的值是-1,并且数组长度是1 shake(); //调用震动方法 continue; //终止本次循环,继续下次循环,因为震动后不需要执行下面的代码 &#125; String message = new String(arr,0,len); //转换成字符串 String time = getCurrentTime(); //获取当前时间 String ip = packet.getAddress().getHostAddress(); //获取ip地址 String str = time + \" \" + ip + \" 对我说:\\r\\n\" + message + \"\\r\\n\\r\\n\"; viewText.append(str); bw.write(str); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; new Demo4_GUIChat(); &#125;&#125; TCP协议 1.客户端 创建Socket连接服务端(指定ip地址,端口号)通过ip地址找对应的服务器 调用Socket的getInputStream()和getOutputStream()方法获取和服务端相连的IO流 输入流可以读取服务端输出流写出的数据 输出流可以写出数据到服务端的输入流 123456789101112Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345);InputStream is = socket.getInputStream(); //获取客户端输入流OutputStream os = socket.getOutputStream(); //获取客户端的输出流byte[] arr = new byte[1024];int len = is.read(arr); //读取服务器发过来的数据System.out.println(new String(arr,0,len)); //将数据转换成字符串并打印os.write(&quot;学习挖掘机哪家强?&quot;.getBytes()); //客户端向服务器写数据socket.close(); 2.服务端 创建ServerSocket(需要指定端口号) 调用ServerSocket的accept()方法接收一个客户端请求，得到一个Socket 调用Socket的getInputStream()和getOutputStream()方法获取和客户端相连的IO流 输入流可以读取客户端输出流写出的数据 输出流可以写出数据到客户端的输入流 12345678910111213ServerSocket server = new ServerSocket(12345);Socket socket = server.accept(); //接受客户端的请求InputStream is = socket.getInputStream(); //获取客户端输入流OutputStream os = socket.getOutputStream(); //获取客户端的输出流os.write(\"百度一下你就知道\".getBytes()); //服务器向客户端写出数据byte[] arr = new byte[1024];int len = is.read(arr); //读取客户端发过来的数据System.out.println(new String(arr,0,len)); //将数据转换成字符串并打印socket.close(); TCP协议代码优化 客户端 1234567891011Socket socket = new Socket(\"127.0.0.1\", 9999); //创建Socket指定ip地址和端口号InputStream is = socket.getInputStream(); //获取输入流OutputStream os = socket.getOutputStream(); //获取输出流BufferedReader br = new BufferedReader(new InputStreamReader(is));PrintStream ps = new PrintStream(os);System.out.println(br.readLine());ps.println(\"我想吃火锅\");System.out.println(br.readLine());ps.println(\"爷不吃了\");socket.close(); 服务端 1234567891011121314ServerSocket server = new ServerSocket(9999); //创建服务器Socket socket = server.accept(); //接受客户端的请求InputStream is = socket.getInputStream(); //获取输入流OutputStream os = socket.getOutputStream(); //获取输出流BufferedReader br = new BufferedReader(new InputStreamReader(is));PrintStream ps = new PrintStream(os);ps.println(\"大酬宾\");System.out.println(br.readLine());ps.println(\"卖完了\");System.out.println(br.readLine());server.close();socket.close(); 服务端是多线程的1234567891011121314151617181920ServerSocket server = new ServerSocket(9999); //创建服务器 while(true) &#123; final Socket socket = server.accept(); //接受客户端的请求 new Thread() &#123; public void run() &#123; try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintStream ps = new PrintStream(socket.getOutputStream()); ps.println(\"大酬宾\"); System.out.println(br.readLine()); ps.println(\"卖完了\"); System.out.println(br.readLine()); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125;&#125; 网络编程(练习) 客户端向服务器写字符串(键盘录入),服务器(多线程)将字符串反转后写回,客户端再次读取到是反转后的字符串 服务器 12345678910111213141516171819202122ServerSocket server = new ServerSocket(54321);System.out.println(\"服务器启动,绑定54321端口\");while(true) &#123; final Socket socket = server.accept(); //接受客户端的请求 new Thread() &#123; //开启一条线程 public void run() &#123; try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); //获取输入流 PrintStream ps = new PrintStream(socket.getOutputStream());//获取输出流 String line = br.readLine();//将客户端写过来的数据读取出来 line = new StringBuilder(line).reverse().toString(); //链式编程 ps.println(line); //反转后写回去 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start();&#125; 12345678910Scanner sc = new Scanner(System.in); //创建键盘录入对象Socket socket = new Socket(\"127.0.0.1\", 54321); //创建客户端,指定ip地址和端口号BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); //获取输入流PrintStream ps = new PrintStream(socket.getOutputStream());//获取输出流ps.println(sc.nextLine()); //将字符串写到服务器去System.out.println(br.readLine()); //将反转后的结果读出来socket.close(); 网络编程(练习) 客户端向服务器上传文件 客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) throws UnknownHostException, IOException &#123; // 1.提示输入要上传的文件路径, 验证路径是否存在以及是否是文件夹 File file = getFile(); // 2.发送文件名到服务端 Socket socket = new Socket(\"127.0.0.1\", 12345); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintStream ps = new PrintStream(socket.getOutputStream()); ps.println(file.getName()); // 6.接收结果, 如果存在给予提示, 程序直接退出 String result = br.readLine(); //读取存在后不存在的结果 if(\"存在\".equals(result)) &#123; System.out.println(\"您上传的文件已经存在,请不要重复上传\"); socket.close(); return; &#125; // 7.如果不存在, 定义FileInputStream读取文件, 写出到网络 FileInputStream fis = new FileInputStream(file); byte[] arr = new byte[8192]; int len; while((len = fis.read(arr)) != -1) &#123; ps.write(arr, 0, len); &#125; fis.close(); socket.close();&#125;private static File getFile() &#123; Scanner sc = new Scanner(System.in); //创建键盘录入对象 System.out.println(\"请输入一个文件路径:\"); while(true) &#123; String line = sc.nextLine(); File file = new File(line); if(!file.exists()) &#123; System.out.println(\"您录入的文件路径不存在,请重新录入:\"); &#125;else if(file.isDirectory()) &#123; System.out.println(\"您录入的是文件夹路径,请输入一个文件路径:\"); &#125;else &#123; return file; &#125; &#125;&#125; 服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445//3,建立多线程的服务器ServerSocket server = new ServerSocket(12345);System.out.println(\"服务器启动,绑定12345端口号\");//4.读取文件名while(true) &#123; final Socket socket = server.accept(); //接受请求 new Thread() &#123; public void run() &#123; try &#123; InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); PrintStream ps = new PrintStream(socket.getOutputStream()); String fileName = br.readLine(); //5.判断文件是否存在, 将结果发回客户端 File dir = new File(\"update\"); dir.mkdir(); //创建文件夹 File file = new File(dir,fileName); //封装成File对象 if(file.exists()) &#123; //如果服务器已经存在这个文件 ps.println(\"存在\"); //将存在写给客户端 socket.close(); //关闭socket return; &#125;else &#123; ps.println(\"不存在\"); &#125; //8.定义FileOutputStream, 从网络读取数据, 存储到本地 FileOutputStream fos = new FileOutputStream(file); byte[] arr = new byte[8192]; int len; while((len = is.read(arr)) != -1) &#123; fos.write(arr, 0, len); &#125; fos.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start();&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - 多线程 加强","date":"2013-10-19T16:00:00.000Z","path":"2013/10/20/2013-10-20-thread-two/","text":"JavaSE - 多线程 加强 单例设计模式 单例设计模式：保证类在内存中只有一个对象。 如何保证类在内存中只有一个对象呢？ (1)控制类的创建，不让其他类来创建本类的对象。private (2)在本类中定义一个本类的对象。Singleton s; (3)提供公共的访问方式。 public static Singleton getInstance(){return s} 单例写法两种： (1)饿汉式 开发用这种方式。 12345678910class Singleton &#123; //1,私有构造方法,其他类不能访问该构造方法了 private Singleton()&#123;&#125; //2,创建本类对象 private static Singleton s = new Singleton(); //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; //获取实例 return s; &#125;&#125; (2)懒汉式 面试写这种方式。多线程的问题？ 懒汉式,单例的延迟加载模式 12345678910111213141516//懒汉式,单例的延迟加载模式class Singleton &#123;//1,私有构造方法,其他类不能访问该构造方法了private Singleton()&#123;&#125;//2,声明一个引用private static Singleton s ;//3,对外提供公共的访问方法public static Singleton getInstance() &#123; //获取实例 if(s == null) &#123; //线程1等待,线程2等待 s = new Singleton(); &#125; return s;&#125;&#125; 饿汉式和懒汉式的区别 饿汉式是空间换时间,懒汉式是时间换空间 在多线程访问时,饿汉式不会创建多个对象,而懒汉式有可能会创建多个对象 (3)第三种格式 123456class Singleton &#123; //1,私有构造方法,其他类不能访问该构造方法了 private Singleton()&#123;&#125; //2,声明一个引用 public static final Singleton s = new Singleton();&#125; Runtime类 Runtime类是一个单例类 123Runtime r = Runtime.getRuntime();//r.exec(\"shutdown -s -t 300\"); //300秒后关机r.exec(\"shutdown -a\"); //取消关机 Timer Timer类:计时器 12345678910111213141516171819202122232425public class Demo3_Timer &#123; /** * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; Timer t = new Timer(); //在指定时间安排指定任务 //第一个参数,是安排的任务,第二个参数是执行的时间,第三个参数是过多长时间再重复执行 t.schedule(new MyTimerTask(), new Date(188, 6, 1, 14, 22, 50),3000); while(true) &#123; Thread.sleep(1000); System.out.println(new Date()); &#125; &#125;&#125;class MyTimerTask extends TimerTask &#123; @Override public void run() &#123; System.out.println(\"起床背英语单词\"); &#125;&#125; 传入时间查看API,实例为20880601142250 两个线程间的通信 1.什么时候需要通信 多个线程并发执行时, 在默认情况下CPU是随机切换线程的 如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印 2.怎么通信 如果希望线程等待, 就调用wait() 如果希望唤醒等待的线程, 就调用notify(); 这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.wxhao.thread2;public class Demo1_Notify &#123; /** * 等待唤醒机制 */ public static void main(String[] args) &#123; final Printer p = new Printer(); new Thread() &#123; public void run() &#123; while(true) &#123; try &#123; p.print1(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; try &#123; p.print2(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125;&#125;//等待唤醒机制class Printer &#123; private int flag = 1; public void print1() throws InterruptedException &#123; synchronized(this) &#123; if(flag != 1) &#123; this.wait(); //当前线程等待 &#125; System.out.print(\"我\"); System.out.print(\"是\"); System.out.print(\"大\"); System.out.print(\"帅\"); System.out.print(\"哔\"); System.out.print(\"\\r\\n\"); flag = 2; this.notify(); //随机唤醒单个等待的线程 &#125; &#125; public void print2() throws InterruptedException &#123; synchronized(this) &#123; if(flag != 2) &#123; this.wait(); &#125; System.out.print(\"吴\"); System.out.print(\"酷\"); System.out.print(\"浩\"); System.out.print(\"\\r\\n\"); flag = 1; this.notify(); &#125; &#125;&#125; 三个或三个以上间的线程通信 多个线程通信的问题 notify()方法是随机唤醒一个线程 notifyAll()方法是唤醒所有线程 JDK5之前无法唤醒指定的一个线程 如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.wxhao.thread2;public class Demo2_NotifyAll &#123; public static void main(String[] args) &#123; final Printer2 p = new Printer2(); new Thread() &#123; public void run() &#123; while(true) &#123; try &#123; p.print1(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; try &#123; p.print2(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; try &#123; p.print3(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125;&#125;class Printer2 &#123; private int flag = 1; public void print1() throws InterruptedException &#123; synchronized(this) &#123; while(flag != 1) &#123; this.wait(); //当前线程等待 &#125; System.out.print(\"我\"); System.out.print(\"是\"); System.out.print(\"大\"); System.out.print(\"帅\"); System.out.print(\"哔\"); System.out.print(\"\\r\\n\"); flag = 2; //this.notify(); //随机唤醒单个等待的线程 this.notifyAll(); &#125; &#125; public void print2() throws InterruptedException &#123; synchronized(this) &#123; while(flag != 2) &#123; this.wait(); //线程2在此等待 &#125; System.out.print(\"吴\"); System.out.print(\"酷\"); System.out.print(\"浩\"); System.out.print(\"\\r\\n\"); flag = 3; //this.notify(); this.notifyAll(); &#125; &#125; public void print3() throws InterruptedException &#123; synchronized(this) &#123; while(flag != 3) &#123; this.wait(); //线程3在此等待,if语句是在哪里等待,就在哪里起来 //while循环是循环判断,每次都会判断标记 &#125; System.out.print(\"刘\"); System.out.print(\"二\"); System.out.print(\"圆\"); System.out.print(\"\\r\\n\"); flag = 1; //this.notify(); this.notifyAll(); &#125; &#125;&#125; 1,在同步代码块中,用哪个对象锁,就用哪个对象调用wait方法 2,为什么wait方法和notify方法定义在Object这类中? 因为锁对象可以是任意对象,Object是所有的类的基类,所以wait方法和notify方法需要定义在Object这个类中 3,sleep方法和wait方法的区别? sleep方法必须传入参数,参数就是时间,时间到了自动醒来wait方法可以传入参数也可以不传入参数,传入参数就是在参数的时间结束后等待,不传入参数就是直接等待 sleep方法在同步函数或同步代码块中,不释放锁,睡着了也抱着锁睡wait方法在同步函数或者同步代码块中,释放锁 JDK1.5的新特性互斥锁 1.同步 使用ReentrantLock类的lock()和unlock()方法进行同步 2.通信 使用ReentrantLock类的newCondition()方法可以获取Condition对象 需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法 不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.wxhao.thread2;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class Demo3_ReentrantLock &#123; public static void main(String[] args) &#123; final Printer3 p = new Printer3(); new Thread() &#123; public void run() &#123; while(true) &#123; try &#123; p.print1(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; try &#123; p.print2(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; try &#123; p.print3(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125;&#125;class Printer3 &#123; private ReentrantLock r = new ReentrantLock(); private Condition c1 = r.newCondition(); private Condition c2 = r.newCondition(); private Condition c3 = r.newCondition(); private int flag = 1; public void print1() throws InterruptedException &#123; r.lock(); //获取锁 if(flag != 1) &#123; c1.await(); &#125; System.out.print(\"我\"); System.out.print(\"是\"); System.out.print(\"大\"); System.out.print(\"帅\"); System.out.print(\"哔\"); System.out.print(\"\\r\\n\"); flag = 2; //this.notify(); //随机唤醒单个等待的线程 c2.signal(); r.unlock(); //释放锁 &#125; public void print2() throws InterruptedException &#123; r.lock(); if(flag != 2) &#123; c2.await(); &#125; System.out.print(\"吴\"); System.out.print(\"酷\"); System.out.print(\"浩\"); System.out.print(\"\\r\\n\"); flag = 3; //this.notify(); c3.signal(); r.unlock(); &#125; public void print3() throws InterruptedException &#123; r.lock(); if(flag != 3) &#123; c3.await(); &#125; System.out.print(\"刘\"); System.out.print(\"二\"); System.out.print(\"圆\"); System.out.print(\"\\r\\n\"); flag = 1; c1.signal(); r.unlock(); &#125;&#125; 线程组的概述和使用 线程组概述 Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 默认情况下，所有的线程都属于主线程组。 public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组 public final String getName()//通过线程组对象获取他组的名字 我们也可以给线程设置分组 1,ThreadGroup(String name) 创建线程组对象并给其赋值名字 2,创建线程对象 3,Thread(ThreadGroup?group, Runnable?target, String?name) 4,设置整组的优先级或者守护线程 线程组的使用,默认是主线程组 123456789101112131415MyRunnable mr = new MyRunnable();Thread t1 = new Thread(mr, \"张三\");Thread t2 = new Thread(mr, \"李四\");//获取线程组// 线程类里面的方法：public final ThreadGroup getThreadGroup()ThreadGroup tg1 = t1.getThreadGroup();ThreadGroup tg2 = t2.getThreadGroup();// 线程组里面的方法：public final String getName()String name1 = tg1.getName();String name2 = tg2.getName();System.out.println(name1);System.out.println(name2);// 通过结果我们知道了：线程默认情况下属于main线程组// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组System.out.println(Thread.currentThread().getThreadGroup().getName()); 自己设定线程组 12345678910111213// ThreadGroup(String name)ThreadGroup tg = new ThreadGroup(\"这是一个新的组\");MyRunnable mr = new MyRunnable();// Thread(ThreadGroup group, Runnable target, String name)Thread t1 = new Thread(tg, mr, \"张三\");Thread t2 = new Thread(tg, mr, \"李四\");System.out.println(t1.getThreadGroup().getName());System.out.println(t2.getThreadGroup().getName());//通过组名称设置后台线程，表示该组的线程都是后台线程tg.setDaemon(true); 线程的五种状态 看图说话 新建,就绪,运行,阻塞,死亡 线程池的概述和使用 线程池概述 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池 内置线程池的使用概述 JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法 public static ExecutorService newFixedThreadPool(int nThreads) public static ExecutorService newSingleThreadExecutor() 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法 Future&lt;?&gt; submit(Runnable task) Future submit(Callable task) 使用步骤： 创建线程池对象 创建Runnable实例 提交Runnable实例 关闭线程池 提交的是Runnable 123456789// public static ExecutorService newFixedThreadPool(int nThreads)ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程pool.submit(new MyRunnable());pool.submit(new MyRunnable());//结束线程池pool.shutdown(); 多线程程序实现的方式3 提交的是Callable 12345678910111213141516171819202122232425262728293031323334// 创建线程池对象ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100));Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200));// V get()Integer i1 = f1.get();Integer i2 = f2.get();System.out.println(i1);System.out.println(i2);// 结束pool.shutdown();public class MyCallable implements Callable&lt;Integer&gt; &#123; private int number; public MyCallable(int number) &#123; this.number = number; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int x = 1; x &lt;= number; x++) &#123; sum += x; &#125; return sum; &#125;&#125; 多线程程序实现的方式3的好处和弊端 好处： 可以有返回值 可以抛出异常 弊端： 代码比较复杂，所以一般不用 简单工厂模式概述和使用 简单工厂模式概述 又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例 优点 客户端不需要在负责对象的创建，从而明确了各个类的职责 缺点 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护 动物抽象类：public abstract Animal { public abstract void eat(); } 具体狗类：public class Dog extends Animal {} 具体猫类：public class Cat extends Animal {} 开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。 12345678910111213141516public class AnimalFactory &#123; private AnimalFactory()&#123;&#125; //public static Dog createDog() &#123;return new Dog();&#125; //public static Cat createCat() &#123;return new Cat();&#125; //改进 public static Animal createAnimal(String animalName) &#123; if(“dog”.equals(animalName)) &#123;&#125; else if(“cat”.equals(animale)) &#123; &#125;else &#123; return null; &#125; &#125;&#125; 工厂方法模式的概述和使用 工厂方法模式概述 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。 优点 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性 缺点 需要额外的编写代码，增加了工作量 D:案例演示 1234567891011动物抽象类：public abstract Animal &#123; public abstract void eat(); &#125;工厂接口：public interface Factory &#123;public abstract Animal createAnimal();&#125;具体狗类：public class Dog extends Animal &#123;&#125;具体猫类：public class Cat extends Animal &#123;&#125;开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。狗工厂：public class DogFactory implements Factory &#123; public Animal createAnimal() &#123;…&#125; &#125;猫工厂：public class CatFactory implements Factory &#123; public Animal createAnimal() &#123;…&#125; &#125; 如何创建一个窗口并显示 Graphical User Interface(图形用户接口)。 123456Frame f = new Frame(“my window”);f.setLayout(new FlowLayout());//设置布局管理器f.setSize(500,400);//设置窗体大小f.setLocation(300,200);//设置窗体出现在屏幕的位置f.setIconImage(Toolkit.getDefaultToolkit().createImage(\"qq.png\"));f.setVisible(true); 布局管理器 FlowLayout（流式布局管理器） 从左到右的顺序排列。 Panel默认的布局管理器。 BorderLayout（边界布局管理器） 东，南，西，北，中 Frame默认的布局管理器。 GridLayout（网格布局管理器） 规则的矩阵 CardLayout（卡片布局管理器） 选项卡 GridBagLayout（网格包布局管理器） 非规则的矩阵 窗体监听123456789Frame f = new Frame(\"我的窗体\");//事件源是窗体,把监听器注册到事件源上//事件对象传递给监听器f.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; //退出虚拟机,关闭窗口 System.exit(0); &#125;&#125;); 鼠标监听 addMouseListener 键盘监听和键盘事件 addKeyListener 动作监听 addActionListener 绑定空格和鼠标单左键 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.wxhao.gui;import java.awt.Button;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;public class Demo1_Frame &#123; public static void main(String[] args) &#123; Frame f = new Frame(\"我的第一个窗口\"); f.setSize(400, 600); //设置窗体大小 f.setLocation(500, 50); //设置窗体位置 f.setIconImage(Toolkit.getDefaultToolkit().createImage(\"qq.png\")); Button b1 = new Button(\"按钮一\"); Button b2 = new Button(\"按钮二\"); f.add(b1); f.add(b2); f.setLayout(new FlowLayout()); //设置布局管理器 //f.addWindowListener(new MyWindowAdapter()); //窗口监听 f.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); //鼠标监听 b1.addMouseListener(new MouseAdapter() &#123; /*@Override public void mouseClicked(MouseEvent e) &#123; //单击 System.exit(0); &#125;*/ @Override public void mouseReleased(MouseEvent e) &#123; //释放 System.exit(0); &#125; &#125;); //键盘监听 b1.addKeyListener(new KeyAdapter() &#123; @Override public void keyReleased(KeyEvent e) &#123; //System.exit(0); //System.out.println(e.getKeyCode()); //if(e.getKeyCode() == 32) &#123; if(e.getKeyCode() == KeyEvent.VK_SPACE)&#123; System.exit(0); &#125; &#125; &#125;); //添加动作监听,应用场景就是暂停视频和播放视频 b2.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.exit(0); &#125; &#125;); f.setVisible(true); //设置窗体可见 &#125;&#125;/*class MyWindowListener implements WindowListener &#123; @Override public void windowOpened(WindowEvent e) &#123; &#125; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; @Override public void windowClosed(WindowEvent e) &#123; System.out.println(\"Closed\"); &#125; @Override public void windowIconified(WindowEvent e) &#123; &#125; @Override public void windowDeiconified(WindowEvent e) &#123; &#125; @Override public void windowActivated(WindowEvent e) &#123; &#125; @Override public void windowDeactivated(WindowEvent e) &#123; &#125;&#125;*//*class MyWindowAdapter extends WindowAdapter &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125;&#125;*/ 适配器设计模式 什么是适配器 在使用监听器的时候, 需要定义一个类事件监听器接口. 通常接口中有多个方法, 而程序中不一定所有的都用到, 但又必须重写, 这很繁琐. 适配器简化了这些操作, 我们定义监听器时只要继承适配器, 然后重写需要的方法即可. 适配器原理 适配器就是一个类, 实现了监听器接口, 所有抽象方法都重写了, 但是方法全是空的. 适配器类需要定义成抽象的,因为创建该类对象,调用空方法是没有意义的 目的就是为了简化程序员的操作, 定义监听器时继承适配器, 只重写需要的方法就可以了. 12345678910111213141516171819202122232425262728interface 和尚 &#123; public void 打坐(); public void 念经(); public void 撞钟(); public void 习武();&#125;//声明成抽象的原因是,不想让其他类创建本类对象,因为创建也没有意义,方法都是空的abstract class 天罡星 implements 和尚 &#123; @Override public void 打坐() &#123;&#125; @Override public void 念经() &#123;&#125; @Override public void 撞钟() &#123;&#125; @Override public void 习武() &#123;&#125;&#125;class 鲁智深 extends 天罡星 &#123; public void 习武() &#123; System.out.println(\"倒拔垂杨柳\"); System.out.println(\"拳打镇关西\"); System.out.println(\"大闹野猪林\"); System.out.println(\"......\"); &#125;&#125; GUI(需要知道的) 事件处理 事件: 用户的一个操作 事件源: 被操作的组件 监听器: 一个自定义类的对象, 实现了监听器接口, 包含事件处理方法,把监听器添加在事件源上, 当事件发生的时候虚拟机就会自动调用监听器中的事件处理方法","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - 多线程","date":"2013-10-14T16:00:00.000Z","path":"2013/10/15/2013-10-15-thread-one/","text":"JavaSE - 多线程 多线程的引入 1.什么是线程 线程是程序执行的一条路径, 一个进程中可以包含多条线程 多线程并发执行可以提高程序的效率, 可以同时完成多项工作 2.多线程的应用场景 红蜘蛛同时共享屏幕给多个电脑 迅雷开启多条线程一起下载 QQ同时和多个人一起视频 服务器同时处理多个客户端请求 多线程并行和并发的区别 并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU) 并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。 比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。 如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。 Java程序运行原理和JVM的启动是多线程的吗 Java程序运行原理 Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。 JVM的启动是多线程的吗 JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。 123456789101112131415161718192021222324 /** * @param args * 证明jvm是多线程的 */ public static void main(String[] args) &#123; for(int i = 0; i &lt; 100000; i++) &#123; new Demo(); &#125; for(int i = 0; i &lt; 10000; i++) &#123; System.out.println(\"我是主线程的执行代码\"); &#125; &#125;&#125;class Demo &#123; @Override public void finalize() &#123; System.out.println(\"垃圾被清扫了\"); &#125; &#125; 多线程程序实现的方式1 1.继承Thread 定义类继承Thread 重写run方法 把新线程要做的事写在run方法中 创建线程对象 开启新线程, 内部会自动执行run方法 1234567891011121314151617181920public class Demo2_Thread &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); //4,创建Thread类的子类对象 mt.start(); //5,开启线程 for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"bb\"); &#125; &#125;&#125;class MyThread extends Thread &#123; //1,继承Thread public void run() &#123; //2,重写run方法 for(int i = 0; i &lt; 1000; i++) &#123; //3,将要执行的代码写在run方法中 System.out.println(\"aaaaaaaaaaaa\"); &#125; &#125;&#125; 多线程程序实现的方式 2.实现Runnable 定义类实现Runnable接口 实现run方法 把新线程要做的事写在run方法中 创建自定义的Runnable的子类对象 创建Thread对象, 传入Runnable 调用start()开启新线程, 内部会自动调用Runnable的run()方法 1234567891011121314151617181920212223242526public class Demo3_Thread &#123; /** * @param args */ public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); //4,创建Runnable的子类对象 //Runnable target = mr; mr = 0x0011 Thread t = new Thread(mr); //5,将其当作参数传递给Thread的构造函数 t.start(); //6,开启线程 for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"bb\"); &#125; &#125;&#125;class MyRunnable implements Runnable &#123; //1,定义一个类实现Runnable @Override public void run() &#123; //2,重写run方法 for(int i = 0; i &lt; 1000; i++) &#123; //3,将要执行的代码写在run方法中 System.out.println(\"aaaaaaaaaaaa\"); &#125; &#125;&#125; 实现Runnable的原理 查看源码 1,看Thread类的构造函数,传递了Runnable接口的引用 2,通过init()方法找到传递的target给成员变量的target赋值 3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法 两种方式的区别 查看源码的区别: 继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法 实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法 继承Thread 好处是:可以直接使用Thread类中的方法,代码简单 弊端是:如果已经有了父类,就不能用这种方法 实现Runnable接口 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂 匿名内部类实现线程的两种方式 继承Thread类 1234567new Thread() &#123; //1,继承Thread类public void run() &#123; //2,重写run方法 for(int i = 0; i &lt; 1000; i++) &#123;//3,将要执行的代码写在run方法中 System.out.println(\"aaaaaaaaaaaaaa\"); &#125;&#125;&#125;.start(); //4,开启线程 实现Runnable接口 12345678new Thread(new Runnable() &#123; //1,将Runnable的子类对象传递给Thread的构造方法public void run() &#123; //2,重写run方法 for(int i = 0; i &lt; 1000; i++) &#123; //3,将要执行的代码写在run方法中 System.out.println(&quot;bb&quot;); &#125;&#125;&#125;).start(); //4,开启线程&#125; 获取名字和设置名字 1.获取名字 通过getName()方法获取线程对象的名字 2.设置名字 通过构造函数可以传入String类型的名字 1234567891011new Thread(\"芙蓉姐姐\") &#123; //通过构造方法给name赋值 public void run() &#123; System.out.println(this.getName() + \"....aaaaaaaaa\"); &#125;&#125;.start();new Thread(\"凤姐\") &#123; public void run() &#123; System.out.println(this.getName() + \"....bb\"); &#125;&#125;.start(); 通过setName(String)方法可以设置线程对象的名字123456789101112131415161718Thread t1 = new Thread() &#123; public void run() &#123; //this.setName(\"张三\"); System.out.println(this.getName() + \"....aaaaaaaaaaaaa\"); &#125;&#125;;Thread t2 = new Thread() &#123; public void run() &#123; //this.setName(\"李四\"); System.out.println(this.getName() + \"....bb\"); &#125;&#125;;t1.setName(\"张三\");t2.setName(\"李四\");t1.start();t2.start(); 获取当前线程的对象 Thread.currentThread(), 主线程也可以获取 1234567891011121314151617new Thread(new Runnable() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + \"...aaaaaaaaaaaaaaaaaaaaa\"); &#125; &#125;&#125;).start();new Thread(new Runnable() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123;//Thread.currentThread()获取当前正在执行的线程 System.out.println(Thread.currentThread().getName() + \"...bb\"); &#125; &#125;&#125;).start();Thread.currentThread().setName(\"我是主线程\"); //获取主函数线程的引用,并改名字System.out.println(Thread.currentThread().getName()); //获取主函数线程的引用,并获取名字 休眠线程 Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 1000 1000纳秒 1000000000 1234for(int i = 20; i &gt;= 0; i--) &#123; Thread.sleep(1000); System.out.println(\"倒计时第\" +i + \"秒\");&#125; 12345678910111213141516171819202122232425262728new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; try &#123; //父类没抛异常,子类必须自己处理 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + \"...aaaaaaaaaa\"); &#125; &#125;&#125;.start();new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + \"...bb\"); &#125; &#125;&#125;.start();&#125; 守护线程 setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出 象棋举例,车马相士(守护线程),将帅(非守护线程)死后,其它的子也会死 1234567891011121314151617181920Thread t1 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 2; i++) &#123; System.out.println(getName() + \"...aaaaaaaaaaaaaaaaaaaa\"); &#125; &#125;&#125;;Thread t2 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; System.out.println(getName() + \"...bb\"); &#125; &#125;&#125;;t2.setDaemon(true); //设置为守护线程t1.start();t2.start(); 从输出结果可以看出,线程2并没有执行完,而是在线程1执行完后,就停止了 QQ主界面是非守护线程,传输窗口为守护线程,关闭QQ主界面,传输窗口也会随之退出,但不会立即退出,会有一个接受关闭命令的缓冲时间 加入线程 join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续 相当于插队 join(int), 可以等待指定的毫秒之后继续 12345678910111213141516171819202122232425262728final Thread t1 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + \"...aaaaaaaaaaaaa\"); &#125; &#125;&#125;;Thread t2 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; if(i == 2) &#123; try &#123; //匿名内部类调用的方法对象必须要用final 修饰 //t1.join(); t1.join(1); //插队指定的时间,过了指定时间后,两条线程交替执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(getName() + \"...bb\"); &#125; &#125;&#125;;t1.start();t2.start(); 礼让线程 yield让出cpu 实际效果不明显 1234567891011121314151617181920 /** * yield让出cpu礼让线程 */ public static void main(String[] args) &#123; new MyThread().start(); new MyThread().start(); &#125;&#125;class MyThread extends Thread &#123; public void run() &#123; for(int i = 1; i &lt;= 1000; i++) &#123; if(i % 10 == 0) &#123; Thread.yield(); //让出CPU &#125; System.out.println(getName() + \"...\" + i); &#125; &#125;&#125; 设置线程的优先级 setPriority()设置线程的优先级 效果不明显,看得出一点儿效果 优先级最大是10,最小是1,默认是5 123456789101112131415161718192021222324Thread t1 = new Thread()&#123; public void run() &#123; for(int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + \"...aaaaaaaaa\" ); &#125; &#125;&#125;;Thread t2 = new Thread()&#123; public void run() &#123; for(int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + \"...bb\" ); &#125; &#125;&#125;;//t1.setPriority(10); 设置最大优先级//t2.setPriority(1);t1.setPriority(Thread.MIN_PRIORITY);//设置最小的线程优先级t2.setPriority(Thread.MAX_PRIORITY);//设置最大的线程优先级t1.start();t2.start(); 同步代码块 1.什么情况下需要同步 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步. 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码. 2.同步代码块 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 public static void main(String[] args) &#123; //匿名内部调用类局部变量 要用final修饰 final Printer p = new Printer(); new Thread() &#123; public void run() &#123; while(true) &#123; p.print1(); &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; p.print2(); &#125; &#125; &#125;.start(); &#125;&#125;class Printer &#123; Demo d = new Demo(); public void print1() &#123; //synchronized(new Demo()) &#123;//同步代码块,锁机制,锁对象可以是任意的 synchronized(d) &#123;//为了保证输出的字符连成一句话,所以要让方法执行完前不执行另一个方法 System.out.print(\"我\"); System.out.print(\"是\"); System.out.print(\"大\"); System.out.print(\"帅\"); System.out.print(\"哔\"); System.out.print(\"\\r\\n\"); &#125; &#125; public void print2() &#123; //synchronized(new Demo()) &#123;//锁对象不能用匿名对象,因为匿名对象不是同一个对象 synchronized(d) &#123; System.out.print(\"吴\"); System.out.print(\"酷\"); System.out.print(\"浩\"); System.out.print(\"\\r\\n\"); &#125; &#125;&#125;class Demo&#123;&#125; 可以先屏蔽锁的代码,查看输出内容发现,会有问题一行字可能会多字,可能会少字 锁就相当于门,一个人进厕所关了门,另一个人是进不去的,要等这个人结束才能进去 锁可以是任意同一个对象 同步方法 使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的 非静态的同步方法的锁对象是神马? 非静态的同步方法的锁对象是this 静态的同步方法的锁对象是什么? 是该类的字节码对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Demo2_Synchronized &#123; /** * @param args * 同步代码块 */ public static void main(String[] args) &#123; final Printer2 p = new Printer2(); new Thread() &#123; public void run() &#123; while(true) &#123; p.print1(); &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; p.print2(); &#125; &#125; &#125;.start(); &#125;&#125;class Printer2 &#123; Demo d = new Demo(); public static synchronized void print1() &#123; //同步方法只需要在方法上加synchronized关键字即可 System.out.print(\"我\"); System.out.print(\"是\"); System.out.print(\"大\"); System.out.print(\"帅\"); System.out.print(\"哔\"); System.out.print(\"\\r\\n\"); &#125; public static void print2() &#123; //synchronized(new Demo()) &#123; //锁对象不能用匿名对象,因为匿名对象不是同一个对象 synchronized(Printer2.class) &#123; System.out.print(\"吴\"); System.out.print(\"嘉\"); System.out.print(\"图\"); System.out.print(\"\\r\\n\"); &#125; &#125;&#125; 线程安全问题 多线程并发操作同一数据时, 就有可能出现线程安全问题 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作 需求:铁路售票,一共100张,通过四个窗口卖完. 12345678910111213141516171819202122232425262728293031323334public class Demo3_Ticket &#123; /** * 需求:铁路售票,一共100张,通过四个窗口卖完. */ public static void main(String[] args) &#123; new Ticket().start(); new Ticket().start(); new Ticket().start(); new Ticket().start(); &#125;&#125;class Ticket extends Thread &#123; private static int ticket = 100; //private static Object obj = new Object(); //如果用引用数据类型成员变量当作锁对象,必须是静态的 public void run() &#123; while(true) &#123; synchronized(Ticket.class) &#123; if(ticket &lt;= 0) &#123; break; &#125; try &#123; Thread.sleep(10); //线程1睡,线程2睡,线程3睡,线程4睡 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + \"...这是第\" + ticket-- + \"号票\"); &#125; &#125; &#125;&#125; 相同类的不同对象调用同一个方法使用共同值时会有问题,所以要用锁,不同对象要锁一个静态的对象,才能同步 火车站卖票的例子用实现Runnable接口123456789101112131415161718192021222324252627282930313233343536373839404142public class Demo4_Ticket &#123; /** * 火车站卖票的例子用实现Runnable接口 */ public static void main(String[] args) &#123; MyTicket mt = new MyTicket(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); /*Thread t1 = new Thread(mt); //多次启动一个线程是非法的 t1.start(); t1.start(); t1.start(); t1.start();*/ &#125;&#125;class MyTicket implements Runnable &#123; private int tickets = 100; @Override public void run() &#123; while(true) &#123; synchronized(this) &#123; if(tickets &lt;= 0) &#123; break; &#125; try &#123; Thread.sleep(10); //线程1睡,线程2睡,线程3睡,线程4睡 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"...这是第\" + tickets-- + \"号票\"); &#125; &#125; &#125;&#125; 实现了Runnable接口,所以开启多线程时可以用一个对象,对象锁使用this就可以同步 死锁 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁 尽量不要嵌套使用 12345678910111213141516171819202122232425262728293031323334 /** * 哲学家们吃饭,一人只有一只筷子,都想说服别人把筷子给自己,然而谁也说不过谁,最后就被饿死了 */ private static String s1 = \"筷子左\"; private static String s2 = \"筷子右\"; public static void main(String[] args) &#123; new Thread() &#123; public void run() &#123; while(true) &#123; synchronized(s1) &#123; System.out.println(getName() + \"...获取\" + s1 + \"等待\" + s2); synchronized(s2) &#123; System.out.println(getName() + \"...拿到\" + s2 + \"开吃\"); &#125; &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; synchronized(s2) &#123; System.out.println(getName() + \"...获取\" + s2 + \"等待\" + s1); synchronized(s1) &#123; System.out.println(getName() + \"...拿到\" + s1 + \"开吃\"); &#125; &#125; &#125; &#125; &#125;.start(); &#125;&#125; 以上代码,会让程序锁死 以前的线程安全的类回顾 回顾的线程安全问题 看源码：Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx) Vector是线程安全的,ArrayList是线程不安全的 StringBuffer是线程安全的,StringBuilder是线程不安全的 Hashtable是线程安全的,HashMap是线程不安全的 Collections.synchroinzed(xxx) 可以把线程不安全的集合变成线程安全的","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE之IO流 - File类练习","date":"2013-10-09T16:00:00.000Z","path":"2013/10/10/2013-10-10-io-file/","text":"JavaSE之IO流 - File类练习 统计该文件夹大小 需求:1,从键盘接收一个文件夹路径,统计该文件夹大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 从键盘接收一个文件夹路径 * 1,创建键盘录入对象 * 2,定义一个无限循环 * 3,将键盘录入的结果存储并封装成File对象 * 4,对File对象判断 * 5,将文件夹路径对象返回 * * 统计该文件夹大小 * 1,定义一个求和变量 * 2,获取该文件夹下所有的文件和文件夹listFiles(); * 3,遍历数组 * 4,判断是文件就计算大小并累加 * 5,判断是文件夹,递归调用 */public static void main(String[] args) &#123; //File dir = new File(\"F:\\\\day06\"); //System.out.println(dir.length()); //直接获取文件夹的结果是0 File dir = getDir(); System.out.println(getFileLength(dir)); &#125;/* * 从键盘接收一个文件夹路径 * 1,返回值类型File * 2,参数列表无 */public static File getDir() &#123; //1,创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个文件夹路径:\"); //2,定义一个无限循环 while(true) &#123; //3,将键盘录入的结果存储并封装成File对象 String line = sc.nextLine(); File dir = new File(line); //4,对File对象判断 if(!dir.exists()) &#123; System.out.println(\"您录入的文件夹路径不存在,请输入一个文件夹路径:\"); &#125;else if(dir.isFile()) &#123; System.out.println(\"您录入的是文件路径,请输入一个文件夹路径:\"); &#125;else &#123; //5,将文件夹路径对象返回 return dir; &#125; &#125; &#125;/* * 统计该文件夹大小 * 1,返回值类型long * 2,参数列表File dir */public static long getFileLength(File dir) &#123; //dir = F:\\day06\\day07 //1,定义一个求和变量 long len = 0; //2,获取该文件夹下所有的文件和文件夹listFiles(); File[] subFiles = dir.listFiles(); //day07 Demo1_Student.class Demo1_Student.java //3,遍历数组 for (File subFile : subFiles) &#123; //4,判断是文件就计算大小并累加 if(subFile.isFile()) &#123; len = len + subFile.length(); //5,判断是文件夹,递归调用 &#125;else &#123; len = len + getFileLength(subFile); &#125; &#125; return len;&#125; 删除该文件夹 需求:2,从键盘接收一个文件夹路径,删除该文件夹 1234567891011121314151617181920212223242526272829303132333435/** * 删除该文件夹 * 分析: * 1,获取该文件夹下的所有的文件和文件夹 * 2,遍历数组 * 3,判断是文件直接删除 * 4,如果是文件夹,递归调用 * 5,循环结束后,把空文件夹删掉 */public static void main(String[] args) &#123; File dir = Test1.getDir(); //获取文件夹路径 deleteFile(dir);&#125;/* * 删除该文件夹 * 1,返回值类型 void * 2,参数列表File dir */public static void deleteFile(File dir) &#123; //1,获取该文件夹下的所有的文件和文件夹 File[] subFiles = dir.listFiles(); //2,遍历数组 for (File subFile : subFiles) &#123; //3,判断是文件直接删除 if(subFile.isFile()) &#123; subFile.delete(); //4,如果是文件夹,递归调用 &#125;else &#123; deleteFile(subFile); &#125; &#125; //5,循环结束后,把空文件夹删掉 dir.delete();&#125; 拷贝 需求:3,从键盘接收两个文件夹路径,把其中一个文件夹中(包含内容)拷贝到另一个文件夹中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 把其中一个文件夹中(包含内容)拷贝到另一个文件夹中 * 分析: * 1,在目标文件夹中创建原文件夹 * 2,获取原文件夹中所有的文件和文件夹,存储在File数组中 * 3,遍历数组 * 4,如果是文件就用io流读写 * 5,如果是文件夹就递归调用 * @throws IOException */public static void main(String[] args) throws IOException &#123; File src = Test1.getDir(); File dest = Test1.getDir(); if(src.equals(dest)) &#123; System.out.println(\"目标文件夹是源文件夹的子文件夹\"); &#125;else &#123; copy(src,dest); &#125;&#125;/* * 把其中一个文件夹中(包含内容)拷贝到另一个文件夹中 * 1,返回值类型void * 2,参数列表File src,File dest */public static void copy(File src, File dest) throws IOException &#123; //1,在目标文件夹中创建原文件夹 File newDir = new File(dest, src.getName()); newDir.mkdir(); //2,获取原文件夹中所有的文件和文件夹,存储在File数组中 File[] subFiles = src.listFiles(); //3,遍历数组 for (File subFile : subFiles) &#123; //4,如果是文件就用io流读写 if(subFile.isFile()) &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(subFile)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File(newDir,subFile.getName()))); int b; while((b = bis.read()) != -1) &#123; bos.write(b); &#125; bis.close(); bos.close(); //5,如果是文件夹就递归调用 &#125;else &#123; copy(subFile,newDir); &#125; &#125;&#125; 按层级打印 需求:4,从键盘接收一个文件夹路径,把文件夹中的所有文件以及文件夹的名字按层级打印, 例如:aaa是文件夹,里面有bbb.txt,ccc.txt,ddd.txt这些文件,有eee这样的文件夹,eee中有fff.txt和ggg.txt,打印出层级来 12345678aaa bbb.txt ccc.txt ddd.txt eee fff.txt ggg.txt 1234567891011121314151617181920212223242526272829303132333435363738/** * 把文件夹中的所有文件以及文件夹的名字按层级打印 * 分析: * 1,获取所有文件和文件夹,返回的File数组 * 2,遍历数组 * 3,无论是文件还是文件夹,都需要直接打印 * 4,如果是文件夹,递归调用 * day07 * day08 * xxx.jpg * yyy.txt * Demo1_Consturctor.class * Demo1_Consturctor.java * Demo1_Student.class * Demo1_Student.java */public static void main(String[] args) &#123; File dir = Test1.getDir(); //获取文件夹路径 printLev(dir,0);&#125;public static void printLev(File dir,int lev) &#123; //1,把文件夹中的所有文件以及文件夹的名字按层级打印 File[] subFiles = dir.listFiles(); //2,遍历数组 for (File subFile : subFiles) &#123; for(int i = 0; i &lt;= lev; i++) &#123; System.out.print(\"\\t\"); &#125; //3,无论是文件还是文件夹,都需要直接打印 System.out.println(subFile); //4,如果是文件夹,递归调用 if(subFile.isDirectory()) &#123; //printLev(subFile,lev + 1); printLev(subFile,++lev); &#125; &#125;&#125; 斐波那契数列 不死神兔 故事得从西元1202年说起，话说有一位意大利青年，名叫斐波那契。 在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡， 问：一对刚出生的兔子，一年内繁殖成多少对兔子? 1 1 2 3 5 8 13 第一个月一对小兔子 1 第二个月一对大兔子 1 第三个月一对大兔子生了一对小兔子 2 第四个月一对大兔子生了一对小兔子一对小兔子长成大兔子 3 第五个月两对大兔子生两对小兔子一对小兔子长成大兔子5 123456789101112131415161718192021222324252627282930313233343536/*** 1 1 2 3 5 8 13 21* 1 = fun(1)* 1 = fun(2)* 2 = fun(1) + fun(2)* 3 = fun(2) + fun(3) */public static void main(String[] args) &#123; //demo1(); System.out.println(fun(8));&#125;public static void demo1() &#123; //用数组做不死神兔 int[] arr = new int[8]; //数组中第一个元素和第二个元素都为1 arr[0] = 1; arr[1] = 1; //遍历数组对其他元素赋值 for(int i = 2; i &lt; arr.length; i++) &#123; arr[i] = arr[i - 2] + arr[i - 1]; &#125; //如何获取最后一个数 System.out.println(arr[arr.length - 1]);&#125;/* * 用递归求斐波那契数列 */public static int fun(int num) &#123; if(num == 1 || num == 2) &#123; return 1; &#125;else &#123; return fun(num - 2) + fun(num - 1); &#125;&#125; 1000的阶乘所有零和尾部零的个数 需求:求出1000的阶乘所有零和尾部零的个数,不用递归做 因为1000的阶乘远远超出了int的取值范围,所以要用BigInteger 尾部0 12345678910111213BigInteger bi1 = new BigInteger(\"1\");for(int i = 1; i &lt;= 1000; i++) &#123; BigInteger bi2 = new BigInteger(i+\"\"); bi1 = bi1.multiply(bi2); //将bi1与bi2相乘的结果赋值给bi1&#125;String str = bi1.toString(); //获取字符串表现形式int count = 0;for(int i = 0; i &lt; str.length(); i++) &#123; if('0' == str.charAt(i)) &#123; //如果字符串中出现了0字符 count++; //计数器加1 &#125;&#125;System.out.println(count); 尾部零 12345678910111213141516171819BigInteger bi1 = new BigInteger(\"1\");for(int i = 1; i &lt;= 1000; i++) &#123; BigInteger bi2 = new BigInteger(i+\"\"); bi1 = bi1.multiply(bi2); //将bi1与bi2相乘的结果赋值给bi1&#125;String str = bi1.toString(); //获取字符串表现形式StringBuilder sb = new StringBuilder(str);str = sb.reverse().toString(); //翻转字符串 //链式编程int count = 0; //定义计数器for(int i = 0; i &lt; str.length(); i++) &#123; if('0' != str.charAt(i)) &#123; break; &#125;else &#123; count++; &#125;&#125;System.out.println(count); 1000的阶乘尾部零的个数 需求:求出1000的阶乘尾部零的个数,用递归做 1234567891011121314151617181920/** * @param args * 需求:求出1000的阶乘尾部零的个数,用递归做 * 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100...1000 1000 / 5 = 200 * 5 * 5 5 * 5 * 2 5 * 5 * 3 5 * 5 * 4 5 * 5 * 5 5 * 5 * 6 200 / 5 = 40 * 5 * 5 * 5 * 1 5 * 5 * 5 * 2 5 * 5 * 5 * 3 5 * 5 * 5 * 4 5 * 5 * 5 * 5 5 * 5 * 5 * 6 5 * 5 * 5 * 7 5 * 5 * 5 * 8 40 / 5 = 8 5 * 5 * 5 * 5 8 / 5 = 1 */public static void main(String[] args) &#123; System.out.println(fun(1000));&#125;public static int fun(int num) &#123; if(num &gt; 0 &amp;&amp; num &lt; 5) &#123; return 0; &#125;else &#123; return num / 5 + fun(num / 5); &#125;&#125; 还可以相乘除以10,给计数器++,个人喜欢这种方法 约瑟夫环 幸运数字 12345678910111213141516171819202122232425262728293031323334/** * @param args * 约瑟夫环 * * 幸运数字 */public static void main(String[] args) &#123; System.out.println(getLucklyNum(8));&#125;/* * 获取幸运数字 * 1,返回值类型int * 2,参数列表int num */public static int getLucklyNum(int num) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //创建集合存储1到num的对象 for(int i = 1; i &lt;= num; i++) &#123; list.add(i); //将1到num存储在集合中 &#125; int count = 1; //用来数数的,只要是3的倍数就杀人 for(int i = 0; list.size() != 1; i++) &#123; //只要集合中人数超过1,就要不断的杀 if(i == list.size()) &#123; //如果i增长到集合最大的索引+1时 i = 0; //重新归零 &#125; if(count % 3 == 0) &#123; //如果是3的倍数 list.remove(i--); //就杀人 &#125; count++; &#125; return list.get(0);&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - IO流","date":"2013-09-24T16:00:00.000Z","path":"2013/09/25/2013-09-25-io/","text":"JavaSE - IO流 IO流概述及其分类 1.概念 IO流用来处理设备之间的数据传输 Java对数据的操作是通过流的方式 Java用于操作流的类都在IO包中 流按流向分为两种：输入流，输出流。 流按操作类型分为两种： 字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的 字符流 : 字符流只能操作纯字符数据，比较方便。 2.IO流常用父类 字节流的抽象父类： InputStream OutputStream 字符流的抽象父类： Reader Writer 3.IO程序书写 使用前，导入IO包中的类 使用时，进行IO异常处理 使用后，释放资源 FileInputStream read()一次读取一个字节 1234567FileInputStream fis = new FileInputStream(\"aaa.txt\"); //创建一个文件输入流对象,并关联aaa.txtint b; //定义变量,记录每次读到的字节while((b = fis.read()) != -1) &#123; //将每次读到的字节赋值给b并判断是否是-1 System.out.println(b); //打印每一个字节&#125; fis.close();//关闭流释放资源 read()方法返回值为什么是int read()方法读取的是一个字节,为什么返回是int,而不是byte 因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上 24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型 FileOutputStream write()一次写出一个字节 12345FileOutputStream fos = new FileOutputStream(\"bbb.txt\"); //如果没有bbb.txt,会创建出一个//fos.write(97); //虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的一个bytefos.write(98);fos.write(99);fos.close(); FileOutputStream追加 FileOutputStream的构造方法写出数据如何实现数据的追加写入 FileOutputStream在创建对象的时候是如果没有这个文件会帮我创建出来 如果有这个文件就会先将文件清空 12345FileOutputStream fos = new FileOutputStream(\"bbb.txt\",true); //如果没有bbb.txt,会创建出一个//fos.write(97); //虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的一个bytefos.write(98);fos.write(99);fos.close(); 拷贝图片 FileInputStream读取 FileOutputStream写出 12345678910FileInputStream fis = new FileInputStream(\"嘿嘿.jpg\"); //创建输入流对象,关联双元.jpgFileOutputStream fos = new FileOutputStream(\"copy.jpg\"); //创建输出流对象,关联copy.jpgint b;while((b = fis.read()) != -1) &#123; //在不断的读取每一个字节 fos.write(b); //将每一个字节写出&#125;fis.close(); //关流释放资源fos.close(); 拷贝大文件,效率低 12345678910FileInputStream fis = new FileInputStream(\"致青春.mp3\"); //创建输入流对象,关联致青春.mp3FileOutputStream fos = new FileOutputStream(\"copy.mp3\");//创建输出流对象,关联copy.mp3int b;while((b = fis.read()) != -1) &#123; fos.write(b);&#125;fis.close();fos.close(); 拷贝音频文件画原理图 字节流一次读写一个字节复制音频 弊端:效率太低 字节数组拷贝之available()方法 int read(byte[] b):一次读取一个字节数组 write(byte[] b):一次写出一个字节数组 available()获取读的文件所有的字节个数 弊端:有可能会内存溢出 1234567FileInputStream fis = new FileInputStream(\"致青春.mp3\");FileOutputStream fos = new FileOutputStream(\"copy.mp3\");byte[] arr = new byte[fis.available()]; //根据文件大小做一个字节数组fis.read(arr); //将文件上的所有字节读取到数组中fos.write(arr); //将数组中的所有字节一次写到了文件上fis.close();fos.close(); 定义小数组 write(byte[] b) write(byte[] b, int off, int len)写出有效的字节个数 123456789101112131415FileInputStream fis = new FileInputStream(\"xxx.txt\");byte[] arr = new byte[2];int a = fis.read(arr); //将文件上的字节读取到字节数组中System.out.println(a); //读到的有效字节个数for (byte b : arr) &#123; //第一次获取到文件上的a和b System.out.println(b);&#125;System.out.println(\"-----------------------\");int c = fis.read(arr);System.out.println(c);for (byte b : arr) &#123; System.out.println(b);&#125;fis.close(); 会多写一些值,原因是到最后的字节数组可能不是刚好长度为2 1234567891011FileInputStream fis = new FileInputStream(\"xxx.txt\");FileOutputStream fos = new FileOutputStream(\"yyy.txt\");byte[] arr = new byte[2];int len;while((len = fis.read(arr)) != -1) &#123; fos.write(arr,0,len);&#125;fis.close();fos.close(); 定义小数组的标准格式 字节流一次读写一个字节数组复制图片和视频 123456789101112FileInputStream fis = new FileInputStream(\"致青春.mp3\");FileOutputStream fos = new FileOutputStream(\"copy.mp3\");int len;byte[] arr = new byte[1024 * 8]; //自定义字节数组while((len = fis.read(arr)) != -1) &#123;//如果忘记加arr,返回的就不是读取的字节个数,而是字节的码表值 //fos.write(arr); fos.write(arr, 0, len); //写出字节数组写出有效个字节个数&#125;fis.close();fos.close(); BufferedInputStream和BufferOutputStream拷贝 缓冲思想 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多， 这是加入了数组这样的缓冲区效果，java本身在设计的时候， 也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流 BufferedInputStream BufferedInputStream内置了一个缓冲区(数组) 从BufferedInputStream中读取一个字节时 BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个 程序再次读取时, 就不用找文件了, 直接从缓冲区中获取 直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个 BufferedOutputStream BufferedOutputStream也内置了一个缓冲区(数组) 程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中 直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里 拷贝的代码 123456789101112FileInputStream fis = new FileInputStream(\"致青春.mp3\"); //创建文件输入流对象,关联致青春.mp3BufferedInputStream bis = new BufferedInputStream(fis); //创建缓冲区对fis装饰FileOutputStream fos = new FileOutputStream(\"copy.mp3\"); //创建输出流对象,关联copy.mp3BufferedOutputStream bos = new BufferedOutputStream(fos); //创建缓冲区对fos装饰int b;while((b = bis.read()) != -1) &#123; bos.write(b);&#125;bis.close(); //只关装饰后的对象即可bos.close(); 小数组的读写和带Buffered的读取哪个更快? 定义小数组如果是8192个字节大小和Buffered比较的话 定义小数组会略胜一筹,因为读和写操作的是同一个数组 而Buffered操作的是两个数组 flush和close方法的区别 flush()方法 用来刷新缓冲区的,刷新后可以再次写出 close()方法 用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 字节流读写中文 字节流读取中文的问题 字节流在读中文的时候有可能会读到半个中文,造成乱码 字节流写出中文的问题 字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 写出回车换行 write(“\\r\\n”.getBytes()); 12345678FileInputStream fis = new FileInputStream(\"yyy.txt\");byte[] arr = new byte[4];int len;while((len = fis.read(arr)) != -1) &#123; System.out.println(new String(arr,0,len));&#125;//可能乱码fis.close(); 1234FileOutputStream fos = new FileOutputStream(\"zzz.txt\");fos.write(\"我读书少,你不要骗我\".getBytes());fos.write(\"\\r\\n\".getBytes());fos.close(); 流的标准处理异常代码1.6版本及其以前 try finally嵌套 123456789101112131415161718FileInputStream fis = null;FileOutputStream fos = null;try &#123; fis = new FileInputStream(\"aaa.txt\"); fos = new FileOutputStream(\"bbb.txt\"); int b; while((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125; finally &#123; try &#123; if(fis != null) fis.close(); &#125;finally &#123; //try fianlly的嵌套目的是能关一个尽量关一个 if(fos != null) fos.close(); &#125;&#125; 流的标准处理异常代码1.7版本try close 12345678910try( FileInputStream fis = new FileInputStream(\"aaa.txt\"); FileOutputStream fos = new FileOutputStream(\"bbb.txt\"); MyClose mc = new MyClose();)&#123; int b; while((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125; 原理 在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉 12345678910try( FileInputStream fis = new FileInputStream(\"xxx.txt\"); FileOutputStream fos = new FileOutputStream(\"yyy.txt\"); MyClose mc = new MyClose();)&#123; int b; while((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125; 12345class MyClose implements AutoCloseable &#123; public void close() &#123; System.out.println(\"我关了\"); &#125;&#125; 图片加密 给图片加密 将写出的字节异或上一个数,这个数就是密钥,解密的时候再次异或就可以了 12345678910BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"a.jpg\"));BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.jpg\"));int b;while((b = bis.read()) != -1) &#123; bos.write(b ^ 123);&#125;bis.close();bos.close(); 拷贝文件 在控制台录入文件的路径,将文件拷贝到当前项目下 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 分析:* 1,定义方法对键盘录入的路径进行判断,如果是文件就返回* 2,在主方法中接收该文件* 3,读和写该文件* @throws IOException */ public static void main(String[] args) throws IOException &#123; File file = getFile(); //获取文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file.getName())); int b; while((b = bis.read()) != -1) &#123; bos.write(b); &#125; bis.close(); bos.close(); &#125;/** 定义一个方法获取键盘录入的文件路径,并封装成File对象返回* 1,返回值类型File* 2,参数列表无 */ public static File getFile() &#123; Scanner sc = new Scanner(System.in); //创建键盘录入对象 System.out.println(\"请输入一个文件的路径:\"); while(true) &#123; String line = sc.nextLine(); //接收键盘录入的路径 File file = new File(line); //封装成File对象,并对其进行判断 if(!file.exists()) &#123; System.out.println(\"您录入的文件路径不存在,请重新录入:\"); &#125;else if(file.isDirectory()) &#123; System.out.println(\"您录入的是文件夹路径,请重新录入:\"); &#125;else &#123; return file; &#125; &#125; &#125; 录入数据拷贝到文件 将键盘录入的数据拷贝到当前项目下的text.txt文件中,键盘录入数据当遇到quit时就退出 123456789101112131415161718192021222324252627282930/*** 分析:* 1,创建键盘录入对象* 2,创建输出流对象,关联text.txt文件* 3,定义无限循环* 4,遇到quit退出循环* 5,如果不quit,就将内容写出* 6,关闭流* @throws IOException */ public static void main(String[] args) throws IOException &#123; //1,创建键盘录入对象 Scanner sc = new Scanner(System.in); //2,创建输出流对象,关联text.txt文件 FileOutputStream fos = new FileOutputStream(\"text.txt\"); System.out.println(\"请输入数据:\"); //3,定义无限循环 while(true) &#123; String line = sc.nextLine(); //将键盘录入的数据存储在line中 //4,遇到quit退出循环 if(\"quit\".equals(line)) &#123; break; &#125; //5,如果不quit,就将内容写出 fos.write(line.getBytes()); //字符串写出必须转换成字节数组 fos.write(\"\\r\\n\".getBytes()); &#125; //6,关闭流 fos.close(); &#125; 字符流FileReader 1.字符流是什么 字符流是可以直接读写字符的IO流 字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出. 2.FileReader FileReader类的read()方法可以按照字符大小读取 12345678FileReader fr = new FileReader(\"aaa.txt\"); //创建输入流对象,关联aaa.txtint ch;//通过项目默认的码表一次读取一个字符while((ch = fr.read()) != -1) &#123; //将读到的字符赋值给ch System.out.println((char)ch); //将读到的字符强转后打印&#125;fr.close(); //关流 字符流FileWriter FileWriter类的write()方法可以自动把字符转为字节写出 1234FileWriter fw = new FileWriter(\"aaa.txt\");fw.write(\"嘿嘿嘿\");fw.write(97);//afw.close(); 字符流的拷贝1234567891011FileReader fr = new FileReader(&quot;a.txt&quot;);FileWriter fw = new FileWriter(&quot;b.txt&quot;);int ch;while((ch = fr.read()) != -1) &#123; fw.write(ch);&#125;fr.close();//Writer类中有一个2k的小缓冲区,如果不关流,就会将内容写到缓冲区里,关流会将缓冲区内容刷新,再关闭fw.close(); 什么情况下使用字符流 字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节. 程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流 读取的时候是按照字符的大小读取的,不会出现半个中文 写出的时候可以直接将字符串写出,不用转换为字节数组 总结:只读或者只写的时候使用字符流 字符流是否可以拷贝非纯文本的文件 不可以拷贝非纯文本的文件 因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去 如果是?,直接写出,这样写出之后的文件就乱了,看不了了 1234567891011//字符流不能拷贝纯文本的文件FileReader fr = new FileReader(\"艳照.jpg\");FileWriter fw = new FileWriter(\"copy.jpg\");int c;while((c = fr.read()) != -1) &#123; fw.write(c);&#125;fr.close();fw.close(); 自定义字符数组的拷贝1234567891011FileReader fr = new FileReader(\"aaa.txt\"); //创建字符输入流,关联aaa.txtFileWriter fw = new FileWriter(\"bbb.txt\"); //创建字符输出流,关联bbb.txtint len;char[] arr = new char[1024*8]; //创建字符数组while((len = fr.read(arr)) != -1) &#123; //将文件上的数据读取到字符数组中 fw.write(arr, 0, len); //将字符数组中的数据写到文件上 &#125;fr.close(); //关流释放资源fw.close(); 带缓冲的字符流 BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率 BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率 12345678910BufferedReader br = new BufferedReader(new FileReader(\"aaa.txt\")); //创建字符输入流对象,关联aaa.txtBufferedWriter bw = new BufferedWriter(new FileWriter(\"bbb.txt\")); //创建字符输出流对象,关联bbb.txtint ch; while((ch = br.read()) != -1) &#123; //read一次,会先将缓冲区读满,从缓冲去中一个一个的返给临时变量ch bw.write(ch); //write一次,是将数据装到字符数组,装满后再一起写出去&#125;br.close(); //关流bw.close(); readLine()和newLine()方法 BufferedReader的readLine()方法可以读取一行字符(不包含换行符号) BufferedWriter的newLine()可以输出一个跨平台的换行符号”\\r\\n” 12345678910111213BufferedReader br = new BufferedReader(new FileReader(\"aaa.txt\"));BufferedWriter bw = new BufferedWriter(new FileWriter(\"bbb.txt\"));String line;while((line = br.readLine()) != null) &#123; bw.write(line); //写出回车换行符 //bw.write(\"\\r\\n\"); //只支持windows系统 bw.newLine(); //跨平台的&#125;br.close();bw.close(); 将文本反转 将一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换 123456789101112131415161718192021222324252627282930313233343536/** * 分析: * 1,创建输入输出流对象 * 2,创建集合对象 * 3,将读到的数据存储在集合中 * 4,倒着遍历集合将数据写到文件上 * 5,关流 * @throws IOException * * 注意事项: * 流对象尽量晚开早关 */public static void main(String[] args) throws IOException &#123; //改写后是尽量晚开早关 // 1,创建输入输出流对象 BufferedReader br = new BufferedReader(new FileReader(\"zzz.txt\")); //2,创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //3,将读到的数据存储在集合中 String line; while((line = br.readLine()) != null) &#123; list.add(line); &#125; br.close(); //关流 //4,倒着遍历集合将数据写到文件上 BufferedWriter bw = new BufferedWriter(new FileWriter(\"revzzz.txt\")); for(int i = list.size() - 1; i &gt;= 0; i--) &#123; bw.write(list.get(i)); bw.newLine(); &#125; //5,关流 bw.close();&#125; LineNumberReader LineNumberReader是BufferedReader的子类, 具有相同的功能, 并且可以统计行号 调用getLineNumber()方法可以获取当前行号 调用setLineNumber()方法可以设置当前行号 12345678LineNumberReader lnr = new LineNumberReader(new FileReader(\"aaa.txt\"));String line;lnr.setLineNumber(100); //设置起始行号while((line = lnr.readLine()) != null) &#123; System.out.println(lnr.getLineNumber() + \":\" + line);//获取行号&#125;lnr.close(); 装饰设计模式 装饰设计模式的好处是: 耦合性不强,被装饰的类的变化与装饰类的变化无关 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.wxhao.chario;public class Demo6_Wrap &#123; public static void main(String[] args) &#123; DaStudent ds = new DaStudent(new Student()); ds.code(); &#125;&#125;interface Coder &#123; public void code();&#125;class Student implements Coder &#123; @Override public void code() &#123; System.out.println(\"javase\"); System.out.println(\"javaweb\"); &#125; &#125;class DaStudent implements Coder &#123; //1,获取被装饰类的引用 private Student s; //获取学生引用 //2,在构造方法中传入被装饰类的对象 public DaStudent(Student s) &#123; this.s = s; &#125; //3,对原有的功能进行升级 @Override public void code() &#123; s.code(); System.out.println(\"ssh\"); System.out.println(\"数据库\"); System.out.println(\"大数据\"); System.out.println(\"...\"); &#125;&#125; 使用指定的码表读写字符 FileReader是使用默认码表读取文件, 如果需要使用指定码表读取, 那么可以使用InputStreamReader(字节流,编码表) FileWriter是使用默认码表写出文件, 如果需要使用指定码表写出, 那么可以使用OutputStreamWriter(字节流,编码表) 12345678910InputStreamReader isr = new InputStreamReader(new FileInputStream(\"utf-8.txt\"), \"uTf-8\"); //指定码表读字符OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"gbk.txt\"), \"gbk\"); //指定码表写字符int c;while((c = isr.read()) != -1) &#123; osw.write(c);&#125;isr.close();osw.close(); 123456789101112//高效的用指定的编码表读BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"UTF-8.txt\"), \"UTF-8\"));//高效的用指定的编码表写BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\"GBK.txt\"), \"GBK\"));int ch;while((ch = br.read()) != -1) &#123; bw.write(ch);&#125;br.close();bw.close(); 转换流图解 画图分析转换流 获取文本上字符出现的次数 获取一个文本上每个字符出现的次数,将结果写在times.txt上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 分析: * 1,创建带缓冲的输入流对象 * 2,创建双列集合对象TreeMap * 3,将读到的字符存储在双列集合中,存储的时候要做判断,如果不包含这个键,就将键和1存储,如果包含这个键,就将该键和值加1存储 * 4,关闭输入流 * 5,创建输出流对象 * 6,遍历集合将集合中的内容写到times.txt中 * 7,关闭输出流 * @throws IOException */public static void main(String[] args) throws IOException &#123; //1,创建带缓冲的输入流对象 BufferedReader br = new BufferedReader(new FileReader(\"zzz.txt\")); //2,创建双列集合对象TreeMap TreeMap&lt;Character, Integer&gt; tm = new TreeMap&lt;&gt;(); //3,将读到的字符存储在双列集合中,存储的时候要做判断,如果不包含这个键,就将键和1存储,如果包含这个键,就将该键和值加1存储 int ch; while((ch = br.read()) != -1) &#123; char c = (char)ch; //强制类型转换 /*if(!tm.containsKey(c)) &#123; tm.put(c, 1); &#125;else &#123; tm.put(c, tm.get(c) + 1); &#125;*/ tm.put(c, !tm.containsKey(c) ? 1 : tm.get(c) + 1); &#125; //4,关闭输入流 br.close(); //5,创建输出流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(\"times.txt\")); //6,遍历集合将集合中的内容写到times.txt中 for(Character key : tm.keySet()) &#123; switch (key) &#123; case '\\t': bw.write(\"\\\\t\" + \"=\" + tm.get(key)); break; case '\\n': bw.write(\"\\\\n\" + \"=\" + tm.get(key)); break; case '\\r': bw.write(\"\\\\r\" + \"=\" + tm.get(key)); break; default: bw.write(key + \"=\" + tm.get(key)); //写出键和值 break; &#125; bw.newLine(); &#125; //7,关闭输出流 bw.close();&#125; 试用版软件 当我们下载一个试用版软件,没有购买正版的时候,每执行一次就会提醒我们还有多少次使用机会用学过的IO流知识,模拟试用版软件,试用10次机会,执行一次就提示一次您还有几次机会,如果次数到了提示请购买正版 1234567891011121314151617181920212223242526/** * 分析: * 1,创建带缓冲的输入流对象,因为要使用readLine方法,可以保证数据的原样性 * 2,将读到的字符串转换为int数 * 3,对int数进行判断,如果大于0,就将其--写回去,如果不大于0,就提示请购买正版 * 4,在if判断中要将--的结果打印,并将结果通过输出流写到文件上 */public static void main(String[] args) throws IOException &#123; //1,创建带缓冲的输入流对象,因为要使用readLine方法,可以保证数据的原样性 BufferedReader br = new BufferedReader(new FileReader(\"config.txt\")); //2,将读到的字符串转换为int数 String line = br.readLine(); int times = Integer.parseInt(line); //将数字字符串转换为数字 //3,对int数进行判断,如果大于0,就将其--写回去,如果不大于0,就提示请购买正版 if(times &gt; 0) &#123; //4,在if判断中要将--的结果打印,并将结果通过输出流写到文件上 System.out.println(\"您还有\" + times-- + \"次机会\"); FileWriter fw = new FileWriter(\"config.txt\"); fw.write(times + \"\"); fw.close(); &#125;else &#123; System.out.println(\"您的试用次数已到,请购买正版\"); &#125; //关闭流 br.close();&#125; 递归 5的阶乘 123456789101112131415161718192021222324252627282930313233343536/** * 递归:方法自己调用自己 * 5! * 5 * 4 * 3 * 2 * 1 * * 5 * fun(4)(代表4!) * 4 * fun(3)(代表3!) * 3 * fun(2)(代表2!) * 2 * fun(1)(代表1!) * 递归的弊端:不能调用次数过多,容易导致栈内存溢出 * 递归的好处:不用知道循环次数 * * 构造方法是否可以递归调用? * 构造方法不能使用递归调用 * * 递归调用是否必须有返回值? * 不一定(可以有,也可以没有) */public static void main(String[] args) &#123; /*int result = 1; for(int i = 1; i &lt;= 5; i++) &#123; result = result * i; &#125; System.out.println(result);*/ System.out.println(fun(6000));&#125;public static int fun(int num) &#123; if(num == 1) &#123; return 1; &#125;else &#123; return num * fun(num - 1); &#125;&#125; 练习 需求:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.java文件名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 分析: * 从键盘接收一个文件夹路径 * 1,如果录入的是不存在,给与提示 * 2,如果录入的是文件路径,给与提示 * 3,如果是文件夹路径,直接返回 * * 打印出该文件夹下所有的.java文件名 * 1,获取到该文件夹路径下的所有的文件和文件夹,存储在File数组中 * 2,遍历数组,对每一个文件或文件夹做判断 * 3,如果是文件,并且后缀是.java的,就打印 * 4,如果是文件夹,就递归调用 */public static void main(String[] args) &#123; File dir = getDir(); printJavaFile(dir);&#125;/* * 获取键盘录入的文件夹路径 * 1,返回值类型File * 2,不需要有参数 */public static File getDir() &#123; Scanner sc = new Scanner(System.in); //创建键盘录入对象 System.out.println(\"请输入一个文件夹路径\"); while(true) &#123; String line = sc.nextLine(); //将键盘录入的文件夹路径存储 File dir = new File(line); //封装成File对象 if(!dir.exists()) &#123; System.out.println(\"您录入的文件夹路径不存在,请重新录入\"); &#125;else if(dir.isFile()) &#123; System.out.println(\"您录入的是文件路径,请重新录入文件夹路径\"); &#125;else &#123; return dir; &#125; &#125;&#125;/* * 获取文件夹路径下的所.java文件 * 1,返回值类型 void * 2,参数列表File dir */public static void printJavaFile(File dir) &#123; //1,获取到该文件夹路径下的所有的文件和文件夹,存储在File数组中 File[] subFiles = dir.listFiles(); //2,遍历数组,对每一个文件或文件夹做判断 for (File subFile : subFiles) &#123; //3,如果是文件,并且后缀是.java的,就打印 if(subFile.isFile() &amp;&amp; subFile.getName().endsWith(\".java\")) &#123; System.out.println(subFile); //4,如果是文件夹,就递归调用 &#125;else if (subFile.isDirectory())&#123; printJavaFile(subFile); &#125; &#125;&#125; IO流(总结) 会用BufferedReader读取GBK码表和UTF-8码表的字符 会用BufferedWriter写出字符到GBK码表和UTF-8码表的文件中 会使用BufferedReader从键盘读取一行 序列流 1.什么是序列流 序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推. 2.使用方式 整合两个: SequenceInputStream(InputStream, InputStream) 123456789101112FileInputStream fis1 = new FileInputStream(\"a.txt\"); //创建输入流对象,关联a.txtFileInputStream fis2 = new FileInputStream(\"b.txt\"); //创建输入流对象,关联b.txtSequenceInputStream sis = new SequenceInputStream(fis1, fis2); //将两个流整合成一个流FileOutputStream fos = new FileOutputStream(\"c.txt\"); //创建输出流对象,关联c.txtint b;while((b = sis.read()) != -1) &#123; //用整合后的读 fos.write(b); //写到指定文件上&#125;//sis在关闭的时候,会将构造方法中传入的流对象也都关闭sis.close();fos.close(); 为什么要用序列流整合? 因为两个读取多个流复用性太差 序列流整合多个 整合多个: SequenceInputStream(Enumeration) 1234567891011121314151617FileInputStream fis1 = new FileInputStream(\"a.txt\"); //创建输入流对象,关联a.txtFileInputStream fis2 = new FileInputStream(\"b.txt\"); //创建输入流对象,关联b.txtFileInputStream fis3 = new FileInputStream(\"c.txt\"); //创建输入流对象,关联c.txtVector&lt;InputStream&gt; v = new Vector&lt;&gt;(); //创建vector集合对象v.add(fis1); //将流对象添加v.add(fis2);v.add(fis3);Enumeration&lt;InputStream&gt; en = v.elements(); //获取枚举引用SequenceInputStream sis = new SequenceInputStream(en); //传递给SequenceInputStream构造FileOutputStream fos = new FileOutputStream(\"d.txt\");int b;while((b = sis.read()) != -1) &#123; fos.write(b);&#125;sis.close();fos.close(); 内存输出流 1.什么是内存输出流 该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据 2.使用方式 创建对象: new ByteArrayOutputStream() 写出数据: write(int), write(byte[]) 获取数据: toByteArray() 1234567891011121314FileInputStream fis = new FileInputStream(\"a.txt\");ByteArrayOutputStream baos = new ByteArrayOutputStream(); //在内存中创建了可以增长的内存数组int b;while((b = fis.read()) != -1) &#123; baos.write(b);&#125;//byte[] newArr = baos.toByteArray(); //将内存缓冲区中所有的字节存储在newArr中//System.out.println(new String(newArr));//byte[] arr = baos.toByteArray(); //将缓冲区的数据全部获取出来,并赋值给arr数组//System.out.println(new String(arr));System.out.println(baos); //将缓冲区的内容转换为了字符串,在输出语句中可以省略调用toString方法fis.close(); FileInputStream读取中文的时候出现了乱码 解决方案 字符流读取 ByteArrayOutputStream 内存输出流之黑马面试题 定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5) 123456789101112131415161718192021222324252627/** * 分析: * 1,read(byte[] b)是字节输入流的方法,创建FileInputStream,关联a.txt * 2,创建内存输出流,将读到的数据写到内存输出流中 * 3,创建字节数组,长度为5 * 4,将内存输出流的数据全部转换为字符串打印 * 5,关闭输入流 * @throws IOException */public static void main(String[] args) throws IOException &#123; //1,reda(byte[] b)是字节输入流的方法,创建FileInputStream,关联a.txt FileInputStream fis = new FileInputStream(\"a.txt\"); //2,创建内存输出流,将读到的数据写到内存输出流中 ByteArrayOutputStream baos = new ByteArrayOutputStream(); //3,创建字节数组,长度为5 byte[] arr = new byte[5]; int len; while((len = fis.read(arr)) != -1) &#123; baos.write(arr, 0, len); //System.out.println(new String(arr,0,len)); &#125; //4,将内存输出流的数据全部转换为字符串打印 System.out.println(baos); //即使没有调用,底层也会默认帮我们调用toString()方法 //5,关闭输入流 fis.close();&#125; 对象操作流ObjecOutputStream 1.什么是对象操作流 该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作. 2.使用方式 写出: new ObjectOutputStream(OutputStream), writeObject() 序列化:将对象写到文件上 123456789101112131415161718192021public class Demo3_ObjectOutputStream &#123; /** * @param args * @throws IOException * 将对象写出,序列化 */ public static void main(String[] args) throws IOException &#123; Person p1 = new Person(\"张三\", 23); Person p2 = new Person(\"李四\", 24);// FileOutputStream fos = new FileOutputStream(\"e.txt\");// fos.write(p1);// FileWriter fw = new FileWriter(\"e.txt\");// fw.write(p1); //无论是字节输出流,还是字符输出流都不能直接写出对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"e.txt\"));//创建对象输出流 oos.writeObject(p1); oos.writeObject(p2); oos.close(); &#125;&#125; 对象操作流ObjectInputStream 读取: new ObjectInputStream(InputStream), readObject() 12345678910111213141516171819public class Demo3_ObjectInputStream &#123; /** * @param args * @throws IOException * @throws ClassNotFoundException * @throws FileNotFoundException * 读取对象,反序列化 */ public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"e.txt\")); Person p1 = (Person) ois.readObject(); Person p2 = (Person) ois.readObject(); //Person p3 = (Person) ois.readObject(); //当文件读取到了末尾时出现EOFException System.out.println(p1); System.out.println(p2); ois.close(); &#125;&#125; 对象操作流优化* 将对象存储在集合中写出 123456789101112131415Person p1 = new Person(\"张三\", 23);Person p2 = new Person(\"李四\", 24);Person p3 = new Person(\"马哥\", 18);Person p4 = new Person(\"辉哥\", 20);ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;();list.add(p1);list.add(p2);list.add(p3);list.add(p4);ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"f.txt\"));oos.writeObject(list);//写出集合对象oos.close(); 读取到的是一个集合对象 12345678ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"f.txt\")); ArrayList&lt;Person&gt; list = (ArrayList&lt;Person&gt;)ois.readObject(); //泛型在运行期会被擦除,索引运行期相当于没有泛型 //想去掉黄色可以加注解 @SuppressWarnings(\"unchecked\") for (Person person : list) &#123; System.out.println(person); &#125;ois.close(); 加上id号 注意 要写出的对象必须实现Serializable接口才能被序列化 不用必须加id号 123456public class Person implements Serializable &#123; /** * */ private static final long serialVersionUID = 2L;&#125; 打印流的概述和特点 1.什么是打印流 该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式 System.out就是一个PrintStream, 其默认向控制台输出信息 1234567PrintStream ps = System.out;ps.println(97); //底层通过Integer.toString()将97转换成字符串并打印ps.write(97); //查找码表,找到对应的a并打印ps.println(\"xxx\");ps.println(new Person(\"张三\", 23));Person p = null;ps.println(p); //如果是null,就返回null,如果不是null,就调用对象的toString() 2.使用方式 打印: print(), println() 自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding) 打印流只操作数据目的 12345PrintWriter pw = new PrintWriter(new FileOutputStream(\"g.txt\"), true);pw.write(97);pw.print(\"大家好\");pw.println(\"你好\"); //自动刷出,只针对的是println方法pw.close(); PrintStream和PrintWriter分别是打印的字节流和字符流 只操作数据目的的 标准输入输出流概述和输出语句 1.什么是标准输入输出流(掌握) System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据 System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据 123456789InputStream is = System.in;int x = is.read();System.out.println(x);is.close();//不用关流,因为没有指向文件InputStream is2 = System.in;//之前关了,就没开了int y = is2.read();System.out.println(y); 2.修改标准输入输出流(了解) 修改输入流: System.setIn(InputStream) 修改输出流: System.setOut(PrintStream) 12345678910111213System.setIn(new FileInputStream(\"a.txt\")); //改变标准输入流System.setOut(new PrintStream(\"b.txt\")); //改变标注输出流InputStream is = System.in; //获取标准的键盘输入流,默认指向键盘,改变后指向文件PrintStream ps = System.out; //获取标准输出流,默认指向的是控制台,改变后就指向文件int b;while((b = is.read()) != -1) &#123; ps.write(b);&#125;//System.out.println(); //也是一个输出流,不用关,因为没有和硬盘上的文件产生关联的管道is.close();ps.close(); 修改标准输入输出流拷贝图片12345678910111213System.setIn(new FileInputStream(\"IO图片.png\")); //改变标准输入流System.setOut(new PrintStream(\"copy.png\")); //改变标准输出流InputStream is = System.in; //获取标准输入流PrintStream ps = System.out; //获取标准输出流int len;byte[] arr = new byte[1024 * 8];while((len = is.read(arr)) != -1) &#123; ps.write(arr, 0, len);&#125;is.close();ps.close(); (两种方式实现键盘录入)(了解) BufferedReader的readLine方法。 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Scanner 123456789BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); //InputStreamReader转换流String line = br.readLine();System.out.println(line);br.close();Scanner sc = new Scanner(System.in);String line2 = sc.nextLine();System.out.println(line2);sc.close(); 随机访问流概述和读写数据 随机访问流概述 RandomAccessFile概述 RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。 支持对随机访问文件的读取和写入。 read(),write(),seek() 1234567RandomAccessFile raf = new RandomAccessFile(\"g.txt\", \"rw\");//raf.write(97);//int x = raf.read();//System.out.println(x);raf.seek(0); //在指定位置设置指针raf.write(98);raf.close(); 数据输入输出流 1.什么是数据输入输出流 DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据 例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节. 123456789101112131415161718192021/* 00000000 00000000 00000011 11100101 int类型997* 11100101* 00000000 00000000 00000000 11100101*/FileOutputStream fos = new FileOutputStream(\"h.txt\");fos.write(997);fos.write(998);fos.write(999);fos.close();FileInputStream fis = new FileInputStream(\"h.txt\");int x = fis.read();int y = fis.read();int z = fis.read();System.out.println(x);//229System.out.println(y);//230System.out.println(z);//231fis.close(); 2.使用方式 DataOutputStream(OutputStream), writeInt(), writeLong() 123456DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;b.txt&quot;));dos.writeInt(997);dos.writeInt(998);dos.writeInt(999);dos.close(); DataInputStream(InputStream), readInt(), readLong() 12345678DataInputStream dis = new DataInputStream(new FileInputStream(&quot;b.txt&quot;));int x = dis.readInt();int y = dis.readInt();int z = dis.readInt();System.out.println(x);System.out.println(y);System.out.println(z);dis.close(); Properties的概述和作为Map集合的使用 Properties的概述 Properties 类表示了一个持久的属性集。 Properties 可保存在流中或从流中加载。 属性列表中每个键及其对应值都是一个字符串。 案例演示 Properties作为Map集合的使用 123Properties prop = new Properties();prop.put(\"abc\", 123);System.out.println(prop); Properties的特殊功能使用 Properties的特殊功能 public Object setProperty(String key,String value) public String getProperty(String key) public Enumeration stringPropertyNames() Properties的特殊功能 1234567891011Properties prop = new Properties();prop.setProperty(\"name\", \"张三\");prop.setProperty(\"tel\", \"18912345678\");//System.out.println(prop);Enumeration&lt;String&gt; en = (Enumeration&lt;String&gt;) prop.propertyNames();while(en.hasMoreElements()) &#123; String key = en.nextElement(); //获取Properties中的每一个键 String value = prop.getProperty(key); //根据键获取值 System.out.println(key + \"=\"+ value);&#125; Properties的load()和store()功能 ) Properties的load()和store()功能 Properties的load()和store()功能 12345Properties prop = new Properties();prop.load(new FileInputStream(\"config.properties\")); //将文件上的键值对读取到集合中prop.setProperty(\"tel\", \"18912345678\");prop.store(new FileOutputStream(\"config.properties\"), null);//第二个参数是对列表参数的描述,可以给值,也可以给nullSystem.out.println(prop); config.properties 1234#Tue Jun 29 05:34:44 CST 2088qq=12345tel=18912345678username=zhangsan","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - 异常","date":"2013-09-12T16:00:00.000Z","path":"2013/09/13/2013-09-13-exception/","text":"JavaSE - 异常 异常的概述和分类 异常的概述 异常就是Java程序在运行过程中出现的错误。 异常的分类 通过API查看Throwable Error 服务器宕机,数据库崩溃等 ExceptionC:异常的继承体系 Throwable Error Exception RuntimeException 123int[] arr = &#123;11,22,33,44,55&#125;; //arr = null; //NullPointerException 空指针异常 System.out.println(arr[10]); //ArrayIndexOutOfBoundsException 数组索引越界异常 JVM默认是如何处理异常的 JVM默认是如何处理异常的 main函数收到这个问题时,有两种处理方式: 自己将该问题处理,然后继续运行 自己没有针对的处理方式,只有交给调用main的jvm来处理 jvm有一个默认的异常处理机制,就将该异常进行处理. 并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行 JVM默认如何处理异常 123456789class Demo &#123; /* * 除法运算 */ public int div(int a,int b) &#123; //a = 10,b = 0 return a / b; // 10 / 0 被除数是10,除数是0当除数是0的时候违背了算数运算法则,抛出异常 //new ArithmeticException(\"/ by zero\"); &#125;&#125; 12345public static void main(String[] args) &#123; Demo d = new Demo(); int x = d.div(10, 0); System.out.println(x);&#125; try…catch的方式处理异常1 异常处理的两种方式 try…catch…finally try catch try catch finally try finally throws try…catch处理异常的基本格式 try…catch…finally try…catch的方式处理1个异常 12345678910111213141516171819202122232425262728293031323334package com.wxhao.exception;public class Demo2_Exception &#123; /** try:用来检测异常的 catch:用来捕获异常的 finally:释放资源 世界上最真情的相依就是你在try我在catch,无论你发神马脾气,我都静静接受,默默处理 当通过trycatch将问题处理了,程序会继续执行 */ public static void main(String[] args) &#123; Demo2 d = new Demo2(); try&#123; int x = d.div(10, 0); System.out.println(x); &#125;catch(ArithmeticException a) &#123; //ArithmeticException a = new ArithmeticException(); System.out.println(\"出错了,除数为零了\"); &#125; System.out.println(\"1111111111111111\"); &#125;&#125;class Demo2 &#123; /* * 除法运算 */ public int div(int a,int b) &#123; //a = 10,b = 0 return a / b; // 10 / 0 被除数是10,除数是0当除数是0的时候违背了算数运算法则,抛出异常 //new ArithmeticException(\"/ by zero\"); &#125;&#125; try…catch的方式处理异常2 try…catch的方式处理多个异常 JDK7以后处理多个异常的方式及注意事项 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * * 安卓,客户端开发,如何处理异常?try&#123;&#125;catch(Exception e)&#123;&#125; * ee,服务端开发,一般都是底层开发,从底层向上抛 * * try后面如果跟多个catch,那么小的异常放前面,大的异常放后面,根据多态的原理,如果大的放前面,就会将所有的子类对象接收 * 后面的catch就没有意义了 */public static void main(String[] args) &#123; //demo1(); int a = 10; int b = 0; int[] arr = &#123;11,22,33,44,55&#125;; //JDK7如何处理多个异常 try &#123; System.out.println(a / b); System.out.println(arr[10]); &#125; catch (ArithmeticException | ArrayIndexOutOfBoundsException e) &#123; System.out.println(\"出错了\"); &#125; &#125;public static void demo1() &#123; int a = 10; int b = 0; int[] arr = &#123;11,22,33,44,55&#125;; try &#123; System.out.println(a / b); System.out.println(arr[10]); arr = null; System.out.println(arr[0]); &#125; catch (ArithmeticException e) &#123; System.out.println(\"除数不能为零\"); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println(\"索引越界了\"); &#125; catch (Exception e) &#123; //Exception e = new NullPointerException(); System.out.println(\"出错了\"); &#125; System.out.println(\"over\");&#125; 编译期异常和运行期异常的区别 编译期异常和运行期异常的区别 Java中的异常被分为两大类：编译时异常和运行时异常。 所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常 编译时异常 Java程序必须显示处理，否则程序就会发生错误，无法通过编译 运行时异常 无需显示处理，也可以和编译时异常一样处理 编译期异常和运行期异常的区别 123456789101112131415/** 编译时异常也叫做未雨绸缪异常(老师自己定义的) 未雨绸缪:在做某些事情的时候要做某些准备 编译时异常:在编译某个程序的时候,有可能会有这样那样的事情发生,比如文件找不到,这样的异常就必须在编译的时候处理 如果不处理编译通不过 运行时异常:就是程序员所犯得错误,需要回来修改代码 */public static void main(String[] args) &#123; try &#123; FileInputStream fis = new FileInputStream(\"xxx.txt\"); &#125; catch(Exception e) &#123; &#125;&#125; Throwable的几个常见方法 Throwable的几个常见方法 getMessage() 获取异常信息，返回字符串。 toString() 获取异常类名和异常信息，返回字符串。 printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。 Throwable的几个常见方法的基本使用 throws的方式处理异常 throws的方式处理异常 定义功能方法时，需要把出现的问题暴露出来让调用者去处理。 那么就通过throws在方法上标识。 throw的概述以及和throws的区别 throw的概述 在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。 throws和throw的区别 throws 用在方法声明后面，跟的是异常类名 可以跟多个异常类名，用逗号隔开 表示抛出异常，由该方法的调用者来处理 throw 用在方法体内，跟的是异常对象名 只能抛出一个异常对象名 表示抛出异常，由方法体内的语句处理 finally关键字的特点及作用 finally的特点 被finally控制的语句体一定会执行 特殊情况：在执行到finally之前jvm退出了(比如System.exit(0)) finally的作用 用于释放资源，在IO流操作和数据库操作中会见到 finally关键字的特点及作用 123456789101112131415/** return语句相当于是方法的最后一口气,那么在他将死之前会看一看有没有finally帮其完成遗愿,如果有就将finally执行 后在彻底返回 */public static void main(String[] args) &#123; try &#123; System.out.println(10/0); &#125; catch (Exception e) &#123; System.out.println(\"除数为零了\"); System.exit(0); //退出jvm虚拟机 return; &#125; finally &#123; System.out.println(\"看看我执行了吗\"); &#125;&#125; finally关键字的练习题 final,finally和finalize的区别 final可以修饰类,不能被继承 修饰方法,不能被重写 修饰变量,只能赋值一次 finally是try语句中的一个语句体,不能单独使用,用来释放资源 finalize是一个方法,当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后。 123456789101112131415public int method() &#123; int x = 10; try &#123; x = 20; System.out.println(1/0); return x; &#125; catch (Exception e) &#123; x = 30; return x; &#125; finally &#123; x = 40; //return x; 千万不要在finally里面写返回语句,因为finally的作用是为了释放资源,是肯定会执行的 //如果在这里面写返回语句,那么try和catch的结果都会被改变,所以这么写就是犯罪 &#125;&#125; 输出30,return先把返回路径建立起来了,然后判断有没有finally,在执行return 自定义异常概述和基本使用 为什么需要自定义异常 举例：人的年龄 通过名字区分到底是神马异常,有针对的解决办法 自定义异常概述 继承自Exception 继承自RuntimeException 12345678910class AgeOutOfBoundsException extends Exception &#123; public AgeOutOfBoundsException() &#123; super(); &#125; public AgeOutOfBoundsException(String message) &#123; super(message); &#125;&#125; 异常的注意事项及如何使用异常处理 异常注意事项 子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏) 如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常 如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws 如何使用异常处理 原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws 区别: 后续程序需要继续运行就try 后续程序不需要继续运行就throws 如果JDK没有提供对应的异常，需要自定义异常。 异常(练习) 键盘录入一个int类型的整数,对其求二进制表现形式 如果录入的整数过大,给予提示,录入的整数过大请重新录入一个整数BigInteger 如果录入的是小数,给予提示,录入的是小数,请重新录入一个整数 如果录入的是其他字符,给予提示,录入的是非法字符,请重新录入一个整数 1234567891011121314151617181920212223242526272829303132333435363738/** * 分析: * 1,创建键盘录入对象 * 2,将键盘录入的结果存储在String类型的字符串中,存储int类型中如果有不符合条件的直接报错,无法进行后续判断 * 3,键盘录入的结果转换成int类型的数据,是正确的还是错误的 * 4,正确的直接转换 * 5,错误的要进行对应判断 */public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个整数:\"); while(true) &#123; //将键盘录入的结果存储在line中 String line = sc.nextLine(); try &#123; //将字符串转换为整数 int num = Integer.parseInt(line); //将整数转换为二进制 System.out.println(Integer.toBinaryString(num)); //跳出循环 break; &#125;catch(Exception e) &#123; try &#123; new BigInteger(line); System.out.println(\"录入错误,您录入的是一个过大整数,请重新输入一个整数:\"); //alt + shif + z (try catch快捷键) &#125;catch (Exception e2) &#123; try &#123; new BigDecimal(line); System.out.println(\"录入错误,您录入的是一个小数,请重新输入一个整数:\"); &#125; catch (Exception e1) &#123; System.out.println(\"录入错误,您录入的是非法字符,请重新输入一个整数:\"); &#125; &#125; &#125; &#125;&#125; File类的概述和构造方法 File类的概述 File更应该叫做一个路径 文件路径或者文件夹路径 路径分为绝对路径和相对路径 绝对路径是一个固定的路径,从盘符开始 相对路径相对于某个位置,在eclipse下是指当前项目下,在dos下指的是当前路径 查看API指的是当前路径 文件和目录路径名的抽象表示形式 构造方法 File(String pathname)：根据一个路径得到File对象 File(String parent, String child):根据一个目录和一个子文件/目录得到File对象 File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象 File类的构造方法 123// File(String pathname)：根据一个路径得到File对象File file2 = new File(\"xxx.txt\");System.out.println(file2.exists());//判断文件是否存在 12345 // File(String parent, String child):根据一个目录和一个子文件/目录得到File对象String parent = &quot;F:\\\\xxx&quot;;String child = &quot;xxx.txt&quot;;File file = new File(parent,child);System.out.println(file.exists()); 123456 // File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象File parent = new File(&quot;F:\\\\xxx&quot;);String child = &quot;xxx.txt&quot;;File file = new File(parent, child);System.out.println(file.exists());System.out.println(parent.exists()); File类的创建功能 创建功能 public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了 public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了 public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来 File类的创建功能 注意事项：如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。 12345678//创建文件public static void demo1() throws IOException &#123; File file = new File(\"yyy.txt\"); System.out.println(file.createNewFile());//如果没有就创建,返回true File file2 = new File(\"zzz\"); System.out.println(file2.createNewFile());&#125; 123456789101112//创建文件夹public static void main(String[] args) throws IOException &#123; //demo1(); File dir1 = new File(\"aaa\"); System.out.println(dir1.mkdir()); File dir2 = new File(\"bbb.txt\"); //这样写是可以的,文件夹也是可以有后缀的 System.out.println(dir2.mkdir()); File dir3 = new File(\"ccc\\\\ddd\"); System.out.println(dir3.mkdirs()); //创建多级目录&#125; File类的重命名和删除功能 重命名和删除功能 public boolean renameTo(File dest):把文件重命名为指定的文件路径 public boolean delete():删除文件或者文件夹 重命名注意事项 如果路径名相同，就是改名。 如果路径名不同，就是改名并剪切。 删除注意事项： Java中的删除不走回收站。 要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹 1234//renameToFile file1 = new File(\"ooo.txt\");File file2 = new File(\"D:\\\\xxx.txt\");System.out.println(file1.renameTo(file2)); 123456789//deleteFile file1 = new File(&quot;yyy.txt&quot;);System.out.println(file1.delete());File file2 = new File(&quot;aaa&quot;);System.out.println(file2.delete());File file3 = new File(&quot;ccc&quot;); //如果删除一个文件夹,那么文件夹必须是空的System.out.println(file3.delete()); File类的判断功能 判断功能 public boolean isDirectory():判断是否是目录 public boolean isFile():判断是否是文件 public boolean exists():判断是否存在 public boolean canRead():判断是否可读 public boolean canWrite():判断是否可写 public boolean isHidden():判断是否隐藏 File类的判断功能 123File dir = new File(\"zzz\");System.out.println(dir.isDirectory()); //判断是否是文件夹System.out.println(dir.isFile()); //判断是否是文件 123456789File file = new File(&quot;zzz&quot;);file.setReadable(false);System.out.println(file.canRead()); //windows系统认为所有的文件都是可读的file.setWritable(true);System.out.println(file.canWrite()); //windows系统可以设置为不可写File file2 = new File(&quot;aaa.txt&quot;);System.out.println(file2.isHidden()); //判断是否是隐藏文件System.out.println(file.isHidden()); File类的获取功能 获取功能 public String getAbsolutePath()：获取绝对路径 public String getPath():获取路径 public String getName():获取名称 public long length():获取长度。字节数 public long lastModified():获取最后一次的修改时间，毫秒值 public String[] list():获取指定目录下的所有文件或者文件夹的名称数组 public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组 File类的获取功能 12345678910111213141516File file1 = new File(\"ccc.txt\");File file2 = new File(\"D:\\\\xxx\\\\ccc.txt\");//System.out.println(file1.getAbsolutePath()); //获取绝对路径//System.out.println(file2.getAbsolutePath());//System.out.println(file1.getPath()); //获取构造方法中传入路径//System.out.println(file2.getPath());// System.out.println(file1.getName()); //获取文件或者文件的名字// System.out.println(file2.getName());// // System.out.println(file1.length()); //获取文件字节个数Date d = new Date(file1.lastModified()); //文件的最后修改时间SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");System.out.println(sdf.format(d)); 123456789101112File dir = new File(&quot;F:/config&quot;);String[] arr = dir.list(); //仅为了获取文件名for (String string : arr) &#123; System.out.println(string);&#125;File[] subFiles = dir.listFiles();for (File file : subFiles) &#123; //获取文件对象 System.out.println(file);&#125; 输出指定目录下指定后缀的文件名 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称 12345678910111213141516File dir = new File(\"E:\\\\\");// String[] arr = dir.list(); //获取e盘下所有的文件或文件夹// for (String string : arr) &#123;// if(string.endsWith(\".jpg\")) &#123;// System.out.println(string);// &#125;// &#125;File[] subFiles = dir.listFiles(); //获取e盘下所有的文件或文件夹对象for (File subFile : subFiles) &#123; if(subFile.isFile() &amp;&amp; subFile.getName().endsWith(\".jpg\")) &#123; System.out.println(subFile); &#125;&#125; 文件名称过滤器的概述及使用 文件名称过滤器的概述 public String[] list(FilenameFilter filter) public File[] listFiles(FileFilter filter) 文件名称过滤器的使用 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称 1234567891011121314151617181920212223File dir = new File(\"E:\\\\\");File[] subFiles = dir.listFiles(); //获取e盘下所有的文件或文件夹对象for (File subFile : subFiles) &#123; if(subFile.isFile() &amp;&amp; subFile.getName().endsWith(\".jpg\")) &#123; System.out.println(subFile); &#125;&#125;String[] arr = dir.list(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; //System.out.println(dir); //System.out.println(name); File file = new File(dir, name); return file.isFile() &amp;&amp; file.getName().endsWith(\".jpg\"); &#125;&#125;);for (String string : arr) &#123; System.out.println(string);&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"jdk","date":"2013-09-11T16:00:00.000Z","path":"2013/09/12/wxhao/2013-09-12-jdk/","text":"jdk 攻略 jdk 常用配置12345678JAVA_HOMEC:\\Program Files\\Java\\jdk1.8.0_121CLASSPATH.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;Path%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;","tags":[{"name":"jdk","slug":"jdk","permalink":"http://wxhaor.me/tags/jdk/"}]},{"title":"JavaSE集合框架 - Map集合","date":"2013-09-04T16:00:00.000Z","path":"2013/09/05/2013-09-05-map/","text":"JavaSE - IO流 Map集合概述和特点 Map接口概述 查看API可以知道： 将键映射到值的对象 一个映射不能包含重复的键 每个键最多只能映射到一个值 B:Map接口和Collection接口的不同 Map是双列的,Collection是单列的 Map的键唯一,Collection的子体系Set是唯一的 Map集合的数据结构值针对键有效，跟值无关;Collection集合的数据结构是针对元素有效 Map集合的功能概述 Map集合的功能概述 a:添加功能 V put(K key,V value):添加元素。 如果键是第一次存储，就直接存储元素，返回null 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值 b:删除功能 void clear():移除所有的键值对元素 V remove(Object key)：根据键删除键值对元素，并把值返回 c:判断功能 boolean containsKey(Object key)：判断集合是否包含指定的键 boolean containsValue(Object value):判断集合是否包含指定的值 boolean isEmpty()：判断集合是否为空 d:获取功能 Set","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE集合框架 - Set集合","date":"2013-08-29T16:00:00.000Z","path":"2013/08/30/2013-08-30-collection-set/","text":"JavaSE集合框架 - Set集合 HashSet存储字符串并遍历 Set集合概述及特点 通过API查看即可 HashSet存储字符串并遍历 12345678910111213HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();//创建HashSet对象boolean b1 = hs.add(\"a\");boolean b2 = hs.add(\"a\"); //当向set集合中存储重复元素的时候返回为falsehs.add(\"b\");hs.add(\"c\");hs.add(\"d\");System.out.println(hs); //HashSet的继承体系中有重写toString方法System.out.println(b1);System.out.println(b2);for (String string : hs) &#123; //只要能用迭代器迭代的,就可以使用增强for循环遍历 System.out.println(string);&#125; Set集合,无索引,不可以重复,无序(存取不一致) HashSet存储自定义对象保证元素唯一性 存储自定义对象，并保证元素唯一性。 1234567HashSet&lt;Person&gt; hs = new HashSet&lt;&gt;();hs.add(new Person(\"张三\", 23));hs.add(new Person(\"张三\", 23));hs.add(new Person(\"李四\", 23));hs.add(new Person(\"李四\", 23));hs.add(new Person(\"王五\", 23));hs.add(new Person(\"赵六\", 23)); 12345678910111213141516171819202122232425262728293031323334353637383940package com.wxhao.bean;public class Person &#123; private String name; private int age; public Person() &#123; super(); &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125; @Override public boolean equals(Object obj) &#123; System.out.println(\"执行了吗\"); Person p = (Person)obj; return this.name.equals(p.name) &amp;&amp; this.age == p.age; &#125; @Override public int hashCode() &#123; return 10; &#125; 重写hashCode()和equals()方法 先调用hashCode(),如果一样,就会调用equals()进行比较 HashSet存储自定义对象保证元素唯一性图解及代码优化 代码优化 为了减少比较，优化hashCode()代码写法。 最终版就是自动生成即可。 HashSet如何保证元素唯一性的原理 1.HashSet原理 我们使用Set集合都是需要去掉重复元素的, 如果在存储的时候逐个equals()比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用equals()方法的次数 当HashSet调用add()方法存储对象的时候, 先调用对象的hashCode()方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象 如果没有哈希值相同的对象就直接存入集合 如果有哈希值相同的对象, 就和哈希值相同的对象逐个进行equals()比较,比较结果为false就存入, true则不存 2.将自定义类的对象存入HashSet去重复 类中必须重写hashCode()和equals()方法 hashCode(): 属性相同的对象返回值必须相同, 属性不同的返回值尽量不同(提高效率) equals(): 属性相同返回true, 属性不同返回false,返回false的时候存储 1234567891011121314151617181920212223242526272829303132/* * 为什么是31? * 1. 31是一个质数,质数是能被1和自己本身整除的数 * 2. 31这个数既不大也不小 * 3. 31这个数好算,2的五次方-1,2向左移动5位 */@Overridepublic int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result;&#125;@Overridepublic boolean equals(Object obj) &#123; if (this == obj) //调用的对象和传入的对象是同一个对象 return true; //直接返回true if (obj == null) //传入的对象为null return false; //返回false if (getClass() != obj.getClass()) //判断两个对象对应的字节码文件是否是同一个字节码 return false; //如果不是直接返回false Person other = (Person) obj; //向下转型 if (age != other.age) //调用对象的年龄不等于传入对象的年龄 return false; //返回false if (name == null) &#123; //调用对象的姓名为null if (other.name != null) //传入对象的姓名不为null return false; //返回false &#125; else if (!name.equals(other.name)) //调用对象的姓名不等于传入对象的姓名 return false; //返回false return true; //返回true&#125; LinkedHashSet的概述和使用 LinkedHashSet的特点 案例演示 LinkedHashSet的特点 可以保证怎么存就怎么取 12345678910111213141516171819202122232425package com.wxhao.set;import java.util.LinkedHashSet;public class Demo2_LinkedHashSet &#123; /** * @param args * LinkedHashSet * 底层是链表实现的,是set集合中唯一一个能保证怎么存就怎么取的集合对象 * 因为是HashSet的子类,所以也是保证元素唯一的,与HashSet的原理一样 */ public static void main(String[] args) &#123; LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;&gt;(); lhs.add(\"a\"); lhs.add(\"a\"); lhs.add(\"a\"); lhs.add(\"a\"); lhs.add(\"b\"); lhs.add(\"c\"); lhs.add(\"d\"); System.out.println(lhs); &#125;&#125; 产生10个1-20之间的随机数要求随机数不能重复 需求：编写一个程序，获取10个1至20的随机数，要求随机数不能重复。并把最终的随机数输出到控制台。 1234567891011121314151617181920212223/*** 分析:* 1,有Random类创建随机数对象* 2,需要存储10个随机数,而且不能重复,所以我们用HashSet集合* 3,如果HashSet的size是小于10就可以不断的存储,如果大于等于10就停止存储* 4,通过Random类中的nextInt(n)方法获取1到20之间的随机数,并将这些随机数存储在HashSet集合中* 5,遍历HashSet */ public static void main(String[] args) &#123; //1,有Random类创建随机数对象 Random r = new Random(); //2,需要存储10个随机数,而且不能重复,所以我们用HashSet集合 HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;(); //3,如果HashSet的size是小于10就可以不断的存储,如果大于等于10就停止存储 while(hs.size() &lt; 10) &#123; //4,通过Random类中的nextInt(n)方法获取1到20之间的随机数,并将这些随机数存储在HashSet集合中 hs.add(r.nextInt(20) + 1); &#125; // 5,遍历HashSet for (Integer integer : hs) &#123; System.out.println(integer); &#125; &#125; 集合框架(练习) 使用Scanner从键盘读取一行输入,去掉其中重复字符, 打印出不同的那些字符 aaaabbbcccddd 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*** 分析:* 1,创建Scanner对象* 2,创建HashSet对象,将字符存储,去掉重复* 3,将字符串转换为字符数组,获取每一个字符存储在HashSet集合中,自动去除重复* 4,遍历HashSet,打印每一个字符 */ public static void main(String[] args) &#123; //1,创建Scanner对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一行字符串:\"); //2,创建HashSet对象,将字符存储,去掉重复 HashSet&lt;Character&gt; hs = new HashSet&lt;&gt;(); //3,将字符串转换为字符数组,获取每一个字符存储在HashSet集合中,自动去除重复 String line = sc.nextLine(); char[] arr = line.toCharArray(); for (char c : arr) &#123; //遍历字符数组 hs.add(c); &#125; //4,遍历HashSet,打印每一个字符 for(Character ch : hs) &#123; System.out.print(ch); &#125; &#125; ``` ## 集合框架(练习)* 将集合中的重复元素去掉```java/** * 分析: * 1,创建List集合存储若干个重复元素 * 2,单独定义方法去除重复 * 3,打印一下List集合 */public static void main(String[] args) &#123; //1,创建List集合存储若干个重复元素 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"a\"); list.add(\"a\"); list.add(\"b\"); list.add(\"b\"); list.add(\"b\"); list.add(\"c\"); list.add(\"c\"); list.add(\"c\"); list.add(\"c\"); //2,单独定义方法去除重复 getSingle(list); //3,打印一下List集合 System.out.println(list);&#125;/* * 分析 * 去除List集合中的重复元素 * 1,创建一个LinkedHashSet集合 * 2,将List集合中所有的元素添加到LinkedHashSet集合 * 3,将list集合中的元素清除 * 4,将LinkedHashSet集合中的元素添加回List集合中 */public static void getSingle(List&lt;String&gt; list) &#123; //1,创建一个LinkedHashSet集合 LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;&gt;(); //2,将List集合中所有的元素添加到LinkedHashSet集合 lhs.addAll(list); //3,将list集合中的元素清除 list.clear(); //4,将LinkedHashSet集合中的元素添加回List集合中 list.addAll(lhs);&#125; TreeSet存储Integer类型的元素并遍历 TreeSet存储Integer类型的元素并遍历 TreeSet集合是用来对象元素进行排序的,同样他也可以保证元素的唯一 12345678910TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();ts.add(3);ts.add(1);ts.add(1);ts.add(2);ts.add(2);ts.add(3);ts.add(3);System.out.println(ts); TreeSet存储自定义对象 存储Person对象 12345678TreeSet&lt;Person&gt; ts = new TreeSet&lt;&gt;();ts.add(new Person(\"张三\", 23));ts.add(new Person(\"李四\", 13));ts.add(new Person(\"周七\", 13));ts.add(new Person(\"王五\", 43));ts.add(new Person(\"赵六\", 33));System.out.println(ts); 需要比较元素大小所以Person类要实现comparable接口 123public int compareTo(Person o) &#123; return 0; &#125; 当compareTo方法返回0的时候集合中只有一个元素 当compareTo方法返回正数的时候集合会怎么存就怎么取 当compareTo方法返回负数的时候集合会倒序存储 TreeSet保证元素唯一和自然排序的原理和图解 TreeSet保证元素唯一和自然排序的原理和图解 123456@Override//按照年龄排序public int compareTo(Person o) &#123; int num = this.age - o.age; //年龄是比较的主要条件 return num == 0 ? this.name.compareTo(o.name) : num;//姓名是比较的次要条件&#125; TreeSet存储自定义对象并遍历练习1 TreeSet存储自定义对象并遍历练习1(按照姓名排序) 123456@Override//按照姓名排序public int compareTo(Person o) &#123; int num = this.name.compareTo(o.name); //姓名是主要条件 return num == 0 ? this.age - o.age : num; //年龄是次要条件&#125; TreeSet存储自定义对象并遍历练习2 TreeSet存储自定义对象并遍历练习2(按照姓名的长度排序) 12345public int compareTo(Person o) &#123; int length = this.name.length() - o.name.length(); //比较长度为主要条件 int num = length == 0 ? this.name.compareTo(o.name) : length; //比较内容为次要条件 return num == 0 ? this.age - o.age : num; //比较年龄为次要条件&#125; TreeSet保证元素唯一和比较器排序的原理及代码实现 TreeSet保证元素唯一和比较器排序的原理及代码实现 123456789class CompareByLen /*extends Object*/ implements Comparator&lt;String&gt; &#123; @Override public int compare(String s1, String s2) &#123; //按照字符串的长度比较 int num = s1.length() - s2.length(); //长度为主要条件 return num == 0 ? s1.compareTo(s2) : num; //内容为次要条件 &#125; &#125; 12345678TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new CompareByLen()); //Comparator c = new CompareByLen(); ts.add(\"aaaaaaaa\"); ts.add(\"z\"); ts.add(\"wc\"); ts.add(\"nba\"); ts.add(\"cba\"); System.out.println(ts); TreeSet原理 1.特点 TreeSet是用来排序的, 可以指定一个顺序, 对象存入之后会按照指定的顺序排列 2.使用方式 a.自然顺序(Comparable) TreeSet类的add()方法中会把存入的对象提升为Comparable类型 调用对象的compareTo()方法和集合中的对象比较 根据compareTo()方法返回的结果进行存储 b.比较器顺序(Comparator) 创建TreeSet的时候可以制定 一个Comparator 如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序 add()方法内部会自动调用Comparator接口中compare()方法排序 调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数 c.两种方式的区别 TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException) TreeSet如果传入Comparator, 就优先按照Comparator 集合框架(练习) 在一个集合中存储了无序并且重复的字符串,定义一个方法,让其有序(字典顺序),而且还不能去除重复 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 分析: * 1,定义一个List集合,并存储重复的无序的字符串 * 2,定义方法对其排序保留重复 * 3,打印List集合 */public static void main(String[] args) &#123; //1,定义一个List集合,并存储重复的无序的字符串 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"aaa\"); list.add(\"aaa\"); list.add(\"ccc\"); list.add(\"ddd\"); list.add(\"fffffffffff\"); list.add(\"wxhao\"); list.add(\"itcast\"); list.add(\"bbbb\"); list.add(\"aaa\"); list.add(\"aaa\"); //2,定义方法对其排序保留重复 sort(list); //3,打印list System.out.println(list);&#125;/* * 定义方法,排序并保留重复 * 分析: * 1,创建TreeSet集合对象,因为String本身就具备比较功能,但是重复不会保留,所以我们用比较器 * 2,将list集合中所有的元素添加到TrreSet集合中,对其排序,保留重复 * 3,清空list集合 * 4,将TreeSet集合中排好序的元素添加到list中 */public static void sort(List&lt;String&gt; list) &#123; //1,创建TreeSet集合对象,因为String本身就具备比较功能,但是重复不会保留,所以我们用比较器 TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String s1, String s2) &#123; int num = s1.compareTo(s2); //比较内容为主要条件 return num == 0 ? 1 : num; //保留重复 &#125; &#125;); //2,将list集合中所有的元素添加到TrreSet集合中,对其排序,保留重复 ts.addAll(list); //3,清空list集合 list.clear(); //4,将TreeSet集合中排好序的元素添加到list中 list.addAll(ts);&#125; 集合框架(练习) 从键盘接收一个字符串, 程序对其中所有字符进行排序,例如键盘输入: helloitcast程序打印:acehillostt 123456789101112131415161718192021222324252627282930313233343536/** * 分析: * 1,键盘录入字符串,Scanner * 2,将字符串转换为字符数组 * 3,定义TreeSet集合,传入比较器对字符排序并保留重复 * 4,遍历字符数组,将每一个字符存储在TreeSet集合中 * 5,遍历TreeSet集合,打印每一个字符 */public static void main(String[] args) &#123; //1,键盘录入字符串,Scanner Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串\"); String line = sc.nextLine(); //2,将字符串转换为字符数组 char[] arr = line.toCharArray(); //3,定义TreeSet集合,传入比较器对字符排序并保留重复 TreeSet&lt;Character&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Character&gt;() &#123; @Override public int compare(Character c1, Character c2) &#123; //int num = c1 - c2; //自动拆箱 int num = c1.compareTo(c2); return num == 0 ? 1 : num; &#125; &#125;); //4,遍历字符数组,将每一个字符存储在TreeSet集合中 for(char c : arr) &#123; ts.add(c); //自动装箱 &#125; //5,遍历TreeSet集合,打印每一个字符 for(Character c : ts) &#123; System.out.print(c); &#125;&#125; 集合框架(练习) 程序启动后, 可以从键盘输入接收多个整数, 直到输入quit时结束输入. 把所有输入的整数倒序排列打印. 123456789101112131415161718192021222324252627282930313233343536/** * 1,创建Scanner对象,键盘录入 * 2,创建TreeSet集合对象,TreeSet集合中传入比较器 * 3,无限循环不断接收整数,遇到quit退出,因为退出是quit,所以键盘录入的时候应该都以字符串的形式录入 * 4,判断是quit就退出,不是将其转换为Integer,并添加到集合中 * 5,遍历TreeSet集合并打印每一个元素 */public static void main(String[] args) &#123; //1,创建Scanner对象,键盘录入 Scanner sc = new Scanner(System.in); //2,创建TreeSet集合对象,TreeSet集合中传入比较器 TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer i1, Integer i2) &#123; //int num = i2 - i1; //自动拆箱 int num = i2.compareTo(i1); return num == 0 ? 1 : num; &#125; &#125;); //3,无限循环不断接收整数,遇到quit退出,因为退出是quit,所以键盘录入的时候应该都以字符串的形式录入 while(true) &#123; String line = sc.nextLine(); //将键盘录入的字符串存储在line中 if(\"quit\".equals(line)) &#123; break; &#125; //4,判断是quit就退出,不是将其转换为Integer,并添加到集合中 Integer i = Integer.parseInt(line); ts.add(i); &#125; // 5,遍历TreeSet集合并打印每一个元素 for (Integer integer : ts) &#123; System.out.println(integer); &#125;&#125; 键盘录入学生信息按照总分排序后输出在控制台 需求：键盘录入5个学生信息(姓名,语文成绩,数学成绩,英语成绩),按照总分从高到低输出到控制台。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 分析: * 1,定义一个学生类 * 成员变量:姓名,语文成绩,数学成绩,英语成绩,总成绩 * 成员方法:空参,有参构造,有参构造的参数分别是姓名,语文成绩,数学成绩,英语成绩 * toString方法,在遍历集合中的Student对象打印对象引用的时候会显示属性值 * 2,键盘录入需要Scanner,创建键盘录入对象 * 3,创建TreeSet集合对象,在TreeSet的构造函数中传入比较器,按照总分比较 * 4,录入五个学生,所以以集合中的学生个数为判断条件,如果size是小于5就进行存储 * 5,将录入的字符串切割,用逗号切割,会返回一个字符串数组,将字符串数组中从二个元素转换成int数, * 6,将转换后的结果封装成Student对象,将Student添加到TreeSet集合中 * 7,遍历TreeSet集合打印每一个Student对象 */public static void main(String[] args) &#123; //2,键盘录入需要Scanner,创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入学生成绩格式是:姓名,语文成绩,数学成绩,英语成绩\"); //3,创建TreeSet集合对象,在TreeSet的构造函数中传入比较器,按照总分比较 TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; int num = s2.getSum() - s1.getSum(); return num == 0 ? 1 : num; &#125; &#125;); //4,录入五个学生,所以以集合中的学生个数为判断条件,如果size是小于5就进行存储 while(ts.size() &lt; 5) &#123; //5,将录入的字符串切割,用逗号切割,会返回一个字符串数组,将字符串数组中从二个元素转换成int数, String line = sc.nextLine(); String[] arr = line.split(\",\"); int chinese = Integer.parseInt(arr[1]); int math = Integer.parseInt(arr[2]); int english = Integer.parseInt(arr[3]); //6,将转换后的结果封装成Student对象,将Student添加到TreeSet集合中 ts.add(new Student(arr[0], chinese, math, english)); &#125; //7,遍历TreeSet集合打印每一个Student对象 System.out.println(\"排序后的学生信息:\"); for (Student s : ts) &#123; System.out.println(s); &#125;&#125; 1234567891011121314151617181920212223242526272829package com.wxhao.bean;public class Student &#123; private String name; private int chinese; private int math; private int english; private int sum; public Student() &#123; super(); &#125; public Student(String name, int chinese, int math, int english) &#123; super(); this.name = name; this.chinese = chinese; this.math = math; this.english = english; this.sum = this.chinese + this.math + this.english; &#125; public int getSum() &#123; return sum; &#125; public String toString() &#123; return name + \",\" + chinese + \",\" + math + \",\" + english + \",\" + sum; &#125;&#125; 总结 List 普通for循环, 使用get()逐个获取 调用iterator()方法得到Iterator, 使用hasNext()和next()方法 增强for循环, 只要可以使用Iterator的类都可以用 d.Vector集合可以使用Enumeration的hasMoreElements()和nextElement()方法 Set 调用iterator()方法得到Iterator, 使用hasNext()和next()方法 增强for循环, 只要可以使用Iterator的类都可以用 普通for循环,迭代器,增强for循环是否可以在遍历的过程中删除","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE集合框架 - Collection","date":"2013-08-24T16:00:00.000Z","path":"2013/08/25/2013-08-25-collection-arraylist/","text":"JavaSE集合框架 - Collection 去除ArrayList中重复字符串元素方式 案例演示 需求：ArrayList去除集合中字符串的重复值(字符串的内容相同) 思路：创建新集合方式 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(\"a\"); list.add(\"a\"); list.add(\"b\"); list.add(\"b\"); list.add(\"b\"); list.add(\"c\"); list.add(\"c\"); list.add(\"c\"); list.add(\"c\"); System.out.println(list); ArrayList newList = getSingle(list); System.out.println(newList);&#125;/* * 去除重复 * 1,返回ArrayList * 2,参数列表ArrayList */public static ArrayList getSingle(ArrayList list) &#123; ArrayList newList = new ArrayList(); //创建一个新集合 Iterator it = list.iterator(); //获取迭代器 while(it.hasNext()) &#123; //判断老集合中是否有元素 String temp = (String)it.next(); //将每一个元素临时记录住 if(!newList.contains(temp)) &#123; //如果新集合中不包含该元素 newList.add(temp); //将该元素添加到新集合中 &#125; &#125; return newList; //将新集合返回&#125; 去除ArrayList中重复自定义对象元素 案例演示 需求：ArrayList去除集合中自定义对象元素的重复值(对象的成员变量值相同) 注意事项 重写equals()方法的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.wxhao.list;import java.util.ArrayList;import java.util.Iterator;import com.wxhao.bean.Person;@SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;)public class Demo2_ArrayList &#123; /** * * contains方法判断是否包含,底层依赖的是equals方法 remove方法判断是否删除,底层依赖的是equals方法 */ public static void main(String[] args) &#123; ArrayList list = new ArrayList(); //创建集合对象 list.add(new Person(\"张三\", 23)); list.add(new Person(\"张三\", 23)); list.add(new Person(\"李四\", 24)); list.add(new Person(\"李四\", 24)); list.add(new Person(\"李四\", 24)); list.add(new Person(\"李四\", 24)); //ArrayList newList = getSingle(list); //调用方法去除重复 //System.out.println(newList); list.remove(new Person(\"张三\", 23)); System.out.println(list); &#125; /* * 创建新集合将重复元素去掉 * 1,明确返回值类型,返回ArrayList * 2,明确参数列表ArrayList * * 分析: * 1,创建新集合 * 2,根据传入的集合(老集合)获取迭代器 * 3,遍历老集合 * 4,通过新集合判断是否包含老集合中的元素,如果包含就不添加,如果不包含就添加 */ public static ArrayList getSingle(ArrayList list) &#123; ArrayList newList = new ArrayList&lt;&gt;(); //1,创建新集合 Iterator it = list.iterator(); //2,根据传入的集合(老集合)获取迭代器 while(it.hasNext()) &#123; //3,遍历老集合 Object obj = it.next(); //记录住每一个元素 if(!newList.contains(obj)) &#123; //如果新集合中不包含老集合中的元素 newList.add(obj); //将该元素添加 &#125; &#125; return newList; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.wxhao.bean;public class Person &#123; private String name; private int age; public Person() &#123; super(); &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125; /*@Override public boolean equals(Object obj) &#123; Person p = (Person)obj; return this.name.equals(p.name) &amp;&amp; this.age == p.age; &#125;*/&#125; LinkedList的特有功能 LinkedList类概述 LinkedList类特有功能 public void addFirst(E e)及addLast(E e) public E getFirst()及getLast() public E removeFirst()及public E removeLast() public E get(int index); 1234567891011121314151617181920212223package com.wxhao.list;import java.util.LinkedList;public class Demo3_LinkedList &#123; public static void main(String[] args) &#123; LinkedList list = new LinkedList(); list.addFirst(\"a\"); list.addFirst(\"b\"); list.addFirst(\"c\"); list.addFirst(\"d\"); list.addLast(\"e\"); //System.out.println(list.getFirst());//d //System.out.println(list.getLast());//e //System.out.println(list.removeFirst());//cbea //System.out.println(list.removeLast());//dcba System.out.println(list.get(1));//c System.out.println(list);//dcbae &#125;&#125; 栈和队列数据结构 栈 先进后出 队列 先进先出 用LinkedList模拟栈数据结构的集合并测试 案例演示 需求：请用LinkedList模拟栈数据结构的集合，并测试 创建一个类将Linked中的方法封装 123456789101112131415public class Stack &#123;private LinkedList list = new LinkedList(); //创建LinkedList对象public void in(Object obj) &#123; list.addLast(obj); //封装addLast()方法&#125;public Object out() &#123; return list.removeLast(); //封装removeLast()方法&#125;public boolean isEmpty() &#123; return list.isEmpty(); //封装isEmpty()方法&#125;&#125; 泛型概述和基本使用 泛型概述 泛型好处 提高安全性(将运行期的错误转换到编译期) 省去强转的麻烦 泛型基本使用 &lt;&gt;中放的必须是引用数据类型 泛型使用注意事项 前后的泛型必须一致,或者后面的泛型可以省略不写(1.7的新特性菱形泛型) 123456789101112131415161718192021222324252627282930313233343536package com.wxhao.generic;import java.util.ArrayList;import java.util.Iterator;import com.wxhao.bean.Person;public class Demo1_Generic &#123; public static void main(String[] args) &#123; //demo1(); //int[] arr = new byte[5]; //数组要保证前后的数据类型一致 //ArrayList&lt;Object&gt; list = new ArrayList&lt;Person&gt;(); //集合的泛型要保证前后的数据类型一致 //ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //1.7版本的新特性,菱形泛型 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //泛型最好不要定义成Object,没有意义 list.add(\"aaa\"); list.add(true); &#125; public static void demo1() &#123; ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); // list.add(110); // list.add(true); list.add(new Person(\"张三\", 23)); list.add(new Person(\"李四\", 24)); Iterator&lt;Person&gt; it = list.iterator(); while(it.hasNext()) &#123; //System.out.println(it.next()); //System.out.println(it.next().getName() + \"...\" + it.next().getAge());//next方法只能调用一次,如果调用多次会将指针向后移动多次 Person p = it.next(); System.out.println(p.getName() + \"...\" + p.getAge()); &#125; &#125;&#125; ArrayList存储字符串和自定义对象并遍历泛型版 ArrayList存储字符串并遍历泛型版 123456789101112131415161718192021222324252627282930313233343536package com.wxhao.generic;import java.util.ArrayList;import java.util.Iterator;import com.wxhao.bean.Person;public class Demo2_Generic &#123; public static void main(String[] args) &#123; // demo1(); ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Person(\"张三\", 23)); list.add(new Person(\"李四\", 24)); list.add(new Person(\"王五\", 25)); list.add(new Person(\"赵六\", 26)); Iterator&lt;Person&gt; it = list.iterator(); while (it.hasNext()) &#123; Person p = it.next(); // 将集合中的每一个元素用Person记录 System.out.println(p.getName() + \"...\" + p.getAge()); &#125; &#125; public static void demo1() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); // 创建集合对象 list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; 泛型的由来 泛型的由来:通过Object转型问题引入 早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。 泛型类的概述及使用 泛型类概述 把泛型定义在类上 定义格式 public class 类名&lt;泛型类型1,…&gt; C:注意事项 泛型类型必须是引用类型 案例演示 泛型类的使用 123456789101112package com.wxhao.bean;public class Tool&lt;Q&gt; &#123; private Q q; public Q getObj() &#123; return q; &#125; public void setObj(Q q) &#123; this.q = q; &#125; 12345678910111213package com.wxhao.bean;public class Student extends Person &#123; public Student() &#123; &#125; public Student(String name, int age) &#123; super(name, age); &#125;&#125; 12345678910111213package com.wxhao.bean;public class Worker extends Person &#123; public Worker() &#123; &#125; public Worker(String name, int age) &#123; super(name, age); &#125;&#125; 泛型方法的概述和使用 泛型方法概述 把泛型定义在方法上 定义格式 public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 变量名) 案例演示 泛型方法的使用 123456789101112131415161718192021package com.wxhao.bean;public class Tool&lt;Q&gt; &#123; private Q q; public Q getObj() &#123; return q; &#125; public void setObj(Q q) &#123; this.q = q; &#125; public&lt;T&gt; void show(T t) &#123; //方法泛型最好与类的泛型一致 System.out.println(t); //如果不一致,需要在方法上声明该泛型 &#125; public static&lt;W&gt; void print(W w) &#123; //静态方法必须声明自己的泛型 System.out.println(w); &#125;&#125; 12345678910111213141516171819202122package com.wxhao.generic;import com.wxhao.bean.Student;import com.wxhao.bean.Tool;public class Demo3_Generic &#123; public static void main(String[] args) &#123; //demo1(); Tool&lt;String&gt; t = new Tool&lt;&gt;(); //t.show(\"abc\"); t.show(true); &#125; public static void demo1() &#123; Tool&lt;Student&gt; t = new Tool&lt;&gt;(); //创建工具类对象 t.setObj(new Student(\"张三\",23)); //Worker w = (Worker) t.getObj(); //向下转型 //System.out.println(w); &#125;&#125; 泛型接口的概述和使用 泛型接口概述 把泛型定义在接口上 定义格式 public interface 接口名&lt;泛型类型&gt; 泛型接口的使用 12345678910111213141516171819202122232425package com.wxhao.generic;public class Demo4_Generic &#123;&#125;interface Inter&lt;T&gt; &#123; public void show(T t);&#125;/*class Demo implements Inter&lt;String&gt; &#123; //推荐用这种 @Override public void show(String t) &#123; System.out.println(t); &#125; &#125;*/class Demo&lt;T&gt; implements Inter&lt;T&gt; &#123; //没有必要在实现接口的时候给自己类加泛型 @Override public void show(T t) &#123; System.out.println(t); &#125;&#125; 泛型高级之通配符 泛型通配符&lt;?&gt; 任意类型，如果没有明确，那么就是Object以及任意的Java类了 ? extends E 向下限定，E及其子类 ? super E 向上限定，E及其父类 123456789101112131415161718192021222324package com.wxhao.generic;import java.util.ArrayList;import com.wxhao.bean.Person;import com.wxhao.bean.Student;public class Demo5_Generic &#123; public static void main(String[] args) &#123; //List&lt;?&gt; list = new ArrayList&lt;Integer&gt;(); //当右边的泛型是不确定时,左边可以指定为? ArrayList&lt;Person&gt; list1 = new ArrayList&lt;&gt;(); list1.add(new Person(\"张三\", 23)); list1.add(new Person(\"李四\", 24)); list1.add(new Person(\"王五\", 25)); ArrayList&lt;Student&gt; list2 = new ArrayList&lt;&gt;(); list2.add(new Student(\"赵六\", 26)); list2.add(new Student(\"周七\", 27)); //子类自动提升为父类 list1.addAll(list2);// java.util.ArrayList.addAll(Collection&lt;? extends Person&gt; c) System.out.println(list1); &#125;&#125; 增强for的概述和使用 增强for概述 简化数组和Collection集合的遍历 格式： for(元素数据类型 变量 : 数组或者Collection集合) { 使用变量即可，该变量就是元素 } 案例演示 数组，集合存储元素用增强for遍历 好处 简化遍历 1234567891011121314int[] arr = &#123;11,22,33,44,55&#125;; for (int i : arr) &#123; System.out.println(i); &#125; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); for (String string : list) &#123; System.out.println(string); &#125; 增强for循环底层依赖的是迭代器(Iterator) ArrayList存储字符串和自定义对象并遍历增强for版 (JDK1.5) 案例演示 ArrayList存储字符串并遍历增强for版 123456789ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;();list.add(new Person(\"张三\", 23));list.add(new Person(\"李四\", 24));list.add(new Person(\"王五\", 25));list.add(new Person(\"赵六\", 26));for (Person person : list) &#123;System.out.println(person);&#125; 三种迭代的能否删除 普通for循环,可以删除,但是索引要– 迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常 增强for循环不能删除 123456789101112131415161718192021222324252627282930313233343536ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"a\");list.add(\"b\");list.add(\"b\");list.add(\"c\");list.add(\"d\");//1,普通for循环删除,索引要--/*for(int i = 0; i &lt; list.size(); i++) &#123; if(\"b\".equals(list.get(i))) &#123; list.remove(i--); //通过索引删除元素 &#125;&#125;*///2,迭代器删除/*Iterator&lt;String&gt; it = list.iterator();while(it.hasNext()) &#123; if(\"b\".equals(it.next())) &#123; //list.remove(\"b\"); //不能用集合的删除方法,因为迭代过程中如果集合修改会出现并发修改异常 it.remove(); &#125;&#125;*//*for(Iterator&lt;String&gt; it2 = list.iterator(); it2.hasNext();) &#123; if(\"b\".equals(it2.next())) &#123; //list.remove(\"b\"); //不能用集合的删除方法,因为迭代过程中如果集合修改会出现并发修改异常 it2.remove(); &#125;&#125;*///3,增强for循环,增强for循环不能删除,只能遍历for (String string : list) &#123; if(\"b\".equals(string)) &#123; list.remove(\"b\"); &#125;&#125;System.out.println(list); 静态导入的概述和使用 (JDK1.5) 静态导入概述 格式： import static 包名….类名.方法名; 可以直接导入到方法的级别 注意事项 方法必须是静态的,如果有多个同名的静态方法，容易不知道使用谁?这个时候要使用，必须加前缀。由此可见，意义不大，所以一般不用，但是要能看懂。 12345678910111213package com.wxhao.jdk5;import static java.util.Arrays.sort; //静态导入import static java.util.Arrays.toString; //静态导入public class Demo2_StaticImport &#123; public static void main(String[] args) &#123; int[] arr = &#123;55,22,33,44,11&#125;; sort(arr); //排序 //System.out.println(toString(arr));//toString冲突 &#125;&#125; 可变参数的概述和使用 (JDK1.5) A:可变参数概述 定义方法的时候不知道该定义多少个参数 B:格式 修饰符 返回值类型 方法名(数据类型… 变量名){} C:注意事项： 这里的变量其实是一个数组 如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个 12345678910111213141516171819202122232425package com.wxhao.jdk5;public class Demo3_ChangeableArgs &#123; public static void main(String[] args) &#123; int[] arr = &#123;11,22,33,44,55&#125;; //print(arr); print(11,22,33,44,55,66); System.out.println(\"---------------\"); //print(); &#125; /*public static void print(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;*/ public static void print(int i ,int ... arr) &#123; //可变参数其实是一个数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; Arrays工具类的asList()方法的使用 (JDK1.5) Arrays工具类的asList()方法的使用 Collection中toArray(T[] a)泛型版的集合转数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.wxhao.jdk5;import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class Demo4_AsList &#123; /** * 数组转换成集合 * 数组转换成集合虽然不能增加或减少元素,但是可以用集合的思想操作数组,也就是说可以使用其他集合中的方法 */ public static void main(String[] args) &#123; //demo1(); //demo2(); //集合转数组,加泛型的 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); // String[] arr = list.toArray(new String[1]);//当集合转换数组时,数组长度如果是小于等于集合的size时,转换后的数组长度等于集合的size String[] arr = list.toArray(new String[10]);//如果数组的长度大于了size,分配的数组长度就和你指定的长度一样 for (String string : arr) &#123; System.out.println(string); &#125; &#125; public static void demo2() &#123; //int[] arr = &#123;11,22,33,44,55&#125;; //List&lt;int[]&gt; list = Arrays.asList(arr); 基本数据类型的数组转换成集合,会将整个数组当作一个对象转换 //System.out.println(list); Integer[] arr = &#123;11,22,33,44,55&#125;; //将数组转换成集合,数组必须是引用数据类型 List&lt;Integer&gt; list = Arrays.asList(arr); System.out.println(list); &#125; public static void demo1() &#123; String[] arr = &#123;\"a\",\"b\",\"c\"&#125;; List&lt;String&gt; list = Arrays.asList(arr); //将数组转换成集合 //list.add(\"d\"); //不能添加 System.out.println(list); &#125;&#125; 集合嵌套之ArrayList嵌套ArrayList 集合嵌套之ArrayList嵌套ArrayList 123456789101112131415161718192021222324252627282930313233343536373839package com.wxhao.list;import java.util.ArrayList;import com.wxhao.bean.Person;public class Demo5_ArrayListArrayList &#123; /** * 案例: * 我们学科,学科又分为若个班级 * 整个学科一个大集合 * 若干个班级分为每一个小集合 */ public static void main(String[] args) &#123; ArrayList&lt;ArrayList&lt;Person&gt;&gt; list = new ArrayList&lt;&gt;(); ArrayList&lt;Person&gt; first = new ArrayList&lt;&gt;(); //创建第一个班级 first.add(new Person(\"杨幂\", 30)); first.add(new Person(\"李冰冰\", 33)); first.add(new Person(\"范冰冰\", 20)); ArrayList&lt;Person&gt; second = new ArrayList&lt;&gt;(); second.add(new Person(\"黄晓明\", 31)); second.add(new Person(\"赵薇\", 33)); second.add(new Person(\"陈坤\", 32)); //将班级添加到学科集合中 list.add(first); list.add(second); //遍历学科集合 for(ArrayList&lt;Person&gt; a : list) &#123; for(Person p : a) &#123; System.out.println(p); &#125; &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE集合框架 - 对象数组","date":"2013-08-19T16:00:00.000Z","path":"2013/08/20/2013-08-20-collection-framework-object/","text":"JavaSE集合框架 - 对象数组 对象数组的概述和使用 需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。 12345678910Student[] arr = new Student[5]; //存储学生对象 arr[0] = new Student(\"张三\", 23); arr[1] = new Student(\"李四\", 24); arr[2] = new Student(\"王五\", 25); arr[3] = new Student(\"赵六\", 26); arr[4] = new Student(\"马哥\", 20); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; 把学生数组的案例画图讲解 数组和集合存储引用数据类型,存的都是地址值 12345678910111213141516171819202122232425262728293031package com.wxhao.bean;public class Student &#123; private String name; private int age; public Student() &#123; super(); &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student [name=\" + name + \", age=\" + age + \"]\"; &#125;&#125; 123456789101112131415161718package com.wxhao.collection;import com.wxhao.bean.Student;public class Demo1_Array &#123; public static void main(String[] args) &#123; //int[] arr = new int[5]; //创建基本数据类型数组 Student[] arr = new Student[5]; //创建引用数据类型数组 arr[0] = new Student(\"张三\", 23); //创建一个学生对象,存储在数组的第一个位置 arr[1] = new Student(\"李四\", 24); //创建一个学生对象,存储在数组的第二个位置 arr[2] = new Student(\"王五\", 25); //创建一个学生对象,存储在数组的第三个位置 for(int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 集合的由来及集合继承体系图 集合的由来 数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 数组和集合的区别 区别1 : 数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值 集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象 区别2: 数组长度是固定的,不能自动增长 集合的长度的是可变的,可以根据元素的增加而增长 数组和集合什么时候用 1,如果元素个数是固定的推荐用数组 2,如果元素个数不是固定的推荐用集合 集合继承体系图 Collection集合的基本功能测试基本功能演示 123456boolean add(E e)boolean remove(Object o)void clear()boolean contains(Object o)boolean isEmpty()int size() 注意: collectionXxx.java使用了未经检查或不安全的操作. 注意:要了解详细信息,请使用 -Xlint:unchecked重新编译. java编译器认为该程序存在安全隐患 温馨提示:这不是编译失败,所以先不用理会,等学了泛型你就知道了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.wxhao.collection;import java.util.ArrayList;import java.util.Collection;import com.wxhao.bean.Student;@SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;)public class Demo2_Collection &#123; /** add方法如果是List集合一直都返回true,因为List集合中是可以存储重复元素的 如果是Set集合当存储重复元素的时候,就会返回false ArrayList的父类的父类重写toString方法,所以在打印对象的引用的时候,输出的结果不是Object类中toString的结果 */ public static void main(String[] args) &#123; //demo1(); Collection c = new ArrayList(); c.add(\"a\"); c.add(\"b\"); c.add(\"c\"); c.add(\"d\"); //c.remove(\"b\"); //删除指定元素 //c.clear(); //清空集合 //System.out.println(c.contains(\"b\")); //判断是否包含 //System.out.println(c.isEmpty()); System.out.println(c.size()); //获取元素的个数 System.out.println(c); &#125; public static void demo1() &#123; Collection c = new ArrayList(); //父类引用指向子类对象 boolean b1 = c.add(\"abc\"); boolean b2 = c.add(true); //自动装箱new Boolean(true); boolean b3 = c.add(100); boolean b4 = c.add(new Student(\"张三\",23)); boolean b5 = c.add(\"abc\"); System.out.println(b1); System.out.println(b2); System.out.println(b3); System.out.println(b4); System.out.println(b5); System.out.println(c.toString()); &#125;&#125; 集合的遍历之集合转数组遍历 集合的遍历 其实就是依次获取集合中的每一个元素。 把集合转成数组，可以实现集合的遍历 toArray() 1234567891011Collection coll = new ArrayList();coll.add(new Student(\"张三\",23)); //Object obj = new Student(\"张三\",23);coll.add(new Student(\"李四\",24));coll.add(new Student(\"王五\",25));coll.add(new Student(\"赵六\",26));Object[] arr = coll.toArray(); //将集合转换成数组for (int i = 0; i &lt; arr.length; i++) &#123; Student s = (Student)arr[i]; //强转成Student System.out.println(s.getName() + \",\" + s.getAge());&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.wxhao.collection;import java.util.ArrayList;import java.util.Collection;import com.wxhao.bean.Student;@SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;)public class Demo3_Collection &#123; /** * * A:集合的遍历 * 其实就是依次获取集合中的每一个元素。 * B:案例演示 * 把集合转成数组，可以实现集合的遍历 * toArray() */ public static void main(String[] args) &#123; //demo1(); Collection c = new ArrayList(); c.add(new Student(\"张三\", 23)); //Object obj = new Student(\"张三\",23); c.add(new Student(\"李四\", 24)); c.add(new Student(\"王五\", 25)); c.add(new Student(\"赵六\", 26)); Object[] arr = c.toArray(); //将集合转换成数组 for (int i = 0; i &lt; arr.length; i++) &#123; //System.out.println(arr[i]); Student s = (Student)arr[i]; //向下转型 System.out.println(s.getName() + \"...\" + s.getAge()); &#125; &#125; public static void demo1() &#123; Collection c = new ArrayList(); c.add(\"a\"); c.add(\"b\"); c.add(\"c\"); c.add(\"d\"); Object[] arr = c.toArray(); //将集合转换成数组 for(int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; Collection集合的带All功能测试 带All的功能 1234boolean addAll(Collection c)boolean removeAll(Collection c)boolean containsAll(Collection c)boolean retainAll(Collection c) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.wxhao.collection;import java.util.ArrayList;import java.util.Collection;@SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;)public class Demo4_CollectionAll &#123; public static void main(String[] args) &#123; //demo1(); //demo2(); //demo3(); Collection c1 = new ArrayList(); c1.add(\"a\"); c1.add(\"b\"); c1.add(\"c\"); c1.add(\"d\"); Collection c2 = new ArrayList(); c2.add(\"a\"); c2.add(\"b\"); c2.add(\"c\"); c2.add(\"d\"); c2.add(\"e\"); c2.add(\"f\"); //取交集,如果调用的集合改变就返回true,如果调用的集合不变就返回false boolean b = c1.retainAll(c2); //取交集 System.out.println(b); System.out.println(c1); &#125; public static void demo3() &#123; Collection c1 = new ArrayList(); c1.add(\"a\"); c1.add(\"b\"); c1.add(\"c\"); c1.add(\"d\"); Collection c2 = new ArrayList(); c2.add(\"a\"); c2.add(\"b\"); c2.add(\"z\"); boolean b = c1.containsAll(c2); //判断调用的集合是否包含传入的集合 System.out.println(b); &#125; public static void demo2() &#123; Collection c1 = new ArrayList(); c1.add(\"a\"); c1.add(\"b\"); c1.add(\"c\"); c1.add(\"d\"); Collection c2 = new ArrayList(); c2.add(\"a\"); c2.add(\"b\"); c2.add(\"z\"); boolean b = c1.removeAll(c2);//删除的是交集 System.out.println(b); System.out.println(c1); &#125; public static void demo1() &#123; Collection c1 = new ArrayList(); c1.add(\"a\"); c1.add(\"b\"); c1.add(\"c\"); c1.add(\"d\"); Collection c2 = new ArrayList();//alt + shift + r改名 c2.add(\"a\"); c2.add(\"b\"); c2.add(\"c\"); c2.add(\"d\"); //c1.addAll(c2); //将c2中的每一个元素添加到c1中 c1.add(c2); //将c2看成一个对象添加到c1中 System.out.println(c1); &#125;&#125; 集合的遍历之迭代器遍历 迭代器概述 集合是用来存储元素,存储的元素需要查看,那么就需要迭代(遍历) 迭代器的使用 12345678910Collection c = new ArrayList();c.add(\"a\");c.add(\"b\");c.add(\"c\");c.add(\"d\");Iterator it = c.iterator(); //获取迭代器的引用while(it.hasNext()) &#123; //集合中的迭代方法(遍历) System.out.println(it.next());&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.wxhao.collection;import java.util.ArrayList;import java.util.Collection;@SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;)public class Demo4_CollectionAll &#123; public static void main(String[] args) &#123; //demo1(); //demo2(); //demo3(); Collection c1 = new ArrayList(); c1.add(\"a\"); c1.add(\"b\"); c1.add(\"c\"); c1.add(\"d\"); Collection c2 = new ArrayList(); c2.add(\"a\"); c2.add(\"b\"); c2.add(\"c\"); c2.add(\"d\"); c2.add(\"e\"); c2.add(\"f\"); //取交集,如果调用的集合改变就返回true,如果调用的集合不变就返回false boolean b = c1.retainAll(c2); //取交集 System.out.println(b); System.out.println(c1); &#125; public static void demo3() &#123; Collection c1 = new ArrayList(); c1.add(\"a\"); c1.add(\"b\"); c1.add(\"c\"); c1.add(\"d\"); Collection c2 = new ArrayList(); c2.add(\"a\"); c2.add(\"b\"); c2.add(\"z\"); boolean b = c1.containsAll(c2); //判断调用的集合是否包含传入的集合 System.out.println(b); &#125; public static void demo2() &#123; Collection c1 = new ArrayList(); c1.add(\"a\"); c1.add(\"b\"); c1.add(\"c\"); c1.add(\"d\"); Collection c2 = new ArrayList(); c2.add(\"a\"); c2.add(\"b\"); c2.add(\"z\"); boolean b = c1.removeAll(c2);//删除的是交集 System.out.println(b); System.out.println(c1); &#125; public static void demo1() &#123; Collection c1 = new ArrayList(); c1.add(\"a\"); c1.add(\"b\"); c1.add(\"c\"); c1.add(\"d\"); Collection c2 = new ArrayList();//alt + shift + r改名 c2.add(\"a\"); c2.add(\"b\"); c2.add(\"c\"); c2.add(\"d\"); //c1.addAll(c2); //将c2中的每一个元素添加到c1中 c1.add(c2); //将c2看成一个对象添加到c1中 System.out.println(c1); &#125;&#125; Collection存储自定义对象并遍历 Collection存储自定义对象并用迭代器遍历 12345678910111213141516171819Collection c = new ArrayList();c.add(new Student(\"张三\",23));c.add(new Student(\"李四\",24));c.add(new Student(\"王五\",25));c.add(new Student(\"赵六\",26));c.add(new Student(\"赵六\",26));for(Iterator it = c.iterator();it.hasNext();) &#123; Student s = (Student)it.next(); //向下转型 System.out.println(s.getName() + \",\" + s.getAge()); //获取对象中的姓名和年龄&#125;System.out.println(\"------------------------------\");Iterator it = c.iterator(); //获取迭代器while(it.hasNext()) &#123; //判断集合中是否有元素 //System.out.println(((Student)(it.next())).getName() + \",\" + ((Student)(it.next())).getAge()); Student s = (Student)it.next(); //向下转型 System.out.println(s.getName() + \",\" + s.getAge()); //获取对象中的姓名和年龄&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.wxhao.collection;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import com.wxhao.bean.Student;public class Demo5_Iterator &#123; /** * 迭代 * * A:迭代器概述 * 集合是用来存储元素,存储的元素需要查看,那么就需要迭代(遍历) */ public static void main(String[] args) &#123; //demo1(); Collection c = new ArrayList(); c.add(new Student(\"张三\", 23)); //Object obj = new Student(\"张三\",23); c.add(new Student(\"李四\", 24)); c.add(new Student(\"王五\", 25)); c.add(new Student(\"赵六\", 26)); //获取迭代器 Iterator it = c.iterator(); while(it.hasNext()) &#123; //System.out.println(it.next()); Student s = (Student)it.next(); //向下转型 System.out.println(s.getName() + \"...\" + s.getAge()); &#125; &#125; public static void demo1() &#123; Collection c = new ArrayList(); c.add(\"a\"); c.add(\"b\"); c.add(\"c\"); c.add(\"d\"); //对集合中的元素迭代(遍历) Iterator it = c.iterator(); //获取迭代器 /*boolean b1 = it.hasNext();//判断集合中是否有元素,有就返回true Object obj1 = it.next(); System.out.println(b1); System.out.println(obj1); boolean b2 = it.hasNext(); //判断集合中是否有元素,有就返回true Object obj2 = it.next(); System.out.println(b2); System.out.println(obj2);*/ while(it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125; 迭代器的原理及源码解析 迭代器原理 迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式,这样做的好处有二,第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可 迭代器源码解析 1,在eclipse中ctrl + shift + t找到ArrayList类 2,ctrl+o查找iterator()方法 3,查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口 4,查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 List集合的特有功能概述和测试 List集合的特有功能概述 void add(int index,E element) E remove(int index) E get(int index) E set(int index,E element) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.wxhao.list;import java.util.ArrayList;import java.util.List;public class Demo1_List &#123; /** * * void add(int index,E element) * E remove(int index) * E get(int index) * E set(int index,E element) */ public static void main(String[] args) &#123; //demo1(); //demo2(); //demo3(); //demo4(); List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.set(1, \"z\"); //将指定位置的元素修改 System.out.println(list); &#125; public static void demo4() &#123; List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); //Object obj1 = list.get(2); //System.out.println(obj1); //通过索引遍历List集合 for(int i = 0;i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125; public static void demo3() &#123; List list = new ArrayList(); list.add(111); list.add(222); list.add(333); list.remove(111); //删除的时候不会自动装箱,把111当作索引 System.out.println(list); &#125; public static void demo2() &#123; List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); Object obj = list.remove(1);//通过索引删除元素,将被删除的元素返回 System.out.println(obj); System.out.println(list); &#125; public static void demo1() &#123; List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(4, \"f\"); //index&lt;=size并且index&gt;=0都不会报异常 //list.add(1,\"e\"); //list.add(10, \"z\"); //java.lang.IndexOutOfBoundsException,当存储时使用不存在的索引时 System.out.println(list); &#125;&#125; List集合存储学生对象并遍历 通过size()和get()方法结合使用遍历。12345678910 List list = new ArrayList(); list.add(new Student(\"张三\", 18)); list.add(new Student(\"李四\", 18)); list.add(new Student(\"王五\", 18)); list.add(new Student(\"赵六\", 18));for(int i = 0; i &lt; list.size(); i++) &#123; Student s = (Student)list.get(i); System.out.println(s.getName() + \",\" + s.getAge());&#125; 12345678910111213141516171819202122232425262728package com.wxhao.list;import java.util.ArrayList;import java.util.List;import com.wxhao.bean.Student;public class Demo2_List &#123; /** * * A:案例演示 * 向List集合中存储学生对象 * 通过size()和get()方法结合使用遍历。 */ public static void main(String[] args) &#123; List list = new ArrayList(); list.add(new Student(\"张三\", 23)); //Object obj = new Student(\"张三\",23); list.add(new Student(\"李四\", 24)); list.add(new Student(\"王五\", 25)); list.add(new Student(\"赵六\", 26)); for(int i = 0; i &lt; list.size(); i++) &#123; //System.out.println(list.get(i)); //通过索引获取每一个元素 Student s = (Student)list.get(i); System.out.println(s.getName() + \"...\" + s.getAge()); &#125; &#125;&#125; 并发修改异常产生的原因及解决方案 需求：我有一个集合，请问，我想判断里面有没有”world”这个元素，如果有，我就添加一个”javaee”元素，请写代码实现。 12345678910111213141516171819202122232425262728293031List list = new ArrayList();list.add(\"a\");list.add(\"b\");list.add(\"world\");list.add(\"d\");list.add(\"e\");/*Iterator it = list.iterator();while(it.hasNext()) &#123; String str = (String)it.next(); if(str.equals(\"world\")) &#123; list.add(\"javaee\"); //这里会抛出ConcurrentModificationException并发修改异常 &#125;&#125;*/``` * ConcurrentModificationException出现 * 迭代器遍历，集合修改集合* 解决方案 * 迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add) * 集合遍历元素，集合修改元素```java ListIterator lit = list.listIterator(); //如果想在遍历的过程中添加元素,可以用ListIterator中的add方法 while(lit.hasNext()) &#123; String str = (String)lit.next(); if(str.equals(\"world\")) &#123; lit.add(\"javaee\"); //list.add(\"javaee\"); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.wxhao.list;import java.util.ArrayList;import java.util.List;import java.util.ListIterator;public class Demo3_List &#123; /** ** A:案例演示 * 需求：我有一个集合，请问，我想判断里面有没有\"world\"这个元素，如果有，我就添加一个\"javaee\"元素，请写代码实现。 */ public static void main(String[] args) &#123; List list = new ArrayList(); list.add(\"a\"); //Object obj = new String(); list.add(\"b\"); list.add(\"world\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); /*Iterator it = list.iterator(); //获取迭代器 while(it.hasNext()) &#123; //判断集合中是否有元素 String str = (String)it.next(); //向下转型 if(\"world\".equals(str)) &#123; list.add(\"javaee\"); //遍历的同时在增加元素,并发修改ConcurrentModificationException &#125; &#125;*/ ListIterator lit = list.listIterator(); //获取迭代器(List集合特有的) while(lit.hasNext()) &#123; String str = (String)lit.next(); //向下转型 if(\"world\".equals(str)) &#123; //list.add(\"javaee\"); //遍历的同时在增加元素,并发修改ConcurrentModificationException lit.add(\"javaee\"); &#125; &#125; System.out.println(list); &#125;&#125; ListIterator boolean hasNext()是否有下一个 boolean hasPrevious()是否有前一个 Object next()返回下一个元素 Object previous();返回上一个元素 1234567891011121314151617181920212223242526272829package com.wxhao.list;import java.util.ArrayList;import java.util.List;import java.util.ListIterator;public class Demo4_ListIterator &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(\"a\"); //Object obj = new String(); list.add(\"b\"); list.add(\"world\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); ListIterator lit = list.listIterator(); //获取迭代器 while(lit.hasNext()) &#123; System.out.println(lit.next()); //获取元素并将指针向后移动 &#125; System.out.println(\"-----------------\"); while(lit.hasPrevious()) &#123; System.out.println(lit.previous()); //获取元素并将指针向前移动 &#125; &#125;&#125; Vector的特有功能 Vector类概述 Vector类特有功能 public void addElement(E obj) public E elementAt(int index) public Enumeration elements() Vector的迭代 1234567891011Vector v = new Vector();//创建集合对象,List的子类v.addElement(\"a\");v.addElement(\"b\");v.addElement(\"c\");v.addElement(\"d\");//Vector迭代Enumeration en = v.elements();//获取枚举while(en.hasMoreElements()) &#123;//判断集合中是否有元素 System.out.println(en.nextElement());//获取集合中的元素&#125; 数据结构之数组和链表 数组 查询快修改也快 增删慢 链表 查询慢,修改也慢 增删快 List的三个子类的特点 List的三个子类的特点 123456789101112131415161718192021222324 ArrayList: 底层数据结构是数组，查询快，增删慢。 线程不安全，效率高。 Vector: 底层数据结构是数组，查询快，增删慢。 线程安全，效率低。 Vector相对ArrayList查询慢(线程安全的) Vector相对LinkedList增删慢(数组结构) LinkedList: 底层数据结构是链表，查询慢，增删快。 线程不安全，效率高。 Vector和ArrayList的区别 Vector是线程安全的,效率低 ArrayList是线程不安全的,效率高 共同点:都是数组实现的 ArrayList和LinkedList的区别 ArrayList底层是数组结果,查询和修改快 LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢 共同点:都是线程不安全的* List有三个儿子，我们到底使用谁呢? 查询多用ArrayList 增删多用LinkedList 如果都多ArrayList","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE常见对象 - util包基本常用类","date":"2013-08-11T16:00:00.000Z","path":"2013/08/12/2013-08-12-object-class-util/","text":"JavaSE常见对象 - util包基本常用类 Math类概述和方法使用 Math类概述 Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 成员方法 public static int abs(int a) public static double ceil(double a) public static double floor(double a) public static int max(int a,int b) min自学 public static double pow(double a,double b) public static double random() public static int round(float a) 参数为double的自学 public static double sqrt(double a) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.wxhao.otherclass;public class Demo1_Math &#123; public static void main(String[] args) &#123; System.out.println(Math.PI); System.out.println(Math.abs(-10)); //取绝对值 //ceil天花板 /* * 13.0 * 12.3 * 12.0 */ System.out.println(Math.ceil(12.3));//向上取整,但是结果是一个double System.out.println(Math.ceil(12.99)); System.out.println(\"-----------\"); //floor地板 /* * 13.0 * 12.3 * 12.0 */ System.out.println(Math.floor(12.3));//向下取整,但是结果是一个double System.out.println(Math.floor(12.99)); //获取两个值中的最大值 System.out.println(Math.max(20, 30)); //前面的数是底数,后面的数是指数 System.out.println(Math.pow(2, 3)); //2.0 ^ 3.0 //生成0.0到1.0之间的所以小数,包括0.0,不包括1.0 System.out.println(Math.random()); //四舍五入 System.out.println(Math.round(12.3f)); System.out.println(Math.round(12.9f)); //开平方 System.out.println(Math.sqrt(4)); System.out.println(Math.sqrt(2)); System.out.println(Math.sqrt(3)); &#125;&#125; Random类的概述和方法使用 Random类的概述 此类用于产生随机数如果用相同的种子创建两个 Random 实例， 则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列。 构造方法 public Random() public Random(long seed) 成员方法 public int nextInt() public int nextInt(int n)(重点掌握) 生成在0到n范围内的随机数,包含0不包含n 12345678910111213141516171819202122232425262728293031323334package com.wxhao.otherclass;import java.util.Random;public class Demo2_Random &#123; public static void main(String[] args) &#123; Random r = new Random(); /*int x = r.nextInt(); System.out.println(x);*/ for(int i = 0; i &lt; 10; i++) &#123; //System.out.println(r.nextInt()); System.out.println(r.nextInt(100)); //要求掌握,生成在0到n范围内的随机数,包含0不包含n &#125; /* * -1244746321 1060493871 -1244746321 1060493871 */ /*Random r2 = new Random(1001); int a = r2.nextInt(); int b = r2.nextInt(); System.out.println(a); System.out.println(b);*/ &#125;&#125; System类的概述和方法使用 System类的概述 System 类包含一些有用的类字段和方法。它不能被实例化。 成员方法 public static void gc()//清理垃圾 public static void exit(int status)//退出虚拟机,非0表示异常退出JVM public static long currentTimeMillis()//当前时间毫秒值 pubiic static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 案例演示 System类的成员方法使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.wxhao.otherclass;public class Demo3_System &#123; public static void main(String[] args) &#123; //demo1(); //demo2(); //demo3(); int[] src = &#123;11,22,33,44,55&#125;; int[] dest = new int[8]; for (int i = 0; i &lt; dest.length; i++) &#123; System.out.println(dest[i]); &#125; System.out.println(\"--------------------------\"); System.arraycopy(src, 0, dest, 0, src.length);//将数组内容拷贝 for (int i = 0; i &lt; dest.length; i++) &#123; System.out.println(dest[i]); &#125; &#125; public static void demo3() &#123; long start = System.currentTimeMillis();//1秒等于1000毫秒 for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(\"*\"); &#125; long end = System.currentTimeMillis(); //获取当前时间的毫秒值 System.out.println(end - start); &#125; public static void demo2() &#123; System.exit(1); //非0状态是异常终止,退出jvm System.out.println(\"11111111111\"); &#125; public static void demo1() &#123; for(int i = 0; i &lt; 100; i++) &#123; new Demo(); System.gc();//运行垃圾回收器,相当于呼喊保洁阿姨 &#125; &#125;&#125;class Demo &#123; //在一个源文件中不允许定义两个用public修饰的类 @Override public void finalize() &#123; System.out.println(\"垃圾被清扫了\"); &#125; &#125; BigInteger类的概述和方法使用 BigInteger的概述 可以让超过Integer范围内的数据进行运算 构造方法 public BigInteger(String val) 成员方法 public BigInteger add(BigInteger val) public BigInteger subtract(BigInteger val) public BigInteger multiply(BigInteger val) public BigInteger divide(BigInteger val) public BigInteger[] divideAndRemainder(BigInteger val) 12345678910111213141516171819202122232425package com.wxhao.otherclass;import java.math.BigInteger;public class Demo4_BigInteger &#123; public static void main(String[] args) &#123; //long num = 123456789098765432123L; //String s = \"123456789098765432123\"; BigInteger bi1 = new BigInteger(\"100\"); BigInteger bi2 = new BigInteger(\"2\"); System.out.println(bi1.add(bi2)); //+ System.out.println(bi1.subtract(bi2)); //- System.out.println(bi1.multiply(bi2)); //* System.out.println(bi1.divide(bi2)); ///(除) BigInteger[] arr = bi1.divideAndRemainder(bi2); //取除数和余数 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; BigDecimal类的概述和方法使用 BigDecimal的概述 由于在运算的时候，float类型和double很容易丢失精度，演示案例。 所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal 不可变的、任意精度的有符号十进制数。 构造方法 public BigDecimal(String val) 成员方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor) 案例演示 BigDecimal类的构造方法和成员方法使用 12345678910111213141516171819202122232425262728package com.wxhao.otherclass;import java.math.BigDecimal;public class Demo5_BigDecimal &#123; /** 十进制表示1/3 0.3333333333333333333333333333333333333333 */ public static void main(String[] args) &#123; //System.out.println(2.0 - 1.1); /*BigDecimal bd1 = new BigDecimal(2.0); //这种方式在开发中不推荐,因为不够精确 BigDecimal bd2 = new BigDecimal(1.1); System.out.println(bd1.subtract(bd2));*/ /*BigDecimal bd1 = new BigDecimal(\"2.0\"); //通过构造中传入字符串的方式,开发时推荐 BigDecimal bd2 = new BigDecimal(\"1.1\"); System.out.println(bd1.subtract(bd2));*/ BigDecimal bd1 = BigDecimal.valueOf(2.0); //这种方式在开发中也是推荐的 BigDecimal bd2 = BigDecimal.valueOf(1.1); System.out.println(bd1.subtract(bd2)); &#125;&#125; Date类的概述和方法使用 Date类的概述 类 Date 表示特定的瞬间，精确到毫秒。 构造方法 public Date() public Date(long date) 成员方法 public long getTime() public void setTime(long time) 12345678910111213141516171819202122232425262728package com.wxhao.otherclass;import java.util.Date;public class Demo6_Date &#123; public static void main(String[] args) &#123; //demo1(); //demo2(); Date d1 = new Date(); d1.setTime(1000); //设置毫秒值,改变时间对象 System.out.println(d1); &#125; public static void demo2() &#123; Date d1 = new Date(); System.out.println(d1.getTime());//通过时间对象获取毫秒值 System.out.println(System.currentTimeMillis()); //通过系统类的方法获取当前时间毫秒值 &#125; public static void demo1() &#123; Date d1 = new Date();//如果没有传参数代表的是当前时间 System.out.println(d1); Date d2 = new Date(0);//如果构造方法中参数传为0代表的是1970年1月1日 System.out.println(d2);//通过毫秒值创建时间对象 &#125;&#125; SimpleDateFormat类实现日期和字符串的相互转换 DateFormat类的概述 DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。是抽象类，所以使用其子类SimpleDateFormat SimpleDateFormat构造方法 public SimpleDateFormat() public SimpleDateFormat(String pattern) 成员方法 public final String format(Date date) public Date parse(String source) 123456789101112131415161718192021222324252627282930313233343536373839404142package com.wxhao.otherclass;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo7_SimpleDateFormat &#123; /** * @throws ParseException */ public static void main(String[] args) throws ParseException &#123; //demo1(); //demo2(); //demo3(); //将时间字符串转换成日期对象 String str = \"2000年08月08日 08:08:08\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); Date d = sdf.parse(str); //将时间字符串转换成日期对象 System.out.println(d); &#125; public static void demo3() &#123; Date d = new Date(); //获取当前时间对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");//创建日期格式化类对象 System.out.println(sdf.format(d)); //将日期对象转换为字符串 &#125; public static void demo2() &#123; Date d = new Date(); //获取当前时间对象 SimpleDateFormat sdf = new SimpleDateFormat();//创建日期格式化类对象 System.out.println(sdf.format(d)); //88-6-6 下午9:31 &#125; public static void demo1() &#123; //DateFormat df = new DateFormat(); //DateFormat是抽象类,不允许实例化 //DateFormat df1 = new SimpleDateFormat(); DateFormat df1 = DateFormat.getDateInstance();//相当于父类引用指向子类对象,右边的方法返回一个子类对象 &#125;&#125; 你来到这个世界多少天案例 需求：算一下你来到这个世界多少天? 1234567891011121314151617181920212223242526272829303132package com.wxhao.test;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Test2 &#123; /** * 分析: * 1,将生日字符串和今天字符串存在String类型的变量中 * 2,定义日期格式化对象 * 3,将日期字符串转换成日期对象 * 4,通过日期对象后期时间毫秒值 * 5,将两个时间毫秒值相减除以1000,再除以60,再除以60,再除以24得到天 * @throws ParseException */ public static void main(String[] args) throws ParseException &#123; //1,将生日字符串和今天字符串存在String类型的变量中 String birthday = \"1993年09月11日\"; String today = \"2013年7月30日\"; //2,定义日期格式化对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\"); //3,将日期字符串转换成日期对象 Date d1 = sdf.parse(birthday); Date d2 = sdf.parse(today); //4,通过日期对象后期时间毫秒值 long time = d2.getTime() - d1.getTime(); //5,将两个时间毫秒值相减除以1000,再除以60,再除以60,再除以24得到天 System.out.println(time / 1000 / 60 / 60 / 24 ); &#125;&#125; Calendar类的概述和获取日期的方法 Calendar类的概述 Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 成员方法 public static Calendar getInstance() public int get(int field) 12345678910111213package com.wxhao.otherclass;import java.util.Calendar;public class Demo8_Calendar &#123; public static void main(String[] args) &#123; Calendar c = Calendar.getInstance(); //父类引用指向子类对象 //System.out.println(c); //证明重写了toString方法打印了对象中所有的属性 System.out.println(c.get(Calendar.YEAR)); //通过字段获取对应的值 System.out.println(c.get(Calendar.MONTH)); &#125;&#125; Calendar类的add()和set()方法 成员方法 public void add(int field,int amount) public final void set(int year,int month,int date) 案例演示 Calendar类的成员方法使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.wxhao.otherclass;import java.util.Calendar;public class Demo9_Calendar &#123; /** * * A:Calendar类的概述 * Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 * B:成员方法 * public static Calendar getInstance() * public int get(int field) * C:成员方法 * public void add(int field,int amount) * public final void set(int year,int month,int date) * D:案例演示 * Calendar类的成员方法使用 */ public static void main(String[] args) &#123; //demo1(); Calendar c = Calendar.getInstance(); //父类引用指向子类对象 //c.add(Calendar.MONTH, -1); //对指定的字段进行向前减或向后加 //c.set(Calendar.YEAR, 2000); //修改指定字段 c.set(2000, 7, 8); System.out.println(c.get(Calendar.YEAR) + \"年\" + getNum((c.get(Calendar.MONTH)+1)) + \"月\" + getNum(c.get(Calendar.DAY_OF_MONTH)) + \"日\" + getWeek(c.get(Calendar.DAY_OF_WEEK))); &#125; public static void demo1() &#123; Calendar c = Calendar.getInstance(); //父类引用指向子类对象 //System.out.println(c); System.out.println(c.get(Calendar.YEAR)); //通过字段获取年 System.out.println(c.get(Calendar.MONTH)); //通过字段后期月,但是月是从0开始编号的 System.out.println(c.get(Calendar.DAY_OF_MONTH));//月中的第几天 System.out.println(c.get(Calendar.DAY_OF_WEEK));//周日是第一天,周六是最后一天 System.out.println(c.get(Calendar.YEAR) + \"年\" + getNum((c.get(Calendar.MONTH)+1)) + \"月\" + getNum(c.get(Calendar.DAY_OF_MONTH)) + \"日\" + getWeek(c.get(Calendar.DAY_OF_WEEK))); &#125; /* * 将星期存储表中进行查表 * 1,返回值类型String * 2,参数列表int week */ public static String getWeek(int week) &#123; String[] arr = &#123;\"\",\"星期日\",\"星期一\",\"星期二\",\"星期三\",\"星期四\",\"星期五\",\"星期六\"&#125;; return arr[week]; &#125; /* * 如果是个数数字前面补0 * 1,返回值类型String类型 * 2,参数列表,int num */ public static String getNum(int num) &#123; /*if(num &gt; 9) &#123; return \"\" + num; &#125;else &#123; return \"0\" + num; &#125;*/ return num &gt; 9 ? \"\" + num : \"0\" + num; &#125;&#125; 1970的由来 如何获取任意年份是平年还是闰年 需求：键盘录入任意一个年份，判断该年是闰年还是平年 12345678910111213141516171819202122232425262728293031323334353637package com.wxhao.test;import java.util.Calendar;import java.util.Scanner;public class Test3 &#123; /** * 分析: * 1,键盘录入年Scanner * 2,创建Calendar c = Calendar.getInstance(); * 3,通过set方法设置为那一年的3月1日 * 4,将日向前减去1 * 5,判断日是多少天,如果是29天返回true否则返回false */ public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入年份,判断该年份是闰年还是平年:\"); //int year = sc.nextInt(); String line = sc.nextLine(); //录入数字字符串 int year = Integer.parseInt(line); //将数字字符串转换成数字 boolean b = getYear(year); System.out.println(b); &#125; private static boolean getYear(int year) &#123; //2,创建Calendar c = Calendar.getInstance(); Calendar c = Calendar.getInstance(); //设置为那一年的3月1日 c.set(year, 2, 1); //将日向前减去1 c.add(Calendar.DAY_OF_MONTH, -1); //判断是否是29天 return c.get(Calendar.DAY_OF_MONTH) == 29; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE常见对象 - 正则表达式","date":"2013-08-08T16:00:00.000Z","path":"2013/08/09/2013-08-09-object-class-regex/","text":"JavaSE常见对象 - 正则表达式 正则表达式的概述和简单使用 正则表达式 是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。 作用:比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的 案例演示 需求：校验qq号码. 1:要求必须是5-15位数字 2:0不能开头 3:必须都是数字 非正则表达式实现 正则表达式实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.wxhao.regex;public class Demo1_Regex &#123; public static void main(String[] args) &#123; System.out.println(checkQQ(\"012345\")); System.out.println(checkQQ(\"a1b345\")); System.out.println(checkQQ(\"123456\")); System.out.println(checkQQ(\"1234567890987654321\")); String regex = \"[1-9]\\\\d&#123;4,14&#125;\"; System.out.println(\"2553868\".matches(regex)); System.out.println(\"012345\".matches(regex)); System.out.println(\"2553868abc\".matches(regex)); &#125; /* * 需求：校验qq号码. * 1:要求必须是5-15位数字 * 2:0不能开头 * 3:必须都是数字 * 校验qq * 1,明确返回值类型boolean * 2,明确参数列表String qq */ public static boolean checkQQ(String qq) &#123; boolean flag = true; //如果校验qq不符合要求就把flag置为false,如果符合要求直接返回 if(qq.length() &gt;= 5 &amp;&amp; qq.length() &lt;= 15) &#123; if(!qq.startsWith(\"0\")) &#123; char[] arr = qq.toCharArray(); //将字符串转换成字符数组 for (int i = 0; i &lt; arr.length; i++) &#123; char ch = arr[i]; //记录每一个字符 if(!(ch &gt;= '0' &amp;&amp; ch &lt;= '9')) &#123; flag = false; //不是数字 break; &#125; &#125; &#125;else &#123; flag = false; //以0开头,不符合qq标准 &#125; &#125;else &#123; flag = false; //长度不符合 &#125; return flag; &#125;&#125; 字符类演示 字符类 []单个字符 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） [0-9] 0到9的字符都包括 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.wxhao.regex;public class Demo2_Regex &#123; /** * [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e 或 f（交集） [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去） */ public static void main(String[] args) &#123; //demo1(); //demo2(); //demo3(); //demo4(); //demo5(); //demo6(); String regex = \"[a-z&amp;&amp;[^m-p]]\"; System.out.println(\"m\".matches(regex)); System.out.println(\"a\".matches(regex)); System.out.println(\"z\".matches(regex)); System.out.println(\"n\".matches(regex)); &#125; private static void demo6() &#123; String regex = \"[a-z&amp;&amp;[^bc]]\"; System.out.println(\"a\".matches(regex)); System.out.println(\"b\".matches(regex)); System.out.println(\"1\".matches(regex)); &#125; private static void demo5() &#123; String regex = \"[a-z&amp;&amp;[def]]\"; //取交集 System.out.println(\"a\".matches(regex)); System.out.println(\"d\".matches(regex)); &#125; private static void demo4() &#123; String regex = \"[a-d[m-p]]\"; System.out.println(\"a\".matches(regex)); System.out.println(\"m\".matches(regex)); System.out.println(\"n\".matches(regex)); &#125; private static void demo3() &#123; String regex = \"[a-zA-Z]\"; System.out.println(\"a\".matches(regex)); System.out.println(\"A\".matches(regex)); System.out.println(\"z\".matches(regex)); System.out.println(\"Z\".matches(regex)); System.out.println(\"1\".matches(regex)); System.out.println(\"%\".matches(regex)); &#125; private static void demo2() &#123; String regex = \"[^abc]\"; System.out.println(\"a\".matches(regex)); System.out.println(\"b\".matches(regex)); System.out.println(\"c\".matches(regex)); System.out.println(\"d\".matches(regex)); System.out.println(\"1\".matches(regex)); System.out.println(\"%\".matches(regex)); System.out.println(\"10\".matches(regex)); //10代表1字符和0字符,不是单个字符 &#125; private static void demo1() &#123; String regex = \"[abc]\"; //[]代表单个字符 System.out.println(\"a\".matches(regex)); System.out.println(\"b\".matches(regex)); System.out.println(\"c\".matches(regex)); System.out.println(\"d\".matches(regex)); System.out.println(\"1\".matches(regex)); System.out.println(\"%\".matches(regex)); &#125;&#125; 预定义字符类演示 预定义字符类 . 任何字符。 \\d 数字：[0-9] \\w 单词字符：[a-zA-Z_0-9] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.wxhao.regex;public class Demo3_Regex &#123; /** * . 任何字符 \\d 数字：[0-9] \\D 非数字： [^0-9] \\s 空白字符：[ \\t\\n\\x0B\\f\\r] \\S 非空白字符：[^\\s] \\w 单词字符：[a-zA-Z_0-9] \\W 非单词字符：[^\\w] */ public static void main(String[] args) &#123; //demo1(); //demo2(); //demo3(); //demo4(); //demo5(); //demo6(); String regex = \"\\\\W\"; System.out.println(\"a\".matches(regex)); System.out.println(\"z\".matches(regex)); System.out.println(\"_\".matches(regex)); System.out.println(\"%\".matches(regex)); &#125; private static void demo6() &#123; String regex = \"\\\\w\"; System.out.println(\"a\".matches(regex)); System.out.println(\"z\".matches(regex)); System.out.println(\"_\".matches(regex)); System.out.println(\"%\".matches(regex)); &#125; private static void demo5() &#123; String regex = \"\\\\S\"; System.out.println(\" \".matches(regex)); System.out.println(\" \".matches(regex)); System.out.println(\"a\".matches(regex)); &#125; private static void demo4() &#123; String regex = \"\\\\s\"; System.out.println(\" \".matches(regex)); System.out.println(\" \".matches(regex)); //一个tab键 System.out.println(\" \".matches(regex)); //四个空格 &#125; private static void demo3() &#123; String regex = \"\\\\D\"; System.out.println(\"0\".matches(regex)); System.out.println(\"9\".matches(regex)); System.out.println(\"a\".matches(regex)); &#125; private static void demo2() &#123; String regex = \"\\\\d\"; //\\代表转义字符,如果想表示\\d的话,需要\\\\d System.out.println(\"0\".matches(regex)); System.out.println(\"a\".matches(regex)); System.out.println(\"9\".matches(regex)); &#125; private static void demo1() &#123; String regex = \"..\"; System.out.println(\"a\".matches(regex)); System.out.println(\"ab\".matches(regex)); &#125;&#125; 数量词 Greedy 数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.wxhao.regex;public class Demo4_Regex &#123; /** * Greedy 数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X&#123;n&#125; X，恰好 n 次 X&#123;n,&#125; X，至少 n 次 X&#123;n,m&#125; X，至少 n 次，但是不超过 m 次 */ public static void main(String[] args) &#123; //demo1(); //demo2(); //demo3(); //demo4(); //demo5(); String regex = \"[abc]&#123;5,15&#125;\"; System.out.println(\"abcba\".matches(regex)); System.out.println(\"abcbaabcabbabab\".matches(regex)); System.out.println(\"abcb\".matches(regex)); System.out.println(\"abcbaabaabcbaaba\".matches(regex)); &#125; public static void demo5() &#123; String regex = \"[abc]&#123;5,&#125;\"; System.out.println(\"abcba\".matches(regex)); System.out.println(\"abcbaabcabbabab\".matches(regex)); System.out.println(\"abcb\".matches(regex)); System.out.println(\"abcbaaba\".matches(regex)); &#125; public static void demo4() &#123; String regex = \"[abc]&#123;5&#125;\"; System.out.println(\"abcba\".matches(regex)); System.out.println(\"abcbaabcabbabab\".matches(regex)); System.out.println(\"abcb\".matches(regex)); System.out.println(\"abcbaaba\".matches(regex)); &#125; public static void demo3() &#123; String regex = \"[abc]+\"; System.out.println(\"\".matches(regex)); System.out.println(\"a\".matches(regex)); System.out.println(\"aaaaabbbbccccc\".matches(regex)); &#125; public static void demo2() &#123; String regex = \"[abc]*\"; System.out.println(\"\".matches(regex)); System.out.println(\"abc\".matches(regex)); System.out.println(\"a\".matches(regex)); &#125; public static void demo1() &#123; String regex = \"[abc]?\"; System.out.println(\"a\".matches(regex)); System.out.println(\"b\".matches(regex)); System.out.println(\"c\".matches(regex)); System.out.println(\"d\".matches(regex)); System.out.println(\"\".matches(regex)); &#125;&#125; 正则表达式的分割功能 正则表达式的分割功能 String类的功能：public String[] split(String regex) 案例演示 正则表达式的分割功能 123456789101112131415package com.wxhao.regex;public class Demo5_Split &#123; public static void main(String[] args) &#123; String s = \"金三胖.郭美美.李dayone\"; String[] arr = s.split(\"\\\\.\"); //通过正则表达式切割字符串 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; System.out.println(\"11111111111111111\"); &#125;&#125; 把给定字符串中的数字排序 案例演示 需求：我有如下一个字符串:”91 27 46 38 50”，请写代码实现最终输出结果是：”27 38 46 50 91” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.wxhao.test;import java.util.Arrays;public class Test1 &#123; /** * 分析: * 1,将字符串切割成字符串数组 * 2,将字符串转换成数字并将其存储在一个等长度的int数组中 * 3,排序 * 4,将排序后的结果遍历并拼接成一个字符串 */ public static void main(String[] args) &#123; String s = \"91 27 46 38 50\"; //1,将字符串切割成字符串数组 String[] sArr = s.split(\" \"); //2,将字符串转换成数字并将其存储在一个等长度的int数组中 int[] arr = new int[sArr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(sArr[i]); //将数字字符串转换成数字 &#125; //3,排序 Arrays.sort(arr); //4,将排序后的结果遍历并拼接成一个字符串27 38 46 50 91 /*String str = \"\"; for (int i = 0; i &lt; arr.length; i++) &#123; if(i == arr.length - 1) &#123; str = str + arr[i]; //27 38 46 50 91 &#125;else &#123; str = str + arr[i] + \" \"; //27 38 46 50 &#125; &#125; System.out.println(str);*/ StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; if(i == arr.length - 1) &#123; sb.append(arr[i]); &#125;else &#123; sb.append(arr[i] + \" \"); &#125; &#125; System.out.println(sb); &#125;&#125; 正则表达式的替换功能 正则表达式的替换功能 String类的功能：public String replaceAll(String regex,String replacement) 正则表达式的替换功能 12345678910111213141516package com.wxhao.regex;public class Demo6_ReplaceAll &#123; /** * * A:正则表达式的替换功能 * String类的功能：public String replaceAll(String regex,String replacement) */ public static void main(String[] args) &#123; String s = \"wo111ai222wxhao\"; String regex = \"\\\\d\"; //\\\\d代表的是任意数字 String s2 = s.replaceAll(regex, \"\"); System.out.println(s2); &#125;&#125; 正则表达式的分组功能 正则表达式的分组功能 捕获组可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C))) 中，存在四个这样的组： 1234567891011121 ((A)(B(C))) 2 (A 3 (B(C)) 4 (C) 组零始终代表整个表达式。案例演示切割 需求：请按照叠词切割： &quot;sdqqfgkkkhjppppkl&quot;;替换 需求：我我....我...我.要...要要...要学....学学..学.编..编编.编.程.程.程..程 将字符串还原成:“我要学编程”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.wxhao.regex;public class Demo7_Regex &#123; public static void main(String[] args) &#123; //demo1(); //demo2(); /* * 需求：我我....我...我.要...要要...要学....学学..学.编..编编.编.程.程.程..程 将字符串还原成:“我要学编程”。 */ String s = \"我我....我...我.要...要要...要学....学学..学.编..编编.编.程.程.程..程\"; String s2 = s.replaceAll(\"\\\\.+\", \"\"); String s3 = s2.replaceAll(\"(.)\\\\1+\", \"$1\"); //$1代表第一组中的内容 System.out.println(s3); &#125; public static void demo2() &#123; //需求：请按照叠词切割： \"sdqqfgkkkhjppppkl\"; String s = \"sdqqfgkkkhjppppkl\"; String regex = \"(.)\\\\1+\"; //+代表第一组出现一次到多次 String[] arr = s.split(regex); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; public static void demo1() &#123; //叠词 快快乐乐,高高兴兴 /*String regex = \"(.)\\\\1(.)\\\\2\"; //\\\\1代表第一组又出现一次 \\\\2代表第二组又出现一次 System.out.println(\"快快乐乐\".matches(regex)); System.out.println(\"快乐乐乐\".matches(regex)); System.out.println(\"高高兴兴\".matches(regex)); System.out.println(\"死啦死啦\".matches(regex));*/ //叠词 死啦死啦,高兴高兴 String regex2 = \"(..)\\\\1\"; System.out.println(\"死啦死啦\".matches(regex2)); System.out.println(\"高兴高兴\".matches(regex2)); System.out.println(\"快快乐乐\".matches(regex2)); &#125;&#125; Pattern和Matcher的概述 Pattern和Matcher的概述 模式和匹配器的典型调用顺序 通过JDK提供的API，查看Pattern类的说明 典型的调用顺序是 Pattern p = Pattern.compile(“a*b”); Matcher m = p.matcher(“aaaaab”); boolean b = m.matches(); 正则表达式的获取功能 正则表达式的获取功能 Pattern和Matcher的结合使用 案例演示 需求：把一个字符串中的手机号码获取出来 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.wxhao.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Demo8_Pattern &#123; /** * Pattern p = Pattern.compile(\"a*b\"); Matcher m = p.matcher(\"aaaaab\"); boolean b = m.matches(); */ public static void main(String[] args) &#123; //demo1(); String s = \"我的手机是18988888888,我曾用过18987654321,还用过18812345678\"; String regex = \"1[3578]\\\\d&#123;9&#125;\"; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(s); /*boolean b1 = m.find(); System.out.println(b1); System.out.println(m.group()); boolean b2 = m.find(); System.out.println(b2); System.out.println(m.group());*/ while(m.find()) System.out.println(m.group()); &#125; public static void demo1() &#123; Pattern p = Pattern.compile(\"a*b\"); //获取到正则表达式 Matcher m = p.matcher(\"aaaaab\"); //获取匹配器 boolean b = m.matches(); //看是否能匹配,匹配就返回true System.out.println(b); System.out.println(\"aaaaab\".matches(\"a*b\")); //与上面的结果一样 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.wxhao.util;public class RegexUtil &#123; /** * 条件字符 * a-z A-Z 0-9 * * * 预定义字符 * . 任何字符 * \\d 数字：[0-9] * \\D 数字：[0-9] * \\s 空白字符: [ \\t\\n\\x0B\\f\\r] * \\S 非空白字符: [^\\s] * \\w 单词字符：[a-zA-Z_0-9] * \\W 非单词字符：[^\\w] * * 逻辑字符 * [] &amp;&amp; || ^ */ /** * 数量词 跟在 条件字符后面 条件字符 ? 一次或一次也没有 如:[abc]? 条件字符 * 零次或多次 条件字符 + 一次或多次 条件字符 &#123;n&#125; 恰好 n 次 条件字符 &#123;n,&#125; 至少 n 次 条件字符 &#123;n,m&#125; 至少 n 次，但是不超过 m 次 */ /**分组 * (.)\\\\1(.)\\\\2 xxyy * (.)\\\\1+ .出现一次以上 1代表再来一次 +代表出现一次或多次 * (..)\\\\1 xyxy * * $1 第一组的东西 * $2 第二组的东西 */ /** * 纯数字 */ public static final String PURE_NUMBER=\"[1-9]\"; /** * 纯字母 */ public static final String PURE_LETTER=\"[a-z]\"; public static boolean check(String str , String regex)&#123; boolean flag=true; if(str!=null&amp;&amp;!str.isEmpty())&#123; return str.matches(regex); &#125; return flag; &#125; public static void main(String[] args) &#123; String xx=\"oxs\"; System.out.println(xx.matches(\"\")); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE常见对象 - 基本包装类","date":"2013-08-04T16:00:00.000Z","path":"2013/08/05/2013-08-05-object-class-basic-package/","text":"JavaSE常见对象 - 基本包装类 Integer类的概述和构造方法 Integer类概述 通过JDK提供的API，查看Integer类的说明 Integer 类在对象中包装了一个基本类型 int 的值, 该类提供了多个方法，能在 int 类型和 String 类型之间互相转换， 还提供了处理 int 类型时非常有用的其他一些常量和方法 构造方法 public Integer(int value) public Integer(String s) 使用构造方法创建对象 123456789101112131415161718package com.wxhao.wrapclass;public class Demo2_Integer &#123; public static void main(String[] args) &#123; System.out.println(Integer.MAX_VALUE); System.out.println(Integer.MIN_VALUE); Integer i1 = new Integer(100); System.out.println(i1); //Integer i2 = new Integer(\"abc\");//java.lang.NumberFormatException数字格式异常 //System.out.println(i2); //因为abc不是数字字符串,所以转换会报错 Integer i3 = new Integer(\"100\"); System.out.println(i3); &#125;&#125; String和int类型的相互转换 int – String 和””进行拼接 public static String valueOf(int i) int – Integer – String(Integer类的toString方法()) public static String toString(int i)(Integer类的静态方法) String – int String – Integer – int public static int parseInt(String s) 123456789101112131415161718192021222324252627282930313233343536373839package com.wxhao.wrapclass;public class Demo3_Integer &#123; /** 基本数据类型包装类有八种,其中七种都有parseXxx的方法,可以将这七种的字符串表现形式转换成基本数据类型 */ public static void main(String[] args) &#123; //demo1(); String s1 = \"true\"; boolean b = Boolean.parseBoolean(s1); System.out.println(b); //String s2 = \"abc\"; //char c = Character.p //char的包装类Character中没有pareseXxx的方法 //字符串到字符的转换通过toCharArray()就可以把字符串转换为字符数组 &#125; private static void demo1() &#123; //int ----&gt; String int转换成String int i = 100; String s1 = i + \"\"; //推荐用 String s2 = String.valueOf(i);//推荐用 Integer i2 = new Integer(i); String s3 = i2.toString(); String s4 = Integer.toString(i); System.out.println(s1); //String----&gt; int String 转换int String s = \"200\"; Integer i3 = new Integer(s); int i4 = i3.intValue(); //将Integer转换成了int数 int i5 = Integer.parseInt(s);//将String转换为int,推荐用这种 &#125;&#125; JDK5的新特性自动装箱和拆箱 JDK5的新特性 自动装箱：把基本类型转换为包装类类型 自动拆箱：把包装类类型转换为基本类型 JDK5的新特性自动装箱和拆箱 Integer ii = 100; ii += 200; 注意事项 在使用时，Integer x = null;代码就会出现NullPointerException。 建议先判断是否为null，然后再使用。 123456789101112131415161718package com.wxhao.wrapclass;public class Demo4_JDK5 &#123; public static void main(String[] args) &#123;// int x = 100;// Integer i1 = new Integer(x);//将基本数据类型包装成对象,手动装箱// // int y = i1.intValue(); //将对象转换为基本数据类型,手动拆箱 Integer i2 = 100; //自动装箱,把基本数据类型转换成对象 int z = i2 + 200; //自动拆箱,把对象转换为基本数据类型 System.out.println(z); Integer i3 = null; int a = i3 + 100; //底层用i3调用intValue,但是i3是null,null调用方法就会出现 System.out.println(a); //空指针异常java.lang.NullPointerException &#125;&#125; Integer的练习看程序写结果 12345678910111213141516171819202122Integer i1 = new Integer(97);Integer i2 = new Integer(97);System.out.println(i1 == i2);System.out.println(i1.equals(i2));System.out.println(\"-----------\");Integer i3 = new Integer(197);Integer i4 = new Integer(197);System.out.println(i3 == i4);System.out.println(i3.equals(i4));System.out.println(\"-----------\");Integer i5 = 97;Integer i6 = 97;System.out.println(i5 == i6);System.out.println(i5.equals(i6));System.out.println(\"-----------\");Integer i7 = 197;Integer i8 = 197;System.out.println(i7 == i8);System.out.println(i7.equals(i8)); 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.wxhao.wrapclass;public class Demo5_Integer &#123; /** * @param args */ public static void main(String[] args) &#123; Integer i1 = new Integer(97); Integer i2 = new Integer(97); System.out.println(i1 == i2); //false System.out.println(i1.equals(i2));//true System.out.println(\"-----------\"); Integer i3 = new Integer(197); Integer i4 = new Integer(197); System.out.println(i3 == i4); //false System.out.println(i3.equals(i4)); //true System.out.println(\"-----------\"); Integer i5 = 127; Integer i6 = 127; System.out.println(i5 == i6); //true System.out.println(i5.equals(i6));//true System.out.println(\"-----------\"); Integer i7 = 128; Integer i8 = 128; System.out.println(i7 == i8); System.out.println(i7.equals(i8));//true /* * -128到127是byte的取值范围,如果在这个取值范围内,自动装箱就不会新创建对象,而是从常量池中获取 * 如果超过了byte取值范围就会再新创建对象 * * public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) //i&gt;= -128 &amp;&amp; i &lt;= 127 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; */ &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE常见对象 - 数组基本原理","date":"2013-08-02T16:00:00.000Z","path":"2013/08/03/2013-08-03-object-class-array/","text":"JavaSE常见对象 - 数组基本原理 数组排序数组高级冒泡排序原理图解 画图演示 需求：12345数组元素：&#123;24, 69, 80, 57, 13&#125;请对数组元素进行排序。冒泡排序相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处 代码实现 数组高级冒泡排序代码 数组高级选择排序原理图解 需求： 数组元素：{24, 69, 80, 57, 13} 请对数组元素进行排序。 选择排序 从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处 代码实现 数组高级选择排序代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.wxhao.array;public class Demo1_Array &#123; public static void main(String[] args) &#123; int[] arr = &#123;24, 69, 80, 57, 13&#125;; bubbleSort(arr); //selectSort(arr); print(arr); &#125; /* * 冒泡排序 * 1,返回值类型,void * 2,参数列表,int[] arr * * 第一次:arr[0]与arr[1],arr[1]与arr[2],arr[2]与arr[3],arr[3]与arr[4]比较4次 第二次:arr[0]与arr[1],arr[1]与arr[2],arr[2]与arr[3]比较3次 第三次:arr[0]与arr[1],arr[1]与arr[2]比较2次 第四次:arr[0]与arr[1]比较1次 */ public static void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; //外循环只需要比较arr.length-1次就可以了 for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; //-1为了防止索引越界,-i为了提高效率 if(arr[j] &gt; arr[j+1]) &#123; /*int temp = arr[j]; arr[j] = arr[j + 1]; arr[j+1] = temp;*/ swap(arr,j,j+1); &#125; &#125; &#125; &#125; /* * 打印数组 * 1,返回值类型void * 2,参数列表int[]arr */ public static void print(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; &#125; /* * 选择排序 * 1,返回值类型void * 2,参数列表int[] arr * * 第一次:arr[0]分别与arr[1-4]比较,比较4次 第二次:arr[1]分别与arr[2-4]比较,比较3次 第三次:arr[2]分别与arr[3-4]比较,比较2次 第四次:arr[3]与arr[4]比较,比较1次 */ public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; //只需要比较arr.length-1次 for (int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[i] &gt; arr[j]) &#123; /*int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;*/ swap(arr,i,j); &#125; &#125; &#125; &#125; /* * 换位操作 * 1,返回值类型,void * 2,参数列表int[] arr.int i,int j * * 如果某个方法,只针对本类使用,不想让其他类使用就可以定义成私有的 */ private static void swap(int[] arr,int i,int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 数组高级二分查找原理图解 画图演示 二分查找 前提：数组元素有序 数组高级二分查找代码实现及注意事项 案例演示 数组高级二分查找代码 注意事项 如果数组无序，就不能使用二分查找。 因为如果你排序了，但是你排序的时候已经改变了我最原始的元素索引。 1234567891011121314151617181920212223242526272829303132333435363738package com.wxhao.array;public class Demo2_Array &#123; public static void main(String[] args) &#123; int[] arr = &#123;11,22,33,44,55,66,77&#125;; System.out.println(getIndex(arr, 22)); System.out.println(getIndex(arr, 66)); System.out.println(getIndex(arr, 88)); &#125; /* * 二分查找 * 1,返回值类型,int * 2,参数列表int[] arr,int value */ public static int getIndex(int[] arr, int value) &#123; int min = 0; int max = arr.length - 1; int mid = (min + max) / 2; while(arr[mid] != value) &#123; //当中间值不等于要找的值,就开始循环查找 if(arr[mid] &lt; value) &#123; //当中间值小于了要找的值 min = mid + 1; //最小的索引改变 &#125;else if (arr[mid] &gt; value)&#123; //当中间值大于了要找的值 max = mid - 1; //最大的索引改变 &#125; mid = (min + max) / 2; //无论最大还是最小改变,中间索引都会随之改变 if(min &gt; max) &#123; //如果最小索引大于了最大索引,就没有查找的可能性了 return -1; //返回-1 &#125; &#125; return mid; &#125;&#125; Arrays类的概述和方法使用 Arrays类概述 针对数组进行操作的工具类。 提供了排序，查找等功能。 成员方法 public static String toString(int[] a) public static void sort(int[] a) public static int binarySearch(int[] a,int key) 基本类型包装类的概述 为什么会有基本类型包装类 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。 常用操作 常用的操作之一：用于基本数据类型与字符串之间的转换。 基本类型和包装类的对应 基本数据类型 - 包装类 byte - Byte short- Short int- Integer long-Long float-Float double-Double char-Character boolean-Boolean 12345678910package com.wxhao.wrapclass;public class Demo1_Integer &#123; public static void main(String[] args) &#123; System.out.println(Integer.toBinaryString(60));//2进制 System.out.println(Integer.toOctalString(60));//8进制 System.out.println(Integer.toHexString(60));//16进制 &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE常见对象 - StringBuffer类与StringBuilder类","date":"2013-07-31T16:00:00.000Z","path":"2013/08/01/2013-08-01-object-class-stringbuffer/","text":"JavaSE常见对象 - StringBuffer类与StringBuilder类 StringBuffer类的概述 StringBuffer类概述 通过JDK提供的API，查看StringBuffer类的说明 线程安全的可变字符序列 StringBuffer和String的区别 String是一个不可变的字符序列 StringBuffer是一个可变的字符序列 StringBuffer类的构造方法 StringBuffer的构造方法： public StringBuffer():无参构造方法 public StringBuffer(int capacity):指定容量的字符串缓冲区对象 public StringBuffer(String str):指定字符串内容的字符串缓冲区对象 StringBuffer的方法： public int capacity()：返回当前容量。 理论值(不掌握) public int length():返回长度（字符数）。 实际值 构造方法和长度方法的使用 12345678910111213141516171819package com.wxhao.stringbuffer;public class Demo1_StringBuffer &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(); System.out.println(sb.length()); //容器中的字符个数,实际值 System.out.println(sb.capacity()); //容器的初始容量,理论值 StringBuffer sb2 = new StringBuffer(10); System.out.println(sb2.length()); System.out.println(sb2.capacity()); StringBuffer sb3 = new StringBuffer(\"heima\"); System.out.println(sb3.length()); //实际字符的个数 System.out.println(sb3.capacity()); //字符串的length + 初始容量 &#125;&#125; StringBuffer的添加功能 StringBuffer的添加功能 public StringBuffer append(String str): 可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身 public StringBuffer insert(int offset,String str): 在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身 12345678910111213141516171819202122232425262728package com.wxhao.stringbuffer;public class Demo2_StringBuffer &#123; /* StringBuffer是字符串缓冲区,当new的时候是在堆内存创建了一个对象,底层是一个长度为16的字符数组 当调用添加的方法时,不会再重新创建对象,在不断向原缓冲区添加字符 */ public static void main(String[] args) &#123; //demo1(); StringBuffer sb = new StringBuffer(\"1234\"); sb.insert(3, \"wxhao\");//在指定位置添加元素,如果没有指定位置的索引就会报索引越界异常 System.out.println(sb); &#125; private static void demo1() &#123; StringBuffer sb = new StringBuffer(); StringBuffer sb2 = sb.append(true); StringBuffer sb3 = sb.append(\"wxhao\"); StringBuffer sb4 = sb.append(100); System.out.println(sb.toString());//StringBuffer类中重写了toString方法,显示的是对象中的属性值 System.out.println(sb2.toString()); System.out.println(sb3.toString()); System.out.println(sb4.toString()); &#125;&#125; StringBuffer是字符串缓冲区,当new的时候是在堆内存创建了一个对象,底层是一个长度为16的字符数组 当调用添加的方法时,不会再重新创建对象,在不断向原缓冲区添加字符 StringBuffer的删除功能 StringBuffer的删除功能 public StringBuffer deleteCharAt(int index): 删除指定位置的字符，并返回本身 public StringBuffer delete(int start,int end): 删除从指定位置开始指定位置结束的内容，并返回本身 12345678910111213141516171819package com.wxhao.stringbuffer;public class Demo3_StringBuffer &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(); //sb.deleteCharAt(5);//当缓冲区中这个索引上没有元素的时候就会报StringIndexOutOfBoundsException sb.append(\"wxhao\"); //sb.deleteCharAt(4);//根据索引删除掉索引位置上对应的字符 //sb.delete(0, 2); //删除的时候是包含头,不包含尾 //System.out.println(sb); //sb.delete(0, sb.length());//清空缓冲区 //System.out.println(sb); sb = new StringBuffer();//不要用这种方式清空缓冲区,原来的会变成垃圾,浪费内存 System.out.println(sb); &#125;&#125; StringBuffer的替换和反转功能 StringBuffer的替换功能 public StringBuffer replace(int start,int end,String str): 从start开始到end用str替换 StringBuffer的反转功能 public StringBuffer reverse(): 字符串反转 12345678910111213package com.wxhao.stringbuffer;public class Demo4_StringBufferMethod &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(\"我爱总复习\"); //sb.replace(0, 3, \"bai\"); //替换 //System.out.println(sb); sb.reverse(); System.out.println(sb); &#125;&#125; StringBuffer的截取功能及注意事项 StringBuffer的截取功能 public String substring(int start): 从指定位置截取到末尾 public String substring(int start,int end): 截取从指定位置开始到结束位置，包括开始位置，不包括结束位置 注意事项 注意:返回值类型不再是StringBuffer本身 123456789101112131415package com.wxhao.stringbuffer;public class Demo5_StringBufferMethod &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(\"woaiwxhao\"); //String str = sb.substring(4); //System.out.println(str);//wxhao //System.out.println(sb);//woaiwxhao String str3 = sb.substring(4, 7); System.out.println(str3); &#125;&#125; StringBuffer和String的相互转换 String – StringBuffer a:通过构造方法 b:通过append()方法 StringBuffer – String 通过构造方法 通过toString()方法 通过subString(0,length); 123456789101112131415161718192021222324252627package com.wxhao.stringbuffer;public class Demo6_StringBuffer &#123; public static void main(String[] args) &#123; //demo1(); StringBuffer sb = new StringBuffer(\"wxhao\"); String s1 = new String(sb);//通过构造将StringBuffer转换为String System.out.println(s1); String s2 = sb.toString();//通过toString方法将StringBuffer转换为String System.out.println(s2); String s3 = sb.substring(0, sb.length());//通过截取子字符串将StringBuffer转换为String System.out.println(s3); &#125; private static void demo1() &#123; StringBuffer sb1 = new StringBuffer(\"wxhao\");//通过构造方法将字符串转换为StringBuffer对象 System.out.println(sb1); StringBuffer sb2 = new StringBuffer(); sb2.append(\"wxhao\"); //通过append方法将字符串转换为StringBuffer对象 System.out.println(sb2); &#125;&#125; 把数组转成字符串 需求：把数组中的数据按照指定个格式拼接成一个字符串 12345举例：int[] arr = &#123;1,2,3&#125;; 输出结果：&quot;[1, 2, 3]&quot;用StringBuffer的功能实现 123456789101112131415161718192021222324252627282930313233343536package com.wxhao.test;public class Test1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; System.out.println(arrayToString(arr)); &#125; /* * 将数组转换为字符串 * 1,返回值类型String * 2,参数列表int[] * * arrayToString 将数组转换为字符串 * array2String 2与to的发音一样就用2替换了to,后来演变成了一种书写习惯 * dom4j domForJ */ public static String arrayToString(int[] arr) &#123; StringBuffer sb = new StringBuffer();//创建字符串缓冲区对象 sb.append(\"[\"); //将[添加到缓冲区 //&#123;1,2,3&#125; for (int i = 0; i &lt; arr.length; i++) &#123;//遍历数组 //sb.append(arr[i] + \", \");//这样做没有] if(i == arr.length - 1) &#123; sb.append(arr[i]).append(\"]\");//[1, 2, 3] &#125;else &#123; sb.append(arr[i]).append(\", \");//[1, 2, &#125; &#125; return sb.toString(); &#125;&#125; 字符串反转 需求：把字符串反转举例：键盘录入”abc”输出结果：”cba” 用StringBuffer的功能实现 12345678910111213141516171819202122232425262728293031package com.wxhao.test;import java.util.Scanner;public class Test2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in);//创建键盘录入对象 String line = sc.nextLine();//将键盘录入的字符串存储在line中 /*StringBuffer sb = new StringBuffer(line); //将字符串转换为StringBuffer对象 sb.reverse(); //将缓冲区的内容反转 System.out.println(sb.toString());*/ System.out.println(revString(line)); &#125; /* * 将字符串反转 * 1,返回值类型String * 2,参数列表String line */ public static String revString(String line) &#123; StringBuffer sb = new StringBuffer(line);//将字符串转换为StringBuffer对象 sb.reverse(); //将缓冲区的内容反转 return sb.toString(); &#125;&#125; StringBuffer和StringBuilder的区别 StringBuilder的概述 通过查看API了解一下StringBuilder类 一些问题 String,StringBuffer,StringBuilder的区别 StringBuffer和StringBuilder的区别 StringBuffer是jdk1.0版本的,是线程安全的,效率低 StringBuilder是jdk1.5版本的,是线程不安全的,效率高 String和StringBuffer,StringBuilder的区别 String是一个不可变的字符序列 StringBuffer,StringBuilder是可变的字符序列 String和StringBuffer分别作为参数传递 形式参数问题 String作为参数传递 StringBuffer作为参数传递 案例演示 String和StringBuffer分别作为参数传递问题 123456789101112131415161718192021222324252627282930313233package com.wxhao.stringbuffer;public class Demo7_StringBuffer &#123; /** 基本数据类型的值传递,不改变其值 引用数据类型的值传递,改变其值 String类虽然是引用数据类型,但是他当作参数传递时和基本数据类型是一样的 */ public static void main(String[] args) &#123; String s = \"wxhao\"; System.out.println(s); change(s); System.out.println(s); System.out.println(\"---------------------\"); StringBuffer sb = new StringBuffer(); sb.append(\"wxhao\"); System.out.println(sb); change(sb); System.out.println(sb); &#125; public static void change(StringBuffer sb) &#123; sb.append(\"itcast\"); &#125; public static void change(String s) &#123; s += \"itcast\"; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"},{"name":"基础知识","slug":"基础知识","permalink":"http://wxhaor.me/tags/基础知识/"}]},{"title":"JavaSE之常见对象 - String类","date":"2013-07-29T16:00:00.000Z","path":"2013/07/30/2013-07-30-object-class-string/","text":"JavaSE之常见对象 - String类 String类的概述 String类的概述 通过JDK提供的API,查看String类的说明 可以看到这样两句话 字符串字面值”abc”也可以看成一个字符串对象 字符串是常量,一旦被赋值,就不能被改变 1234567891011package com.wxhao.string;public class Demo1_String &#123; public static void main(String[] args) &#123; String str = \"abc\"; //\"abc\"可以看诚意个字符串对象 str = \"def\"; //当把\"def\"复制给str,原来的\"abc\"就变成了垃圾 System.out.println(str);//String类重写toString房里返回的是该对象本身 &#125;&#125; String类的构造方法 常见构造方法 public String();空构造 public String(byte[] bytes);把字节数组转成字符串 public String(byte[] bytes,int index,int length);把字节数组转成一部分字符串 public String(char[] value);把字符数组转成字符串 public String(char[] value,int index,int count);把字符数组转成一部分字符串 public String(String original);把字符串常量值转成字符串 12345678910111213141516171819202122232425262728package com.wxhao.string;public class Demo2_String &#123; public static void main(String[] args) &#123; String s = new String(); System.out.println(s);//空白 byte[] arr1 = &#123;97, 98 ,99&#125;; String s1 = new String(arr1);//解码,奖计算机读得懂得转成我们读得懂得 System.out.println(s1);//默认项目解码(GBK), byte[] arr2 = &#123;97, 98 ,99,100,101,102&#125;; String s2 = new String(arr2,2,3); System.out.println(s2); char[] arr3 = &#123;'a','b','c','d','e'&#125;; String s3 = new String(arr3); System.out.println(s3); String s4 = new String(arr2,2,3); System.out.println(s4); String s5=new String (\"wxhao\"); System.out.println(s5); &#125;&#125; String类的常见面试题 判断定义为String类型的s1和s2是否相等 1234String s1 = &quot; abc&quot;;String s2 = &quot; abc&quot;;System.out.println(s1==s2);//trueSystem.out.println(s1.equals(s2));//true 下面这句话在内存中传建几个对象 1String s1 = new String(&quot;abc&quot;); 判断定义为String类型的s1和s2是否相等 1234String s1 = new String(&quot;abc&quot;);String s2 = &quot;abc&quot;;System.out.println(s1==s2);System.out.println(s1.equals(s2)); 判断定义为String类型的s1和s2是否相等 1234String s1 = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;;String s2 = &quot; abc&quot;;System.out.println(s1==s2);System.out.println(s1.equals(s2)); 判断定义为String类型的s1和s2是否相等 12345String s1 = &quot;ab&quot;;String s2 = &quot;abc&quot;;String s3 = s1+&quot;c&quot;;System.out.println(s3==s2);System.out.println(s3.equals(s2)); 1234567891011121314151617181920212223242526272829303132333435363738394041package com.wxhao.string;public class Demo3_String &#123; public static void main(String[] args) &#123; //demo1(); //demo2(); //demo3(); //demo4(); String s1 = \"ab\"; String s2 = \"abc\"; String s3 = s1+\"c\"; System.out.println(s3==s2);//false System.out.println(s3.equals(s2));//true &#125; private static void demo4() &#123; String s1 = \"a\"+\"b\"+\"c\";//常量优化 String s2 = \"abc\"; System.out.println(s1==s2);//true System.out.println(s1.equals(s2));//true &#125; private static void demo3() &#123; String s1 = new String(\"abc\"); String s2 = \"abc\"; System.out.println(s1==s2);//false System.out.println(s1.equals(s2));//true &#125; private static void demo2() &#123; // 创建了两个对象,一个在常量池中,一个在堆内存中 String s1 = new String(\"abc\"); &#125; private static void demo1() &#123; String s1 = \" abc\"; String s2 = \" abc\"; System.out.println(s1 == s2); System.out.println(s1.equals(s2)); &#125;&#125; String类的判断功能 boolean equals(Object obj);比较字符串的内容是否相容,区分大小写 boolean equalsIngnoreCase(String str);比较字符串的内容是否相容,忽略大小写 boolean contains(String str);判断大字符串中是否包含小字符串 boolean startsWith(String str);判断字符串是否以某个指定的字符串开头 boolean endsWith(String str);判断字符串是否以某个指定的字符串结尾 boolean isEmpty(String str);判断字符串是否为空 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.wxhao.string;public class Demo4_String &#123; public static void main(String[] args) &#123;// demo1();// demo2(); String s1 = \"wxhao\"; String s2 = \"\"; String s3 = null; System.out.println(s1.isEmpty()); System.out.println(s2.isEmpty()); //System.out.println(s3.isEmpty());//空对象,并不是空字符串 &#125; private static void demo2() &#123; String s1 = \"我是wxhao,嘿嘿\"; String s2 = \"wxhao\"; String s3 = \"sb\"; String s4 = \"我是\"; String s5 = \"嘿嘿\"; System.out.println(s1.concat(s2));// 判断是否包含字符串 System.out.println(s1.concat(s3)); System.out.println(\"---------\"); System.out.println(s1.startsWith(s4));//判断是否以传入字符串开头 System.out.println(s1.startsWith(s5)); System.out.println(\"---------\"); System.out.println(s1.endsWith(s4));//判断是否以传入字符串结尾 System.out.println(s1.endsWith(s5)); &#125; private static void demo1() &#123; String s1 = \"wxhao\"; String s2 = \"wxhao\"; String s3 = \"Wxhao\"; System.out.println(s1.equals(s2)); System.out.println(s1.equals(s3)); System.out.println(\"------------\"); System.out.println(s1.equalsIgnoreCase(s2)); System.out.println(s1.equalsIgnoreCase(s3)); System.out.println(\"------------\"); &#125;&#125; 模拟用户登录 需求:摸你登录,给三次机会,并提示还有几次 用户名和密码都是admin 12345678910111213141516171819202122232425262728293031323334353637package com.wxhao.test;import java.util.Scanner;public class Test1 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); final String USERNAME= \"admin\"; final String PASSWORD= \"admin\"; String usernameIn=null; String passwordIn=null; for(int i = 0 ; i &lt; 3 ; i++)&#123; System.out.println(\"请输入用户名:\"); usernameIn = sc.nextLine(); System.out.println(\"请输入密码:\"); passwordIn = sc.nextLine(); if(USERNAME.equals(usernameIn)&amp;&amp;PASSWORD.equals(passwordIn))&#123; System.out.println(\"登录成功\"); break; &#125;else&#123; System.out.println(\"登录失败\"); if(i==2)&#123; System.out.println(\"你的错误次数已到到上限,请明天再来\"); &#125;else&#123; System.out.println(\"还有\"+(2-i)+\"次机会\"); &#125; &#125; &#125; &#125;&#125; String类的获取功能 int length();获取字符串长度 char charAt(int index);获取指定索引位置的字符 int indexOf(int ch);返回指定字符在此字符串中第一次出现处的索引 int indexOf(String str);返回指定字符在此字符串中第一次出现处的索引 int indexOf(int ch ,int fromIndex);返回指定字符在此字符串中从指定位置后第一次出现处的索引 int indexOf(String str,int fromIndex);返回指定字符在此字符串中从指定位置后第一次出现处的索引 lastIndexOf String substring(int start);从指定位置开始截取字符串,默认到尾数 String substring(int start,int end);从指定位置开始到指定位置结束截取字符串 字符串的遍历12345678910111213package com.wxhao.test;public class Test2 &#123; public static void main(String[] args) &#123; String s= \"wxhao\"; for (int i = 0; i &lt; s.length(); i++) &#123; char c=s.charAt(i);//通过索引获取每一个字符 System.out.println(c); &#125; &#125;&#125; 统计不同类型字符个数 需求:统计一个字符串中大写字母字符,小写字母字符,数字字符出现的次数,其他字符出现的次数 ABCDEabcd123456!@#$%^ 123456789101112131415161718192021222324252627282930package com.wxhao.test;public class Test3 &#123; /** * 分析:字符串是由字符组成的,而字符的值都是有范围的 通过范围来判断是否包含该字符 */ public static void main(String[] args) &#123; String s = \"ABCDEabcd123456!@#$%^\"; int big = 0; int small = 0; int num = 0; int other = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') &#123; big++; &#125; else if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; small++; &#125; else if (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; num++; &#125; else &#123; other++; &#125; &#125; System.out.println(big); System.out.println(small); System.out.println(num); System.out.println(other); &#125;&#125; String类的转换功能 String的转换功能: byte[] getBytes();把字符串转换为字节数组 GBK码表一个中文代表两个字节,第一个字节为负数 char[] toCharArray();把字符串转换为字符数组 static String valueOf(char[] chs);吧字符数组专程字符串 static String valueOf(int i);把int类型的数据转成字符串 注意:String 类的valueOf可以把任意类型的数据转成字符串 String toLowerCase();把字符串转成小写 String toUpperCase();把字符串转成大写 String concat(String str);把字符串拼接 按需求转换字符 需求 把一个字符串的首字母转成大写,其余为小写 123456789101112package com.wxhao.test;public class Test4 &#123; /** * 链式编程:只要保证每次调用完成方法返回的是对象,就可以继续调用 */ public static void main(String[] args) &#123; String s = \"woshiYIGEDASHUAIBI\"; String str = s.substring(0, 1).toUpperCase().concat(s.substring(1).toLowerCase()); System.out.println(str); &#125;&#125; String 类的其他功能12345678910111213141516171819202122232425262728293031package com.wxhao.string;public class Demo7_StringMethod &#123; public static void main(String[] args) &#123; String s1 = \"a\"; String s2 = \"aaaa\"; int num = s1.compareTo(s2);// 码表值比较 System.out.println(num); String s3 = \"吴\"; String s4 = \"浩\"; int num2 = s3.compareTo(s4); System.out.println(num2); System.out.println('吴' + 0);// 查找的是Unicode码表值 System.out.println('浩' + 0); String s5=\"wxhao\"; String s6=\"WXHAO\"; int num3=s5.compareTo(s6); System.out.println(num3); int num4=s5.compareToIgnoreCase(s6); System.out.println(num4); &#125;&#125; 字符串反转 举例:输入”abc”,输出”cba” 12345678910111213141516171819package com.wxhao.test;import java.util.Scanner;public class Test6 &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); String str=sc.nextLine(); char[] cs=str.toCharArray(); int length=cs.length; char[] newCs=new char[length]; for (int i = 0; i &lt; length; i++) &#123; newCs[length-i-1]=cs[i]; &#125; System.out.println(String.valueOf(newCs)); &#125;&#125; 在大串中查找小串出现的次数代码实现12345678910111213141516171819package com.wxhao.test;public class Test7_String &#123; public static void main(String[] args) &#123; String s=\"woshiwxhao,woailyy,hahaah,wxhao,lyyheihh lyy\"; String value=\"lyy\"; int count=0; int i=-1; do &#123; i=s.indexOf(value); s=s.substring(i+value.length());// System.out.println(i);// System.out.println(s); count++; &#125; while (i&gt;-1&amp;&amp;!s.isEmpty()); System.out.println(count); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE常见对象 - Scanner","date":"2013-07-26T16:00:00.000Z","path":"2013/07/27/2013-07-27-object-class-scanner/","text":"JavaSE常见对象 - Scanner Scanner的概述和方法介绍 scanner的构造方法原理 scanner(inputstream source) system类下有一个静态的字段 public static final inputstream in:标准的输入流,对应着键盘录入 一般方法 hashNextXxx() 判断是否还有下一个输入项,其中Xxx可以是Int,Double等,如果需要判断是否包含下一个字符串,则可以省略Xxx nextXxx() 获取下一个输入项,Xxx的含义和上个方法中的相同,默认情况下,scanner用空格,回车等作分隔符 12345678910111213141516171819package com.wxhao.bean;import java.util.Scanner;public class Demo_Scanner &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in);// int i =sc.nextInt();// System.out.println(i); if(sc.hasNextInt())&#123; int i =sc.nextInt(); System.out.println(i); &#125;else&#123; System.out.println(\"输入类型错误\"); &#125; &#125;&#125; Scanner获取数据出现的小问题及解决方案 两个常用的方法 public int nextInt();获取一个int类型的值 public int nextString();获取一个String类型的值 代码演示 获取多个int值,多个String值 先获取int,然后获取string值出现问题 解决问题办法 第一种:现获取一个数之后在创建一个新的键盘录入对象获取字符串 第二种:把所有的数据都先按照字符串获取,然后要什么,你就对应的转换为什么 123456789101112131415161718192021222324252627282930313233343536373839404142package com.wxhao.bean;import java.util.Scanner;public class Demo2_Scanner &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); // System.out.println(\"请输入第一个数字\");// int i = sc.nextInt();// System.out.println(\"请输入第二个数字\");// int j = sc.nextInt(); // System.out.println(\"i=\"+i+\",j=\"+j); // System.out.println(\"请输入第一个字符串\");// String x = sc.nextLine();// System.out.println(\"请输入第二个字符串\");// String y = sc.nextLine();// System.out.println(\"x=\"+x+\",y=\"+y); /** * nextInt()是键盘录入整数的方法,当我们录入10的时候 * 其实在键盘上录入的是10和\\r\\n,nextInt()方法只获取10就结束了 * nextLine()是键盘录入字符串的方法,可以接受任意类型,但是他为什么能获取一行呢? * 通过\\r\\n,只要遇到\\r\\n就证明是一行结束 */// System.out.println(\"请输入第一个数字\");// int a = sc.nextInt();// System.out.println(\"请输入第二个字符串\");// String b = sc.nextLine();// System.out.println(\"a=\"+a+\",b=\"+b);//输入10 敲回车只会输出10,为什么? /** * 解决方案 * 1.创建两次对象,但是浪费空间 * 2.键盘录入的都是字符串,都用nextLine方法 */ &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - Object类","date":"2013-07-24T16:00:00.000Z","path":"2013/07/25/2013-07-25-object-class-object/","text":"JavaSE Object类 API概述 API(Application Programming Interface) 应用程序编程接口 Java API 就是Java提供给我们使用的类，这些类将底层的实现封装了起来， 我们不需要关心这些类是如何实现的，只需要学习这些类如何使用。 Object类的概述 Object类概述 类层次结构的根类 所有类都直接或者间接的继承自该类 构造方法 public Object() 回想面向对象中为什么说： 子类的构造方法默认访问的是父类的无参构造方法 Object类的hashCode()方法 案例演示 public int hashCode() 返回该对象的哈希码值。默认情况下，该方法会根据对象的地址来计算。 不同对象的，hashCode()一般来说不会相同。但是，同一个对象的hashCode()值肯定相同。 Object类的getClass()方法(在反射的时候掌握) public final Class getClass() 返回此 Object 的运行时类。 可以通过Class类中的一个方法，获取对象的真实类的全名称。 public String getName() Object类的toString()方法 public String toString() a:返回该对象的字符串表示。 123public Stirng toString() &#123;return name + &quot;,&quot; + age;&#125; 它的值等于： getClass().getName() + “@” + Integer.toHexString(hashCode()) 由于默认情况下的数据对我们来说没有意义，一般建议重写该方法。 最终版 自动生成 Object类的equals()方法 指示其他某个对象是否与此对象“相等”。 默认情况下比较的是对象的引用是否相同。 由于比较对象的引用没有意义，一般建议重写该方法。 ==号和equals方法的区别 ==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值 equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - 开发工具","date":"2013-07-22T16:00:00.000Z","path":"2013/07/23/2013-07-23-tool-eclipse/","text":"JAVA 开发工具 eclipse 常见开发工具介绍 操作系统自带的记事本软件 高级记事本软件 集成开发环境 IDE (Integrated Development Environment) Eclipse和MyEclipse的区别 Eclipse是一种可扩展的开放源代码的IDE。 Eclipse的特点描述 免费 纯Java语言编写 免安装 扩展性强 MyEclipse 在Eclipse基础上追加的功能性插件，对插件收费 在WEB开发中提供强大的系统架构平台 下载 http://eclipse.org/ org是非盈利团体 安装 绿色版 解压就可以使用(Eclipse) 安装版 双击运行,一路next即可(JDK) 卸载 绿色版 直接删除文件夹即可 安装版 专业卸载软件或者控制面板添加删除程序 Eclipse中HelloWorld案例以及汉化 选择工作空间 工作空间 其实就是我们写的源代码所在的目录 用Eclipse来完成一个HelloWorld案例 代码以项目为基本单位 创建项目 创建包 创建类 编写代码 编译和运行 Eclipse的汉化 从Eclipse3.5开始，安装目录下就多了一个dropins目录,只要将插件解压后放到到该目录即可。 同理，这种方式卸载插件也是特别的方便，推荐这种方式 语法检查提示 红色波浪线 必须处理,否则编译通不过 黄色波浪线 可以不搭理他 eclipse3.7百度云下载 Eclipse的视窗和视图概述 视窗 每一个基本的窗体被称为视窗 PackageExplorer 显示项目结构，包，类，及资源 Outline 显示类的结构，方便查找，识别，修改 Console 程序运行的结果在该窗口显示 Hierarchy 显示Java继承层次结构，选中类后F4 视图 是由某些视窗的组合而成的 Java视图 Debug视图 Eclipse工作空间的基本配置 程序的编译和运行的环境配置(一般不改) window – Preferences – Java 编译环境：Compiler默认选中的就是最高版本。 运行环境：Installed JREs默认会找你安装的那个JDK。建议配置了Java的环境变量。 问题： 低编译，高运行。可以。 高编译，低运行。不可以。 建议，编译和运行的版本一致。 如何去掉默认注释? window – Preferences – Java – Code Style – Code Templates 选择你不想要的内容，通过右边Edit编辑。 注意：请只删除注释部分，不是注释部分的不要删除。 行号的显示和隐藏 显示：在代码区域的最左边的空白区域，右键 – Show Line Numbers即可。 隐藏：把上面的动作再做一次。 字体大小及颜色 a:Java代码区域的字体大小和颜色： window – Preferences – General – Appearance – Colors And Fonts –Java修改 – Java Edit Text Font 控制台 window – Preferences – General – Appearance – Colors And Fonts – Debug – Console font 其他文件 window – Preferences – General – Appearance – Colors And Fonts – Basic – Text Font 窗体给弄乱了，怎么办? window – Reset Perspective 控制台找不到了，怎么办? Window–Show View—Console 取消悬浮提示 window – Preferences – Java–Editor–Hovers。右边将Combined Hover勾去掉。 这样代码的悬浮框就不会自动出现了。如果想看提示，将光标悬浮在代码上，按F2即可。 Eclipse中内容辅助键的使用 Alt+/ 起提示作用 main+alt+/,syso+alt+/,给出其他提示 补充输出语句,选中需要输出的部分,alt+/选择最后一项即可 定义自己的alt + / windows–perference-Java-Editor-Templates–New Eclipse中快捷键的使用 新建 ctrl + n 格式化 ctrl+shift+f 导入包 ctrl+shift+o 注释 ctrl+/,ctrl+shift+/,ctrl+shift+\\ 代码上下移动 选中代码alt+上/下箭头 查看源码 选中类名(F3或者Ctrl+鼠标点击) 查找具体的类 ctrl + shift + t 查找具体类的具体方法 ctrl + o 给建议 ctrl+1,根据右边生成左边的数据类型,生成方法 删除代码 ctrl + d 抽取方法alt + shift + m 改名alt + shift + r Eclipse中如何提高开发效率 alt + shift + s A:自动生成构造方法 B:自动生成get/set方法 Eclipse中如何生成jar包并导入到项目中 jar是什么? jar是多个class文件的压缩包。 jar有什么用? 用别人写好的东西 打jar包 选中项目–右键–Export–Java–Jar–自己指定一个路径和一个名称–Finish 导入jar包 复制到项目路径下并添加至构建路径。 Eclipse中如何删除项目和导入项目) 删除项目 选中项目 – 右键 – 删除 从项目区域中删除 从硬盘上删除 导入项目 在项目区域右键找到import 找到General，展开，并找到 Existing Projects into Workspace 点击next,然后选择你要导入的项目 注意：这里选择的是项目名称 Eclipse中断点调试的基本使用 Debug的作用 调试程序 查看程序执行流程 B:如何查看程序执行流程 什么是断点： 就是一个标记，从哪里开始。 如何设置断点： 你想看哪里的程序，你就在那个有效程序的左边双击即可。 在哪里设置断点： 哪里不会点哪里。 目前：我们就在每个方法的第一条有效语句上都加。 如何运行设置断点后的程序： 右键 – Debug as – Java Application 看哪些地方： Debug：断点测试的地方 在这个地方，记住F6，或者点击也可以。一次看一行的执行过程。 Variables：查看程序的变量变化 ForDemo：被查看的源文件 Console：控制台 如何去断点： a:再次双击即可 b:找到Debug视图，Variables界面，找到Breakpoints，并点击，然后看到所有的断点，最后点击那个双叉。 Eclipse查看Java中参数传递问题 断点 断点查看Java中参数传递问题","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"},{"name":"IDE","slug":"IDE","permalink":"http://wxhaor.me/tags/IDE/"}]},{"title":"JavaSE之面向对象 - 内部类","date":"2013-07-20T16:00:00.000Z","path":"2013/07/21/2013-07-21-object-inner-class/","text":"内部类 内部类概述和访问特点 内部类概述 内部类访问特点 内部类可以直接访问外部类的成员，包括私有。 外部类要访问内部类的成员，必须创建对象。 外部类名.内部类名 对象名 = 外部类对象.内部类对象; 案例演示 内部类极其访问特点 12345678910111213141516171819class Demo1_InnerClass &#123; public static void main(String[] args) &#123; //Inner i = new Inner(); //i.method(); //外部类名.内部类名 = 外部类对象.内部类对象 Outer.Inner oi = new Outer().new Inner(); //创建内部类对象 oi.method(); &#125;&#125;class Outer &#123; private int num = 10; class Inner &#123; public void method() &#123; System.out.println(num); &#125; &#125;&#125; 成员内部类私有使用 private 1234567891011121314151617181920212223class Demo2_InnerClass &#123; public static void main(String[] args) &#123; //Outer.Inner oi = new Outer().new Inner(); //oi.method(); Outer o = new Outer(); o.print(); &#125;&#125;class Outer &#123; private int num = 10; private class Inner &#123; public void method() &#123; System.out.println(num); &#125; &#125; public void print() &#123; Inner i = new Inner(); i.method(); &#125;&#125; 静态成员内部类 static B:成员内部类被静态修饰后的访问方式是: 外部类名.内部类名 对象名 = 外部类名.内部类对象; 1234567891011121314151617181920212223class Demo1_InnerClass &#123; public static void main(String[] args) &#123; //外部类名.内部类名 对象名 = 外部类名.内部类对象; Outer.Inner oi = new Outer.Inner(); oi.method(); Outer.Inner2.print(); &#125;&#125;class Outer &#123; static class Inner &#123; public void method() &#123; System.out.println(\"method\"); &#125; &#125; static class Inner2 &#123; public static void print() &#123; System.out.println(\"print\"); &#125; &#125;&#125; 成员内部类的面试题 面试题 要求：使用已知的变量，在控制台输出30，20，10。 123456789101112131415161718class Outer &#123;public int num = 10;class Inner &#123; public int num = 20; public void show() &#123; int num = 30; System.out.println(?); System.out.println(??); System.out.println(???); &#125;&#125;&#125;class InnerClassTest &#123;public static void main(String[] args) &#123; Outer.Inner oi = new Outer().new Inner(); oi.show();&#125; &#125; 1234567891011121314151617181920class Test1_InnerClass &#123; public static void main(String[] args) &#123; Outer.Inner oi = new Outer().new Inner(); oi.show(); &#125;&#125;//要求：使用已知的变量，在控制台输出30，20，10。//内部类之所以能获取到外部类的成员,是因为他能获取到外部类的引用外部类名.thisclass Outer &#123; public int num = 10; class Inner &#123; public int num = 20; public void show() &#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); &#125; &#125;&#125; 局部内部类访问局部变量的问题 案例演示 局部内部类访问局部变量必须用final修饰 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么?因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用但是jdk1.8取消了这个事情,所以我认为这是个bug 12345678910111213141516171819202122232425class Demo1_InnerClass &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.method(); &#125;&#125;//局部内部类class Outer &#123; public void method() &#123; final int num = 10; class Inner &#123; public void print() &#123; System.out.println(num); &#125; &#125; Inner i = new Inner(); i.print(); &#125; /*public void run() &#123; Inner i = new Inner(); //局部内部类,只能在其所在的方法中访问 i.print(); &#125;*/&#125; 匿名内部类的格式和理解 匿名内部类 就是内部类的简化写法。 前提：存在一个类或者接口 这里的类可以是具体类也可以是抽象类。 格式：new 类名或者接口名(){ 重写方法; } 本质是什么呢? 是一个继承了该类或者实现了该接口的子类匿名对象。 案例演示 按照要求来一个匿名内部类 12345678910111213141516171819202122232425262728293031interface Inter &#123; public void print();&#125;class Outer &#123; class Inner implements Inter &#123; public void print() &#123; System.out.println(\"print\"); &#125; &#125; public void method()&#123; //Inner i = new Inner(); //i.print(); //new Inner().print(); //Inter i = new Inner(); //父类引用指向子类对象 new Inter() &#123; //实现Inter接口 public void print() &#123; //重写抽象方法 System.out.println(\"print\"); &#125; &#125;.print(); &#125;&#125;class Demo1_NoNameInnerClass &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.method(); &#125;&#125; 面向对象(匿名内部类重写多个方法调用) 案例演示 匿名内部类的方法调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Demo2_NoNameInnerClass &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.method(); &#125;&#125;interface Inter &#123; public void show1(); public void show2();&#125;//匿名内部类只针对重写一个方法时候使用class Outer &#123; public void method() &#123; /*new Inter()&#123; public void show1() &#123; System.out.println(\"show1\"); &#125; public void show2() &#123; System.out.println(\"show2\"); &#125; &#125;.show1(); new Inter()&#123; public void show1() &#123; System.out.println(\"show1\"); &#125; public void show2() &#123; System.out.println(\"show2\"); &#125; &#125;.show2();*/ Inter i = new Inter()&#123; public void show1() &#123; System.out.println(\"show1\"); &#125; public void show2() &#123; System.out.println(\"show2\"); &#125; /*public void show3() &#123; System.out.println(\"show3\"); &#125;*/ &#125;; i.show1(); i.show2(); //i.show3(); //匿名内部类是不能向下转型的,因为没有子类类名 &#125;&#125; 面向对象(匿名内部类在开发中的应用) 代码如下 123456789101112131415161718//这里写抽象类，接口都行abstract class Person &#123; public abstract void show();&#125;class PersonDemo &#123; public void method(Person p) &#123; p.show(); &#125;&#125;class PersonTest &#123; public static void main(String[] args) &#123; //如何调用PersonDemo中的method方法呢? PersonDemo pd = new PersonDemo (); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637class Test1_NoNameInnerClass &#123; public static void main(String[] args) &#123; //如何调用PersonDemo中的method方法呢? PersonDemo pd = new PersonDemo (); //pd.method(new Student()); pd.method(new Person() &#123; public void show() &#123; System.out.println(\"show\"); &#125; &#125;); &#125;&#125;//这里写抽象类，接口都行abstract class Person &#123; public abstract void show();&#125;class PersonDemo &#123;​ //public void method(Person p) &#123; //Person p = new Student(); //父类引用指向子类对象 /* Person p = new Person()&#123; public void show() &#123; System.out.println(\"show\"); &#125; &#125;; */ public void method(Person p) &#123; p.show(); &#125;&#125;class Student extends Person &#123; public void show() &#123; System.out.println(\"show\"); &#125;&#125; 面向对象(匿名内部类的小练习)123456789按照要求，补齐代码interface Inter &#123; void show(); &#125;class Outer &#123; //补齐代码 &#125;class OuterDemo &#123; public static void main(String[] args) &#123; Outer.method().show(); &#125;&#125;要求在控制台输出”HelloWorld” 12345678910111213141516171819202122class Test2_NoNameInnerClass &#123; public static void main(String[] args) &#123; //Outer.method().show(); //链式编程,每次调用方法后还能继续调用方法,证明调用方法返回的是对象 Inter i = Outer.method(); i.show(); &#125;&#125;//按照要求，补齐代码interface Inter &#123; void show(); &#125;class Outer &#123; //补齐代码 public static Inter method() &#123; return new Inter() &#123; public void show() &#123; System.out.println(\"show\"); &#125; &#125;; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE之面向对象 - package关键字及访问修饰符","date":"2013-07-18T16:00:00.000Z","path":"2013/07/19/2013-07-19-object-package-public/","text":"package关键字及访问修饰符 package关键字的概述及作用 为什么要有包 将字节码(.class)进行分类存放 包其实就是文件夹 包的概述 举例： 1234567891011121314151617181920212223242526272829学生：增加，删除，修改，查询老师：增加，删除，修改，查询...方案1：按照功能分 com.heima.add AddStudent AddTeacher com.heima.delete DeleteStudent DeleteTeacher com.heima.update UpdateStudent UpdateTeacher com.heima.find FindStudent FindTeacher方案2：按照模块分 com.heima.teacher AddTeacher DeleteTeacher UpdateTeacher FindTeacher com.heima.student AddStudent DeleteStudent UpdateStudent FindStudent 包的定义及注意事项 定义包的格式 package 包名; 多级包用.分开即可 定义包的注意事项 A:package语句必须是程序的第一条可执行的代码 B:package语句在一个java文件中只能有一个 C:如果没有package，默认表示无包名 案例演示 包的定义及注意事项 带包的类编译和运行 如何编译运行带包的类(cmd) javac编译的时候带上-d即可 javac -d . HelloWorld.java 通过java命令执行。 java 包名.HellWord 12javac -d . HelloWorld.javajava 包名.HellWord 不同包下类之间的访问 案例演示 不同包下类之间的访问 1234567891011121314151617181920212223242526272829303132package com.baidu;public class Person &#123; private String name; private int age; public Person()&#123;&#125; public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; protected void print() &#123; System.out.println(\"print\"); &#125;&#125; 12345678package com.heima;class Demo1_Package &#123; public static void main(String[] args) &#123; com.baidu.Person p = new com.baidu.Person(\"张三\",23); System.out.println(p.getName() + \"...\" + p.getAge()); &#125;&#125; import关键字的概述和使用 案例演示 为什么要有import 其实就是让有包的类对调用者可见,不用写全类名了 导包格式 import 包名; 注意： 这种方式导入是到类的名称。 虽然可以最后写*，但是不建议。 package,import,class有没有顺序关系(面试题) 有,依次是package,import,class 12345678910111213141516package com.heima;import com.baidu.Person;//import java.util.Scanner; //在开发中我们用的都是导入具体的类import java.util.*; //*代表通配符,他会到该包下挨个匹配,匹配上就导入class Demo1_Package &#123; public static void main(String[] args) &#123; Person p = new Person(\"张三\",23); System.out.println(p.getName() + \"...\" + p.getAge()); //p.print(); //在不同包下的无关类,不允许访问,因为是protected修饰的 Scanner sc = new Scanner(System.in); int x = sc.nextInt(); System.out.println(x); &#125;&#125; 四种权限修饰符的测试 A:案例演示 四种权限修饰符 B:结论 修饰符 本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类) private Y 默认 Y Y protected Y Y Y public Y Y Y Y 12345678910111213package com.xxx;import com.baidu.Person;public class Student extends Person &#123; public Student()&#123;&#125; public Student(String name,int age) &#123; super(name,age); &#125; public void method() &#123; print(); &#125;&#125; 1234567891011121314151617181920package com.heima;import com.baidu.Person;import com.xxx.Student;//import java.util.Scanner; //在开发中我们用的都是导入具体的类import java.util.*; //*代表通配符,他会到该包下挨个匹配,匹配上就导入class Demo1_Package &#123; public static void main(String[] args) &#123; Person p = new Person(\"张三\",23); System.out.println(p.getName() + \"...\" + p.getAge()); //p.print(); //在不同包下的无关类,不允许访问,因为是protected修饰的 /*Scanner sc = new Scanner(System.in); int x = sc.nextInt(); System.out.println(x);*/ Student s = new Student(\"李四\",24); System.out.println(s.getName() + \"...\" + s.getAge()); s.method(); &#125;&#125; 类及其组成所使用的常见修饰符 修饰符： 权限修饰符：private，默认的，protected，public 状态修饰符：static，final 抽象修饰符：abstract 类： 权限修饰符：默认修饰符，public 状态修饰符：final 抽象修饰符：abstract 用的最多的就是：public 成员变量： 权限修饰符：private，默认的，protected，public 状态修饰符：static，final 用的最多的就是：private 构造方法： 权限修饰符：private，默认的，protected，public 用的最多的就是：public 成员方法： 权限修饰符：private，默认的，protected，public 状态修饰符：static，final 抽象修饰符：abstract 用的最多的就是：public 除此以外的组合规则： 成员变量：public static final 成员方法： public static public abstract public final","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE之面向对象 - 抽象类与接口","date":"2013-07-16T16:00:00.000Z","path":"2013/07/17/2013-07-17-object-abstract-interface/","text":"抽象类与接口 抽象类的概述及其特点 抽象类概述 抽象就是看不懂的 抽象类特点 抽象类和抽象方法必须用abstract关键字修饰 abstract class 类名 {} public abstract void 方法名(); 抽象类不一定有抽象方法,有抽象方法的类一定是抽象类或者接口 抽象类不能实例化,抽象类如何实例化呢按照多态的方式,由具体的子类实例化,其实这也是多态的一种,抽象类多态 抽象类的子类 要么是抽象类 要么重写抽象类中的所有抽象方法 代码演示 123456789101112131415161718192021public class Demo1_Abstract &#123; public static void main(String[] args) &#123; //Animal a= Animal(); //Animal是抽象的,无法实例化 Animal a= new Cat(); //父类引用子类对象 a.eat(); &#125;&#125;abstract class Animal&#123;//抽象类 public abstract void eat();//抽象方法&#125;class Cat extends Animal&#123; public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125; &#125; 抽象类的成员特点 抽象类的成员特点 成员变量:既可以是变量,也可以是常量 abstract是否可以修饰成员变量不能修饰成员变量 构造方法:有用于子类访问父类数据的初始化 成员方法:既可以是抽象的,也可以是非抽象的 代码演示抽象类的特点 抽象方法,强制要求子类做的事情 非抽象方法,子类继承的事情,提高代码复用性 1234567891011121314151617181920212223242526public class Demo2_Abstract &#123; public static void main(String[] args) &#123; &#125;&#125;abstract class Demo&#123; int num = 10; final int num2=20; public Demo()&#123;&#125; public void print()&#123; System.out.println(\"111\"); &#125; public abstract void method();&#125;class Test extends Demo&#123; public void method() &#123; &#125;&#125; 抽象类中的面试题 一个抽象类如果没有抽象方法,可以不可以定义为抽象类?可以,这么做目的只有一个,就是不让其它的创建本类对象,交给子类完成 abstract不能和哪些关键字共存 static 可以被类名调用,但类名.抽象方法没有意义abstract 方法没有方法体 final 不让子类重写abstract 强制子类重写 private 修饰不让子类访问,所以他俩是矛盾的abstract 为了让子类看到,并强制子类重写 接口的概述及其特点 接口概述 从狭义的角度讲就是java中的interface 从广义的角度讲对外提供规则的都是接口 接口特点 接口用关键字interface表示interface 接口名{} 类实现接口用implements表示class 类名 implements 接口名{} 接口不能实例化 接口如何实例化? 按照多态的方式来实例化 接口的子类 可以是抽象类,但是意义不大 可以是具体类,要重写接口中的所有抽象方法(推荐方案) 代码演示 1234567891011121314151617181920public class Demo1_Interface &#123; public static void main(String[] args) &#123; //Inter i=new Inter(); 接口不能被实例化,因为调用抽象方法没有意义 Inter i =new Demo(); i.print(); &#125;&#125;interface Inter&#123; public abstract void print(); //接口中的方法都是抽象的&#125;class Demo implements Inter&#123; public void print() &#123; System.out.println(\"print\"); &#125;&#125; 接口成员特点 成员变量:只能是常量,冰倩是静态的并公共的 默认修饰符:public static final 建议:自己手动给出 构造方法:接口没有构造方法 成员方法: 只能是抽象方法 默认修饰符:public abstract 建议:自己手动给出 代码演示 1234567891011121314151617181920212223public class Demo2_Interface &#123; public static void main(String[] args) &#123; Demo d=new Demo(); d.print(); System.out.println(Inter.num); &#125;&#125;interface Inter&#123; static final int num = 10; //默认加public static final修饰符 //public Inter()&#123;&#125; //没有构造方法 void print(); //默认public abstract&#125;class Demo /*extends Object */implements Inter &#123;//默认继承Object类 public void print() &#123; System.out.println(num); &#125;&#125; 类与类,类与接口,接口与接口的关系 类与类,类与接口,接口与接口的关系 类与类: 继承关系,只能单继承,不能多层继承 类与接口 实现关系,可以 单实现,也可以多实现 并且还可以在继承一个类的同事实现多个接口 接口与接口 继承关系,可以单继承,也可以多继承 123456789101112131415161718192021interface InterA&#123; void printA();&#125;interface InterB&#123; void printB(); &#125;interface InterC extends InterA,InterB&#123;//可以多继承&#125;class Demo implements InterA ,InterB &#123;//多接口用,(逗号)分割 public void printA() &#123; System.out.println(\"printA\"); &#125; public void printB() &#123; System.out.println(\"printB\"); &#125;&#125; 类与类,类与接口,接口与接口的区别 成员区别 抽象类: 成员变量:可以变量,也可以常量 构造方法:有 成员方法:可以抽象,也可以非抽象 接口: 成员变量:只可以常量 成员方法:只可以抽象 关系区别 类与类: 继承,单继承 类与接口 实现,单实现,多实现 接口与接口 继承,单继承,多继承 设计理念区别 抽象类 被继承体现的是”is a”的关系,抽象类中定义的是该继承体系的共性功能 接口 被实现体现的是:”like a”的关系.接口中定义的是该继承体系的扩展功能","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE之面向对象 - 多态(重点)","date":"2013-07-13T16:00:00.000Z","path":"2013/07/14/2013-07-14-object-polymorphic/","text":"多态(重点) 多态的概述及其代码体现 多态(polymorphic)概述 事物存在的多种形态 多态的前提 要的是有继承关系 要有方法重写 要有父类引用指向子类对象 代码体现多态 1234567891011121314151617181920212223public class Demo_polymorphic &#123; public static void main(String[] args) &#123; Cat c=new Cat(); c.eat(); Animal a=new Cat();//父类引用指向子类对象 a.eat();//猫吃鱼 &#125;&#125;class Animal&#123; public void eat()&#123; System.out.println(\"动物吃饭\"); &#125;&#125;class Cat extends Animal&#123; public void eat()&#123; System.out.println(\"猫吃鱼\"); &#125;&#125; 多态中的成员访问特点 成员变量(左边子类,右边父类)编译看左边,运行看左边 成员方法编译看左边,运行看右边,动态绑定 静态方法 编译看左边,运行看左边 静态和类相关,算不上重写,所以,访问还是左边的 总结:只有非静态的成员方法,编译看左边,运行看右边 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940public class Demo_polymorphic2 &#123; public static void main(String[] args) &#123; Father f=new Son(); System.out.println(f.num); Son s=new Son(); System.out.println(s.num); f.print();//Son //Father.method() f.method();//method static Father Son.method();//method static Son &#125;&#125;class Father&#123; int num = 10; public void print()&#123; System.out.println(\"Father\"); &#125; public static void method()&#123; System.out.println(\"method static Father\"); &#125;&#125;class Son extends Father&#123; int num = 20; public void print()&#123; System.out.println(\"Son\"); &#125; public static void method()&#123; System.out.println(\"method static Son\"); &#125;&#125; 面向对象(超人的故事) 代码演示 123456789101112131415161718192021222324252627282930313233public class Demo3_SuperMan &#123; public static void main(String[] args) &#123; Person p=new SuperMan();//父类引用指向子类对象,超人伪装成人 System.out.println(p.name);//谈生意不能说自己是超人,而说自己的人名 p.谈生意();//动作是超人做的,所以谈的是几个亿的大单子 //假如有人要跳楼,超人要去救人 //p.fly();//现在是普通人不能去救人 &#125;&#125;class Person &#123; String name = \"John\"; public void 谈生意()&#123; System.out.println(\"谈生意\"); &#125;&#125;class SuperMan extends Person&#123; String name = \"SuperMan\"; public void 谈生意()&#123; System.out.println(\"谈几个亿的大生意\"); &#125; public void fly()&#123; System.out.println(\"飞出去救人\"); &#125;&#125; 多态中向上转型和向下转型 父类引用指向子类对象就是向上转型,就像超人伪装成了人 1Person p=new SuperMan();//向上转型 向下转型(必须先有向上转型才有向下转型) 12SuperMan sm = (SuperMan)p;//向下转型sm.fly();//现在就可以飞出去救人 多态的好处和弊端 多态的好处 提高了代码的维护性(继承保证) 提高了代码的扩展性(由多态保证) 代码演示 多态的好处 可以当做形式参数,可以接受任意子对象 多态的弊端 不能使用子类特有属性和行为 关键字 instanceof 判断前边的引用是否是后边的数据类型 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Demo4_Animal &#123; public static void main(String[] args) &#123; method(new Cat()); //method(new Dog()); method(new Dog()); // Animal a=new Cat();//开发的时候很少在创建对象的时候用父类引用指向子类对象,直接创建子类对象更方便,可以使用子类中的特有属性和行为 &#125; //Cat c= new Dog();狗是一只猫,这是错误的 /*public static void method(Cat c)&#123; c.eat(); &#125; public static void method(Dog d)&#123; d.eat(); &#125;*/ public static void method(Animal a)&#123;//当作参数的时候用多态最好,因为拓展性强 // a.catchMouse(); //关键字 instanceof 判断前边的引用是否是后边的数据类型 if(a instanceof Cat)&#123; Cat c=(Cat)a; c.eat(); c.catchMouse(); &#125;else if(a instanceof Cat)&#123; Dog d=(Dog)a; d.eat(); d.lookHome();; &#125;else&#123; a.eat(); &#125; &#125;&#125;class Animal&#123; public void eat()&#123; System.out.println(\"动物吃饭\"); &#125;&#125;class Cat extends Animal&#123; public void eat()&#123; System.out.println(\"猫吃鱼\"); &#125; public void catchMouse()&#123; System.out.println(\"抓老鼠\"); &#125;&#125;class Dog extends Animal&#123; public void eat()&#123; System.out.println(\"狗吃肉\"); &#125; public void lookHome()&#123; System.out.println(\"看家\"); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE面向对象 - final 关键字","date":"2013-07-10T16:00:00.000Z","path":"2013/07/11/2013-07-11-object-final/","text":"final 关键字 final关键字修饰类,方法以及变量的特点 final概述 final修饰特点 修饰类，类不能被继承 修饰变量，变量就变成了常量，只能被赋值一次 修饰方法，方法不能被重写 案例演示 final修饰特点 123456789101112131415161718192021class Demo1_Final &#123; public static void main(String[] args) &#123; Son s = new Son(); s.print(); &#125;&#125;/*final class Father &#123; public void print() &#123; System.out.println(\"访问底层数据资源\"); &#125;&#125;*/class Son /*extends Father*/ &#123; final int NUM = 10; //常量命名规范,如果是一个单词,所有字母大写,如果是多个单词,每个单词都大写,中间用下划线隔开 public static final double PI = 3.14; //final修饰变量叫做常量,一般会与public static共用 public void print() &#123; //NUM = 20; System.out.println(NUM); &#125;&#125; final关键字修饰局部变量 代码演示 方法内部或者方法声明上都试一下 基本类型，是值不能被改变 引用类型，是地址值不能被改变,对象中的属性可以改变 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Demo2_Final &#123; public static void main(String[] args) &#123; final int num = 10; //num = 20; System.out.println(num); final Person p = new Person(\"张三\",23); //p = new Person(\"李四\",24); p.setName(\"李四\"); p.setAge(24); System.out.println(p.getName() + \"...\" + p.getAge()); method(10); method(20); &#125; public static void method(final int x) &#123; System.out.println(x); &#125;&#125;class Person &#123; private String name; //姓名 private int age; //年龄 public Person()&#123;&#125; //空参构造 public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; //设置姓名 this.name = name; &#125; public String getName() &#123; //获取姓名 return name; &#125; public void setAge(int age) &#123; //设置年龄 this.age = age; &#125; public int getAge() &#123; //获取年龄 return age; &#125;&#125; final修饰变量的初始化时机 final修饰变量的初始化时机 显示初始化 在对象构造完毕前即可 1234567891011121314151617class Demo3_Final &#123; public static void main(String[] args) &#123; Demo d = new Demo(); d.print(); &#125;&#125;class Demo &#123; final int num; //成员变量的默认初始化值是无效值 public Demo() &#123; num = 10; &#125; public void print() &#123; System.out.println(num); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE之面向对象 - 继承","date":"2013-07-08T16:00:00.000Z","path":"2013/07/09/2013-07-09-object-extends/","text":"JavaSE之面向对象 - 继承 继承案例演示 继承(extends) 让类与类之间产生关系,子父类关系 继承案例演示： 动物类,猫类,狗类 定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉) 案例演示 使用继承前 案例演示 使用继承后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Demo1_Extends &#123; public static void main(String[] args) &#123; Cat c = new Cat(); c.color = \"花\"; c.leg = 4; c.eat(); c.sleep(); System.out.println(c.leg + \"...\" + c.color); &#125;&#125;/** A:继承(extends) * 让类与类之间产生关系,子父类关系 * B:继承案例演示： * 动物类,猫类,狗类 * 定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉)* C:案例演示 * 使用继承前* D:案例演示 * 使用继承后*/class Animal &#123; String color; //动物的颜色 int leg; //动物腿的个数 public void eat() &#123; //吃饭的功能 System.out.println(\"吃饭\"); &#125; public void sleep() &#123; //睡觉的功能 System.out.println(\"睡觉\"); &#125;&#125;class Cat extends Animal &#123; &#125;class Dog extends Animal &#123; &#125;/*extends是继承的意思Animal是父类Cat和Dog都是子类*/ 继承的好处和弊端 继承的好处 提高了代码的复用性 提高了代码的维护性 让类与类之间产生了关系，是多态的前提 继承的弊端 类的耦合性增强了。 开发的原则：高内聚，低耦合。 耦合：类与类的关系 内聚：就是自己完成某件事情的能力 Java中类的继承特点 Java中类的继承特点 Java只支持单继承，不支持多继承。(一个儿子只能有一个爹) 有些语言是支持多继承，格式：extends 类1,类2,… Java支持多层继承(继承体系) 案例演示 Java中类的继承特点 如果想用这个体系的所有功能用最底层的类创建对象 如果想看这个体系的共性功能,看最顶层的类 123456789101112131415161718192021222324class Demo2_Extends &#123; public static void main(String[] args) &#123; DemoC d = new DemoC(); d.show(); &#125;&#125;class DemoA &#123; public void show() &#123; System.out.println(\"DemoA\"); &#125;&#125;class DemoB extends DemoA &#123; public void method() &#123; System.out.println(\"DemoB\"); &#125;&#125;class DemoC extends DemoB &#123; public void print() &#123; System.out.println(\"DemoC\"); &#125;&#125; 继承的注意事项和什么时候使用继承 继承的注意事项 子类只能继承父类所有非私有的成员(成员方法和成员变量) 子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。 不要为了部分功能而去继承 项目经理 姓名 工号 工资 奖金 程序员姓名 工号 工资 什么时候使用继承 继承其实体现的是一种关系：”is a”。 1234567Person Student Teacher水果 苹果 香蕉 橘子 采用假设法。 如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。 12345678910111213141516class Demo3_Extends &#123; public static void main(String[] args) &#123; Son s = new Son(); s.show(); &#125;&#125;class Father &#123; private String name; private void show() &#123; System.out.println(\"Hello World!\"); &#125;&#125;class Son extends Father &#123;&#125; 继承中成员变量的关系 案例演示 不同名的变量 同名的变量 123456789101112131415161718192021222324252627class Demo4_Extends &#123; public static void main(String[] args) &#123; Son s = new Son(); s.print(); &#125;&#125;/** A:案例演示 * a:不同名的变量 * b:同名的变量 子父类出现同名的变量只是在讲课中举例子有,在开发中是不会出现这种情况的 子类继承父类就是为了使用父类的成员,那么如果定义了同名的成员变量没有意义了*/class Father &#123; int num1 = 10; int num2 = 30;&#125;class Son extends Father &#123; int num2 = 20; public void print() &#123; System.out.println(num1);//10 System.out.println(num2);//20,就近原则,子类有就不用父类的了 &#125;&#125; this和super的区别和应用 this和super都代表什么 this:代表当前对象的引用,谁来调用我,我就代表谁 super:代表当前对象父类的引用 this和super的使用区别 调用成员变量 this.成员变量 调用本类的成员变量,也可以调用父类的成员变量 super.成员变量 调用父类的成员变量 调用构造方法 this(…) 调用本类的构造方法 super(…)调用父类的构造方法 调用成员方法 this.成员方法 调用本类的成员方法,也可以调用父类的方法 super.成员方法 调用父类的成员方法 1234567891011121314class Father &#123; int num1 = 10; int num2 = 30;&#125;class Son extends Father &#123; int num2 = 20; public void print() &#123; System.out.println(this.num1); //this既可以调用本类的,也可以调用父类的(本类没有的情况下) System.out.println(this.num2); //就近原则,子类有就不用父类的了 System.out.println(super.num2); &#125;&#125; 继承中构造方法的关系 案例演示 子类中所有的构造方法默认都会访问父类中空参数的构造方法 为什么呢? 因为子类会继承父类中的数据，可能还会使用父类的数据。 所以，子类初始化之前，一定要先完成父类数据的初始化。 其实： 每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。 12345678910111213141516171819class Demo5_Extends &#123; public static void main(String[] args) &#123; Son s = new Son(); &#125;&#125;class Father extends Object &#123; public Father() &#123; super(); System.out.println(\"Father 的构造方法\"); &#125;&#125;class Son extends Father &#123; public Son() &#123; super(); //这是一条语句,如果不写,系统会默认加上,用来访问父类中的空参构造 System.out.println(\"Son 的构造方法\"); &#125;&#125; 继承中构造方法的注意事项 案例演示 父类没有无参构造方法,子类怎么办? super解决 this解决 注意事项 super(…)或者this(….)必须出现在构造方法的第一条语句上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Demo6_Extends &#123; public static void main(String[] args) &#123; Son s1 = new Son(); System.out.println(s1.getName() + \"...\" + s1.getAge()); System.out.println(\"--------------------\"); Son s2 = new Son(\"张三\",23); System.out.println(s2.getName() + \"...\" + s2.getAge()); &#125;&#125;class Father &#123; private String name; //姓名 private int age; //年龄 public Father() &#123; //空参构造 System.out.println(\"Father 空参构造\"); &#125; public Father(String name,int age) &#123; //有参构造 this.name = name; this.age = age; System.out.println(\"Father 有参构造\"); &#125; public void setName(String name) &#123; //设置姓名 this.name = name; &#125; public String getName() &#123; //获取姓名 return name; &#125; public void setAge(int age) &#123; //设置年龄 this.age = age; &#125; public int getAge() &#123; //获取年龄 return age; &#125;&#125;class Son extends Father &#123; public Son() &#123; //空参构造 this(\"王五\",25); //本类中的构造方法 //super(\"李四\",24); //调用父类中的构造方法 System.out.println(\"Son 空参构造\"); &#125; public Son(String name,int age) &#123; //有参构造 super(name,age); System.out.println(\"Son 有参构造\"); &#125;&#125; 继承中的面试题 看程序写结果1 123456789101112131415161718192021222324class Fu&#123; public int num = 10; public Fu()&#123; System.out.println(\"fu\"); &#125;&#125;class Zi extends Fu&#123; public int num = 20; public Zi()&#123; System.out.println(\"zi\"); &#125; public void show()&#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125;&#125;class Test1_Extends &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); &#125;&#125; 输出 fu zi 30 20 10 看程序写结果 1234567891011121314151617181920212223242526272829class Fu &#123;static &#123;System.out.println(&quot;静态代码块Fu&quot;);&#125;&#123;System.out.println(&quot;构造代码块Fu&quot;);&#125;public Fu() &#123;System.out.println(&quot;构造方法Fu&quot;);&#125;&#125;class Zi extends Fu &#123;static &#123;System.out.println(&quot;静态代码块Zi&quot;);&#125;&#123;System.out.println(&quot;构造代码块Zi&quot;);&#125;public Zi() &#123;System.out.println(&quot;构造方法Zi&quot;);&#125;&#125;Zi z = new Zi(); 输出 静态代码块Fu 静态代码块Zi 构造代码块Fu 构造方法Fu 构造代码块Zi 构造方法Zi 请执行结果。 jvm调用了main方法,main进栈 遇到Zi z = new Zi();会先将Fu.class和Zi.class分别加载进内存,再创建对象,当Fu.class加载进内存父类的静态代码块会随着Fu.class一起加载,当Zi.class加载进内存,子类的静态代码块会随着Zi.class一起加载第一个输出,静态代码块Fu,第二个输出静态代码块Zi 走Zi类的构造方法,因为java中是分层初始化的,先初始化父类,再初始化子类,所以先走的父类构造,但是在执行父类构造时,发现父类有构造代码块,构造代码块是优先于构造方法执行的所以第三个输出构造代码块Fu,第四个输出构造方法Fu Fu类初始化结束,子类初始化,第五个输出的是构造代码块Zi,构造方法Zi 继承中成员方法关系 不同名的方法 同名的方法 12345678910111213141516171819202122232425262728class Demo7_Extends &#123; public static void main(String[] args) &#123; Son s = new Son(); s.print(); s.method(); &#125;&#125;/** a:不同名的方法* b:同名的方法 */class Father &#123; public void print() &#123; System.out.println(\"Fu print\"); &#125;&#125;class Son extends Father &#123; public void method() &#123; System.out.println(\"Zi Method\"); &#125; public void print() &#123; super.print(); //super可以调用父类的成员方法 System.out.println(\"Zi print\"); &#125;&#125; 方法重写概述及其应用 什么是方法重写 重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) 方法重写的应用： 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。 演示 定义一个手机类。 12345678910111213141516171819202122232425262728293031class Demo7_Phone &#123; public static void main(String[] args) &#123; Ios8 i = new Ios8(); i.siri(); i.call(); &#125;&#125;/*B:方法重写的应用： * 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。 ios7系统 siri speak English ios8系统 siri 说中文*/class Ios7 &#123; public void call() &#123; System.out.println(\"打电话\"); &#125; public void siri() &#123; System.out.println(\"speak English\"); &#125;&#125;class Ios8 extends Ios7 &#123; public void siri() &#123; System.out.println(\"说中文\"); super.siri(); &#125;&#125; 方法重写的注意事项 方法重写注意事项 父类中私有方法不能被重写 因为父类私有方法子类根本就无法继承 子类重写父类方法时，访问权限不能更低 最好就一致 父类静态方法，子类也必须通过静态方法进行重写 其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态) 子类重写父类方法的时候，最好声明一模一样。 演示 方法重写注意事项 12345678910111213141516171819202122232425262728293031class Demo8_双桨 &#123; public static void main(String[] args) &#123; DayOne d = new DayOne(); d.泡妞(); d.print(); &#125;&#125;class 双桨 &#123; public void sing() &#123; System.out.println(\"唱红歌\"); &#125; public void 泡妞() &#123; System.out.println(\"唱红歌搞定林夕合鸟女士\"); &#125; public static void print() &#123; System.out.println(\"Fu print\"); &#125;&#125;class DayOne extends 双桨 &#123; public void 泡妞() &#123; System.out.println(\"霸王硬上弓\"); &#125; public static void print() &#123; //静态只能覆盖静态,其实不算重写,多态时候详细讲解 System.out.println(\"Zi print\"); &#125;&#125; 面向对象(方法重写的练习题) 方法重写的练习题 Override和Overload的区别?Overload能改变返回值类型吗? overload可以改变返回值类型,只看参数列表 方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的 方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 子类对象调用方法的时候： 先找子类本身，再找父类。 使用继承前的学生和老师案例 案例演示 使用继承前的学生和老师案例 属性:姓名,年龄 行为:吃饭 老师有特有的方法:讲课 学生有特有的方法:学习 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Test3_Person &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125;class Student &#123; private String name; //姓名 private int age; //年龄 public Student() &#123;&#125; //空参构造 public Student(String name,int age) &#123; //有参构造 this.name = name; this.age = age; &#125; public void setName(String name) &#123; //设置姓名 this.name = name; &#125; public String getName() &#123; //获取姓名 return name; &#125; public void setAge(int age) &#123; //设置年龄 this.age = age; &#125; public int getAge() &#123; //获取年龄 return age; &#125; public void eat() &#123; //吃饭 System.out.println(\"学生吃饭\"); &#125; public void study() &#123; //学习 System.out.println(\"学生学习\"); &#125;&#125;class Teacher &#123; private String name; //姓名 private int age; //年龄 public Teacher() &#123;&#125; //空参构造 public Teacher(String name,int age) &#123; //有参构造 this.name = name; this.age = age; &#125; public void setName(String name) &#123; //设置姓名 this.name = name; &#125; public String getName() &#123; //获取姓名 return name; &#125; public void setAge(int age) &#123; //设置年龄 this.age = age; &#125; public int getAge() &#123; //获取年龄 return age; &#125; public void eat() &#123; //吃饭 System.out.println(\"老师吃饭\"); &#125; public void teach() &#123; //学习 System.out.println(\"老师讲课\"); &#125;&#125; 使用继承后的学生和老师案例 使用继承后的学生和老师案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Test4_Person &#123; public static void main(String[] args) &#123; Student s1 = new Student(); s1.setName(\"张三\"); s1.setAge(23); System.out.println(s1.getName() + \"...\" + s1.getAge()); s1.eat(); s1.study(); System.out.println(\"------------------\"); Student s2 = new Student(\"李四\",24); System.out.println(s2.getName() + \"...\" + s2.getAge()); s2.eat(); s2.study(); &#125;&#125;/** 使用继承后的学生和老师案例 */class Person &#123; private String name; //姓名 private int age; //年龄 public Person() &#123;&#125; //空参构造 public Person(String name,int age) &#123; //有参构造 this.name = name; this.age = age; &#125; public void setName(String name) &#123; //设置姓名 this.name = name; &#125; public String getName() &#123; //获取姓名 return name; &#125; public void setAge(int age) &#123; //设置年龄 this.age = age; &#125; public int getAge() &#123; //获取年龄 return age; &#125; public void eat() &#123; //吃饭 System.out.println(name + \"吃饭\"); &#125;&#125;class Student extends Person &#123; public Student() &#123;&#125; //空参构造 public Student(String name,int age) &#123; super(name,age); &#125; public void study() &#123; System.out.println(this.getName() + \"学习\"); &#125;&#125;class Teacher extends Person &#123; public Teacher() &#123;&#125; //空参构造 public Teacher(String name,int age) &#123; super(name,age); &#125; public void teach() &#123; System.out.println(this.getName() + \"讲课\"); &#125;&#125; 猫狗案例分析,实现及测试 猫狗案例分析 案例演示 猫狗案例继承版 属性:毛的颜色,腿的个数 行为:吃饭 猫特有行为:抓老鼠catchMouse 狗特有行为:看家lookHome 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Test5_Animal &#123; public static void main(String[] args) &#123; Cat c1 = new Cat(\"花\",4); System.out.println(c1.getColor() + \"...\" + c1.getLeg()); c1.eat(); c1.catchMouse(); Dog d1 = new Dog(\"黑\",2); System.out.println(d1.getColor() + \"...\" + d1.getLeg()); d1.eat(); d1.lookHome(); &#125;&#125;class Animal &#123; private String color; //毛的颜色 private int leg; //腿的个数 public Animal()&#123;&#125; public Animal(String color,int leg) &#123; this.color = color; this.leg = leg; &#125; public void setColor(String color) &#123; //设置颜色 this.color = color; &#125; public String getColor() &#123; //获取颜色 return color; &#125; public void setLeg(int leg) &#123; //设置腿的个数 this.leg = leg; &#125; public int getLeg() &#123; //获取腿的个数 return leg; &#125; public void eat() &#123; //吃饭 System.out.println(\"吃饭\"); &#125;&#125;class Cat extends Animal &#123; public Cat() &#123;&#125; //空参构造 public Cat(String color,int leg) &#123; //有参构造 super(color,leg); &#125; public void eat() &#123; //吃鱼 System.out.println(\"猫吃鱼\"); &#125; public void catchMouse() &#123; //抓老鼠 System.out.println(\"抓老鼠\"); &#125;&#125;class Dog extends Animal &#123; public Dog() &#123;&#125; //空参构造 public Dog(String color,int leg) &#123; //有参构造 super(color,leg); &#125; public void eat() &#123; //吃肉 System.out.println(\"狗吃肉\"); &#125; public void lookHome() &#123; //看家 System.out.println(\"看家\"); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE之面向对象 - 代码块","date":"2013-07-04T16:00:00.000Z","path":"2013/07/05/2013-07-05-object-dmk/","text":"JavaSE之面向对象 - 代码块 代码块的概述和分类 代码块概述 在Java中，使用{}括起来的代码被称为代码块。 代码块分类 根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。 常见代码块的应用 局部代码块 在方法中出现；限定变量生命周期，及早释放，提高内存利用率 构造代码块 (初始化块) 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 静态代码块 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Demo1_Code &#123; public static void main(String[] args) &#123; &#123; int x = 10; //限定变量的声明周期 System.out.println(x); &#125; Student s1 = new Student(); System.out.println(\"---------------\"); Student s2 = new Student(\"张三\",23); &#125; static &#123; System.out.println(\"我是在主方法类中的静态代码块\"); &#125;&#125;class Student &#123; private String name; private int age; public Student()&#123; //study(); System.out.println(\"空参构造\"); &#125; //空参构造 public Student(String name,int age) &#123;//有参构造 //study(); this.name = name; this.age = age; System.out.println(\"有参构造\"); &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; &#123; //构造代码块:每创建一次对象就会执行一次,优先于构造函数执行 //System.out.println(\"构造代码块\"); study(); &#125; public void study() &#123; System.out.println(\"学生学习\"); &#125; static &#123; //随着类加载而加载,且只执行一次 System.out.println(\"我是静态代码块\"); //作用:用来给类进行初始化,一般用来加载驱动 &#125; //静态代码块是优先于主方法执行&#125; 代码块的面试题 看程序写结果 1234567891011121314151617181920212223242526class Student &#123; static &#123; System.out.println(\"Student 静态代码块\"); &#125; &#123; System.out.println(\"Student 构造代码块\"); &#125; public Student() &#123; System.out.println(\"Student 构造方法\"); &#125;&#125;class Demo2_Student &#123; static &#123; System.out.println(\"Demo2_Student静态代码块\"); &#125; public static void main(String[] args) &#123; System.out.println(\"我是main方法\"); Student s1 = new Student(); Student s2 = new Student(); &#125;&#125; 顺序 Demo2_Student静态代码块 我是main方法 Student 静态代码块 Student 构造代码块 Student 构造方法 Student 构造代码块 Student 构造方法","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"static详解","date":"2013-07-02T16:00:00.000Z","path":"2013/07/03/2013-07-03-javase-obj-static-jvm/","text":"不知道说什么 static关键字及内存图 代码演示 通过一个案例引入static关键字。 人类：Person。每个人都有国籍，中国。 1234567891011121314151617181920212223class Demo1_Static &#123; public static void main(String[] args) &#123; Person p1 = new Person();//创建对象 p1.name = \"苍老师\";//调用姓名属性并赋值 p1.country = \"日本\";//调用国籍属性并赋值 Person p2 = new Person(); p2.name = \"小泽老师\";//调用姓名属性并赋值 //p2.country = \"日本\";//调用国籍属性并赋值 p1.speak(); p2.speak(); &#125;&#125;class Person &#123; String name;//姓名 static String country;//国籍 public void speak() &#123;//说话的方法 System.out.println(name + \"...\" + country); &#125;&#125; 画图演示带有static的内存图 static关键字的特点 static关键字的特点 随着类的加载而加载 优先于对象存在 被类的所有对象共享 举例：咱们班级的学生应该共用同一个班级编号。 其实这个特点也是在告诉我们什么时候使用静态? 如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。 举例： 饮水机(用静态修饰) 水杯(不能用静态修饰) 共性用静态,特性用非静态 可以通过类名调用 其实它本身也可以通过对象名调用。 推荐使用类名调用。 静态修饰的内容一般我们称其为：与类相关的，类成员 案例演示static关键字的特点 12Person.country = \"日本\"; //静态多了一种调用方式,可以通过类名.System.out.println(Person.country); static的注意事项 static的注意事项 在静态方法中是没有this关键字的如何理解呢? 静态是随着类的加载而加载，this是随着对象的创建而存在。 静态比对象先存在。 静态方法只能访问静态的成员变量和静态的成员方法 静态方法： 成员变量：只能访问静态变量 成员方法：只能访问静态成员方法 非静态方法： 成员变量：可以是静态的，也可以是非静态的 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。 简单记：静态只能访问静态。 案例演示static的注意事项 1234567891011121314151617181920212223class Demo2_Static &#123; public static void main(String[] args) &#123; //Demo d = new Demo(); //d.print1(); Demo.print2(); &#125;&#125;class Demo &#123; int num1 = 10;//非静态的成员变量 static int num2 = 20;//静态的成员变量 /*public void print1() &#123;//非静态的成员方法,既可以访问静态的成员也可以访问非静态的 System.out.println(num1); System.out.println(num2); &#125;*/ public static void print2() &#123;//静态的成员方法 //System.out.println(this.num1);//静态的成员方法不能访问非静态的,错误: 无法从静态上下文中引用非静态 变量 num1 System.out.println(num2); &#125;&#125; 静态变量和成员变量的区别 静态变量也叫类变量 成员变量也叫对象变量 所属不同 静态变量属于类，所以也称为为类变量 成员变量属于对象，所以也称为实例变量(对象变量) 内存中位置不同 静态变量存储于方法区的静态区 成员变量存储于堆内存 内存出现时间不同 静态变量随着类的加载而加载，随着类的消失而消失 成员变量随着对象的创建而存在，随着对象的消失而消失 调用不同 静态变量可以通过类名调用，也可以通过对象调用 成员变量只能通过对 象名调用 main方法的格式详细解释 格式 1public static void main(String[] args) &#123;&#125; 针对格式的解释 public 被jvm调用，访问权限足够大。 static 被jvm调用，不用创建对象，直接类名访问 void被jvm调用，不需要给jvm返回值 main 一个通用的名称，虽然不是关键字，但是被jvm识别 String[] args 以前用于接收键盘录入的 演示案例 通过args接收键盘例如数据 12345678class Demo_Main &#123; public static void main(String[] args) &#123; System.out.println(args.length); for (int i = 0;i &lt; args.length ;i++ ) &#123; System.out.println(args[i]); &#125; &#125;&#125; 开打cmd窗口,编译此文件输入1java Demo_Main haha xx heihh 将会输出 123hahaxxheihh 工具类中使用静态 制作一个工具类ArrayTool 获取最大值 数组的遍历 数组的反转 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/**这是一个数组工具类,里面封装了查找数组最大值,打印数组,数组反转的方法@author wxhao@version v1.0*/public class ArrayTool &#123; //如果一个类中所有的方法都是静态的,需要再多做一步,私有构造方法,目的是不让其他类创建本类对象 //直接用类名.调用即可 /** 私有构造方法 */ private ArrayTool()&#123;&#125; //1,获取最大值 /** 这是获取数组中最大值的方法 @param arr 接收一个int类型数组 @return 返回数组中最大值 */ public static int getMax(int[] arr) &#123; int max = arr[0]; //记录第一个元素 for (int i = 1;i &lt; arr.length ;i++ ) &#123;//从第二个元素开始遍历 if (max &lt; arr[i]) &#123;//max与数组中其他的元素比较 max = arr[i];//记录住较大的 &#125; &#125; return max; //将最大值返回 &#125; //2,数组的遍历 /** 这是遍历数组的方法 @param arr 接收一个int类型数组 */ public static void print(int[] arr) &#123; for (int i = 0;i &lt; arr.length ;i++ ) &#123;//遍历数组 System.out.print(arr[i] + \" \"); &#125; &#125; //3,数组的反转 /** 这是数组反转的方法 @param arr 接收一个int类型数组 */ public static void revArray(int[] arr) &#123; for (int i = 0;i &lt; arr.length / 2 ;i++ ) &#123;//循环次数是元素个数的一半 /* arr[0]与arr[arr.length-1-0] 交换 arr[1]与arr[arr.length-1-1] 交换 arr[2]与arr[arr.length-1-2] 交换 */ int temp = arr[i]; arr[i] = arr[arr.length-1-i]; arr[arr.length-1-i] = temp; &#125; &#125;&#125; 说明书的制作过程 对工具类加入文档注释 通过javadoc命令生成说明书 @author(提取作者内容) @version(提取版本内容) javadoc -d 指定的文件目录 -author -version ArrayTool.java @param 参数名称//形式参数的变量名称@return 函数运行完返回的数据 开打cmd窗口,输入 1javadoc -d api -version -author ArrayTool.java 类要是public,将会生产对应文档目录,点击index.html 如何使用JDK提供的帮助文档 找到文档，打开文档 点击显示，找到索引，出现输入框 你应该知道你找谁?举例：Scanner 看这个类的结构(需不需要导包)成员变量 字段 构造方法构造方法 成员方法方法 JDK1.6中文版 百度云链接 学习Math类的随机数功能 打开JDK提供的帮助文档学习 Math类概述类包含用于执行基本数学运算的方法 Math类特点 由于Math类在java.lang包下，所以不需要导包。 因为它的成员全部是静态的,所以私有了构造方法 获取随机数的方法public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 我要获取一个1-100之间的随机数，肿么办?int number = (int)(Math.random()*100)+1; 123456789101112131415161718192021class Demo2_Math &#123; public static void main(String[] args) &#123; //double d = Math.random(); //System.out.println(d); //Math.random()会生成大于等于0.0并且小于1.0的伪随机数 for (int i = 0;i &lt; 10 ;i++ ) &#123; System.out.println(Math.random()); &#125; //生成1-100的随机数 //Math.random()0.0000000 - 0.999999999 //Math.random() * 100 ====&gt; 0.00000 - 99.999999999 //(int)(Math.random() * 100) ====&gt; 0 - 99 //(int)(Math.random() * 100) + 1 for (int i = 0;i &lt; 10 ;i++ ) &#123; System.out.println((int)(Math.random() * 100) + 1); &#125; &#125;&#125; 猜数字小游戏案例 案例演示需求：猜数字小游戏(数据在1-100之间) 12345678910111213141516171819import java.util.Scanner;class Test_GuessNum &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in);//创建键盘录入对象 System.out.println(\"请输入一个整数,范围在1-100之间\"); int guessNum = (int)(Math.random() * 100) + 1;//心里想的随机数 while (true) &#123; //因为需要猜很多次,所以用无限循环 int result = sc.nextInt();//大家猜的数 if (result &gt; guessNum) &#123;//如果你们猜的数大于了我心里想的数 System.out.println(\"大了\");//提示大了 &#125; else if (result &lt; guessNum) &#123; //如果你们猜的数小于了我心里想的数 System.out.println(\"小了\");//提示小了 &#125; else &#123;//如果既不大也不小 System.out.println(\"中了\");//中了 break; &#125; &#125; &#125;&#125; static方法本类调用12345678910111213141516class Demo_Static &#123; public static void main(String[] args) &#123; //method();//错误: 无法从静态上下文中引用非静态 方法 method() Demo3_Static.print();//在主方法中调用本类的静态方法,可以省略类名.,系统会默认加上 Demo3_Static d = new Demo3_Static();//非静态方法在调用的时候必须创建对象调用 d.method(); &#125; public void method() &#123; System.out.println(\"Hello World!\"); &#125; public static void print() &#123; System.out.println(\"Hello World!\"); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"构造方法和面向对象练习","date":"2013-06-30T16:00:00.000Z","path":"2013/07/01/2013-07-01-javase-obj-constructor/","text":"不知道说什么 构造方法Constructor概述和格式 构造方法概述和作用给对象的数据(属性)进行初始化 构造方法格式特点 :方法名与类名相同(大小也要与类名一致) 没有返回值类型，连void都没有 没有具体的返回值return; 1234567891011121314151617181920212223242526272829//Constructor构造class Demo1_Constructor &#123; public static void main(String[] args) &#123; //在一创建对象的时候,系统就帮我调用了构造方法 Person p = new Person(); //p.Person();//构造方法不能用对象调用 p.show(); //再次创建对象 Person p2 = new Person(); p2.show(); &#125;&#125;class Person &#123; private String name; private int age; //构造方法 public Person() &#123; //System.out.println(\"Hello World!\"); //return;//构造方法也是有return语句的,格式是return; name = \"张三\"; age = 23; &#125; public void show() &#123; System.out.println(name + \"...\" + age); &#125;&#125; 构造方法的重载及注意事项 案例演示 构造方法的重载 重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表 构造方法注意事项 如果我们没有给出构造方法，系统将自动提供一个无参构造方法。 如果我们给出了构造方法，系统将不再提供默认的无参构造方法。注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法 1234567891011121314151617181920212223242526272829303132333435class Demo2_Person &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.show(); System.out.println(\"---------------------\"); Person p2 = new Person(\"张三\",23); p2.show(); System.out.println(\"---------------------\"); Person p3 = new Person(\"李四\",24); p3.show(); &#125;&#125;class Person &#123; private String name;//姓名 private int age;//年龄 public Person() &#123;//空参构造 System.out.println(\"空参的构造\"); &#125; public Person(String name,int age) &#123; this.name = name; this.age = age; System.out.println(\"有参的构造\"); &#125; public void show() &#123; System.out.println(name + \"...\" + age); &#125;&#125; 给成员变量赋值的两种方式的区别 setXxx()方法修改属性值 构造方法给对象中属性进行初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Demo3_Person &#123; public static void main(String[] args) &#123; Person p1 = new Person(\"张三\",23); //p1 = new Person(\"张天一\",23); //这种方式看运行结果貌似是改名了,其实是将原对象变成垃圾 System.out.println(p1.getName() + \"...\" + p1.getAge()); System.out.println(\"--------------------\"); Person p2 = new Person();//空参构造创建对象 p2.setName(\"李四\"); p2.setAge(24); p2.setName(\"李鬼\"); System.out.println(p2.getName() + \"...\" + p2.getAge()); &#125;&#125;/*构造方法 给属性进行初始化setXxx方法 修改属性值 这两种方式,在开发中用setXxx更多一些,因为比较灵活*/class Person &#123; private String name;//姓名 private int age; //年龄 public Person() &#123; //空参构造 &#125; //有参构造 public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; //设置姓名 public void setName(String name) &#123; this.name = name; &#125; //获取姓名 public String getName() &#123; return name; &#125; //设置年龄 public void setAge(int age) &#123; this.age = age; &#125; //获取年龄 public int getAge() &#123; return age; &#125;&#125; 学生类的代码及测试 案例演示 学生类： 成员变量： name，age 构造方法： 无参，带两个参 成员方法： getXxx()/setXxx() show()：输出该类的所有成员变量值 给成员变量赋值： a:setXxx()方法 b:构造方法 输出成员变量值的方式： 通过getXxx()分别获取然后拼接 通过调用show()方法搞定 123456789101112131415161718192021222324252627282930313233class Student &#123; //姓名 private String name; //年龄 private int age; //空参构造 public Student()&#123;&#125; //有参构造 public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; //设置姓名 public void setName(String name) &#123; this.name = name; &#125; //获取姓名 public String getName() &#123; return name; &#125; //设置年龄 public void setAge(int age) &#123; this.age = age; &#125; //获取年龄 public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println(\"我的姓名是:\" + name + \",我的年龄是:\" + age); &#125;&#125; 手机类的代码及测试 案例演示模仿学生类，完成手机类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Demo5_Phone &#123; public static void main(String[] args) &#123; Phone p1 = new Phone(); p1.setBrand(\"苹果\"); p1.setPrice(1500); System.out.println(p1.getBrand() + \"...\" + p1.getPrice()); Phone p2 = new Phone(\"小米\",98); p2.show(); &#125;&#125;/*手机类: 成员变量: 品牌brand,价格price 构造方法 无参,有参 成员方法 setXxx和getXxx show*/class Phone &#123; //品牌 private String brand; //价格 private int price; //空参构造 public Phone()&#123;&#125; //有参构造 public Phone(String brand,int price) &#123; this.brand = brand; this.price = price; &#125; //设置品牌 public void setBrand(String brand) &#123; this.brand = brand; &#125; //获取品牌 public String getBrand() &#123; return brand; &#125; //设置价格 public void setPrice(int price) &#123; this.price = price; &#125; //获取价格 public int getPrice() &#123; return price; &#125; public void show() &#123; System.out.println(brand + \"...\" + price); &#125;&#125; 创建一个对象的步骤 画图演示 画图说明一个对象的创建过程做了哪些事情? Student s = new Student(); Student.class加载进内存 声明一个Student类型引用s 在堆内存创建对象, 给对象中属性默认初始化值 属性进行显示初始化 构造方法进栈,对对象中的属性赋值,构造方法弹栈 将对象的地址值赋值给s 1234567891011121314151617181920class Demo1_Student &#123; public static void main(String[] args) &#123; Student s = new Student(); s.show(); &#125;&#125;class Student &#123; private String name = \"张三\"; private int age = 23; public Student() &#123; name = \"李四\"; age = 24; &#125; public void show() &#123; System.out.println(name + \"...\" + age); &#125;&#125; 长方形案例练习 案例演示 需求： 定义一个长方形类,定义 求周长和面积的方法， 然后定义一个测试类进行测试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Test1_Rectangle &#123; //Rectangle矩形 public static void main(String[] args) &#123; Rectangle r = new Rectangle(10,20); System.out.println(r.getLength());//周长 System.out.println(r.getArea());//面积 &#125;&#125;/** 成员变量: 宽width,高high 空参有参构造 成员方法: setXxx和getXxx 求周长:getLength() 求面积:getArea()*/class Rectangle &#123; private int width;//宽 private int high;//高 //空参构造 public Rectangle()&#123;&#125; //有参构造 public Rectangle(int width,int high) &#123; this.width = width; this.high = high; &#125; //设置宽 public void setWidth(int width) &#123; this.width = width; &#125; //获取宽 public int getWidth() &#123; return width; &#125; //设置高 public void setHigh(int high) &#123; this.high = high; &#125; //获取高 public int getHigh() &#123; return high; &#125; //获取周长 public int getLength() &#123; return 2 * (width + high); &#125; //获取面积 public int getArea() &#123; return width * high; &#125;&#125; 员工类案例练习 案例演示 需求：定义一个员工类Employee 自己分析出几个成员，然后给出成员变量 姓名name,工号id,工资salary 构造方法， 空参和有参的 getXxx()setXxx()方法， 以及一个显示所有成员信息的方法。并测试。 work 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Test2_Employee &#123;//employee员工 public static void main(String[] args) &#123; Employee e = new Employee(\"令狐冲\",\"9527\",20000); e.work(); &#125;&#125;class Employee &#123; private String name;//姓名 private String id; //工号 private double salary;//工资 public Employee() &#123;&#125;//空参构造 //有参构造 public Employee(String name, String id, double salary) &#123; this.name = name; this.id = id; this.salary = salary; &#125; //设置姓名 public void setName(String name) &#123; this.name = name; &#125; //获取姓名 public String getName() &#123; return name; &#125; //设置id public void setId(String id) &#123; this.id = id; &#125; //获取id public String getId() &#123; return id; &#125; //设置工资 public void setSalary(double salary) &#123; this.salary = salary; &#125; //获取工资 public double getSalary() &#123; return salary; &#125; public void work() &#123; System.out.println(\"我的姓名是:\" + name + \",我的工号是:\" + id + \",我的工资是:\" + salary + \",我的工作内容是敲代码\"); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"面向对象的特点及其使用","date":"2013-06-27T16:00:00.000Z","path":"2013/06/28/2013-06-28-javase-obj-special-jvm/","text":"不知道说什么 方法的形式参数是类名的时候如何调用 方法的参数是类名 1public void print(Student s)&#123;&#125;//print(new Student()); 如果你看到了一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。 12345678910111213141516171819202122232425262728class Demo1_Student &#123; public static void main(String[] args) &#123; print(10); //创建对象,并将对象的地址值赋值给s Student s = new Student(); print(s); &#125; //基本数据类型当作形式参数 public static void print(int x) &#123; System.out.println(x); &#125; //引用数据类型当作形式参数 public static void print(Student stu) &#123; stu.name = \"张三\"; stu.age = 23; stu.speak(); &#125;&#125;class Student &#123; String name;//姓名 int age;//年龄 public void speak() &#123; System.out.println(name + \"...\" + age); &#125;&#125; 匿名对象的概述和应用 什么是匿名对象没有名字的对象 匿名对象应用场景 调用方法，仅仅只调用一次的时候。那么，这种匿名调用有什么好处吗? 节省代码 注意：调用多次的时候，不适合。匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。 匿名对象可以作为实际参数传递 案例演示匿名对象应用场景 1234567891011121314151617181920212223242526272829class Demo2_Car &#123; public static void main(String[] args) &#123; //创建有名字的对象 /*Car c1 = new Car(); c1.run(); c1.run(); //匿名对象调用方法 new Car().run(); new Car().run(); */ //匿名对象只适合对方法的一次调用,因为调用多次就会产生多个对象,不如用有名字的对象 //匿名对象是否可以调用属性并赋值?有什么意义? /* 匿名对象可以调用属性,但是没有意义,因为调用后就变成垃圾 如果需要赋值还是用有名字对象 */ new Car().color = \"red\"; new Car().num = 8; new Car().run(); &#125;&#125;class Car &#123; String color;//颜色 int num;//轮胎数 public void run() &#123; System.out.println(color + \"...\" + num); &#125;&#125; 12345678910111213141516171819202122232425262728293031class Demo3_Car &#123; public static void main(String[] args) &#123; //Car c1 = new Car(); /*c1.color = \"red\"; c1.num = 8; c1.run();*/ //method(c1); method(new Car()); //Car c2 = new Car(); //method(c2); method(new Car());//匿名对象可以当作参数传递 &#125; //抽取方法提高代码的复用性 public static void method(Car cc) &#123; //Car cc = new Car(); cc.color = \"red\"; cc.num = 8; cc.run(); &#125;&#125;class Car &#123; String color;//颜色 int num; //轮胎数 public void run() &#123; System.out.println(color + \"...\" + num); &#125;&#125; 封装的概述 封装概述是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。 封装好处 隐藏实现细节，提供公共的访问方式 提高了代码的复用性 提高安全性。 封装原则 将不需要对外提供的内容都隐藏起来。 把属性隐藏，提供公共方法对其访问。 private关键字的概述和特点 人类赋值年龄的问题 private关键字特点 是一个权限修饰符 可以修饰成员变量和成员方法 被其修饰的成员只能在本类中被访问 案例演示 封装和private的应用： 把成员变量用private修饰 提供对应的getXxx()和setXxx()方法 private仅仅是封装的一种体现形式,不能说封装就是私有 1234567891011121314151617181920212223242526272829303132333435//年龄不能为负数,可是测试类不能保证都是正数,所以不安全class Demo1_Person &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.name = \"张三\"; //调用姓名属性并赋值 //p1.age = -17; //调用年龄属性并赋值 //p1.speak(); //调用行为 p1.setAge(-17); System.out.println(p1.getAge()); &#125;&#125;class Person &#123; String name; //姓名 private int age;//年龄 public void setAge(int a) &#123; //设置年龄 if (a &gt; 0 &amp;&amp; a &lt; 200) &#123; age = a; &#125;else &#123; System.out.println(\"请回火星吧,地球不适合你\"); &#125; &#125; public int getAge() &#123; //获取年龄 return age; &#125; public void speak() &#123; System.out.println(name + \"...\" + age); &#125;&#125; this关键字的概述和应用 this关键字特点代表当前对象的引用 代码演示 this的应用场景 用来区分成员变量和局部变量重名 1234567891011121314151617181920212223242526272829303132333435363738394041class Demo1_This &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.setName(\"张三\"); p1.setAge(23); System.out.println(p1.getName() + \"...\" + p1.getAge()); Person p2 = new Person(); p2.setName(\"李四\"); p2.setAge(24); System.out.println(p2.getName() + \"...\" + p2.getAge()); &#125;&#125;class Person &#123; private String name;//姓名 private int age; //年龄 public void setAge(int age) &#123;//设置年龄 if (age &gt; 0 &amp;&amp; age &lt; 200) &#123; this.age = age; //System.out.println(age); &#125;else &#123; System.out.println(\"请回火星吧,地球不适合你\"); &#125; &#125; public int getAge() &#123;//获取年龄 return age; &#125; public void setName(String name) &#123;//设置姓名 this.name = name; //System.out.println(name); &#125; public String getName() &#123; return name; &#125;&#125; this关键字用来规避就近原则 手机类代码及其测试 练习请把手机类写成一个标准类，然后创建对象测试功能。 123手机类 属性:品牌brand,价格price 行为:打电话call,发短信sendMessage,玩游戏,playGame 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Demo2_Phone &#123; public static void main(String[] args) &#123; Phone p1 = new Phone(); p1.setBrand(\"三星\"); p1.setPrice(5288); System.out.println(p1.getBrand() + \"...\" + p1.getPrice()); p1.call(); p1.sendMessage(); p1.playGame(); &#125;&#125;class Phone &#123; //java bean private String brand;//品牌 private int price; //价格 //设置品牌 public void setBrand(String brand) &#123; this.brand = brand; &#125; //获取品牌 public String getBrand() &#123; //this.可以省略,你不加系统会默认给你加 return this.brand; &#125; //设置价格 public void setPrice(int price) &#123; this.price = price; &#125; //获取价格 public int getPrice() &#123; return price; &#125; //打电话 public void call() &#123; System.out.println(\"打电话\"); &#125; //发短信 public void sendMessage() &#123; System.out.println(\"发短信\"); &#125; //玩游戏 public void playGame() &#123; System.out.println(\"玩游戏\"); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"面向对象思想及其内存分配","date":"2013-06-25T16:00:00.000Z","path":"2013/06/26/2013-06-26-javase-obj-jvm/","text":"不知道说什么 面向对象思想概述 面向过程思想概述 第一步 第二步 面向对象思想概述找对象(第一步,第二步)*:举例 买煎饼果子 洗衣服 面向对象思想特点 是一种更符合我们思想习惯的思想 可以将复杂的事情简单化 将我们从执行者变成了指挥者角色发生了转换 面向对象开发就是不断的创建对象，使用对象，指挥对象做事情。 面向对象设计其实就是在管理和维护对象之间的关系。 面向对象特征 封装(encapsulation) 继承(inheritance) 多态(polymorphism) 类与对象概述 我们学习编程是为了什么为了把我们日常生活中实物用学习语言描述出来 我们如何描述现实世界事物属性 就是该事物的描述信息(事物身上的名词) 行为就是该事物能够做什么(事物身上的动词) Java中最基本的单位是类,Java中用class描述事物也是如此成员变量 就是事物的属性 成员方法就是事物的行为*:定义类其实就是定义类的成员(成员变量和成员方法)成员变量 和以前定义变量是一样的，只不过位置发生了改变。在类中，方法外。 成员方法和以前定义方法是一样的，只不过把static去掉，后面在详细讲解static的作用。 类和对象的概念 类：是一组相关的属性和行为的集合 对象：是该类事物的具体体现 举例： 类 学生对象具体的某个学生就是一个对象 学生类的定义 学生事物 学生类 代码演示 属性:姓名,年龄,性别 行为:学习,睡觉 12345678910111213class Student &#123; String name; //姓名 int age; //年龄 String gender; //性别 //定义学习的方法 public void study() &#123; System.out.println(\"学生学习\"); &#125; //定义睡觉的方法 public void sleep() &#123; System.out.println(\"学生睡觉\"); &#125;&#125; 手机类的定义 模仿学生类，让学生自己完成 属性:品牌(brand)价格(price) 行为:打电话(call),发信息(sendMessage)玩游戏(playGame) 12345678910111213141516class Phone &#123; String brand; //品牌 int price; //价格 public void call() &#123;//打电话 System.out.println(\"打电话\"); &#125; public void sendMessage() &#123; //发信息 System.out.println(\"发信息\"); &#125; public void playGame() &#123;//玩游戏 System.out.println(\"玩游戏\"); &#125;&#125; 学生类的使用 文件名问题 在一个java文件中写两个类：一个基本的类，一个测试类。 建议：文件名称和测试类名称一致。 如何使用对象? 创建对象并使用 格式：类名 对象名 = new 类名(); 如何使用成员变量呢? 对象名.变量名 如何使用成员方法呢? 对象名.方法名(…) 1234567891011121314151617class Demo_Student &#123;//测试类 public static void main(String[] args) &#123; //创建对象的格式:类名 对象名 = new 类名(); //对象名:其实就是合法的标识符,如果是一个单词所有字母小写,如果是多个单词,从第二个单词开始首字母大写 Student s = new Student(); //* D:如何使用成员变量呢? //* 对象名.变量名 s.name = \"张三\"; s.age = 23; System.out.println(s.name + \"...\" + s.age); //* E:如何使用成员方法呢? //* 对象名.方法名(...) s.study(); s.sleep(); &#125;&#125; 手机类的使用 学生自己完成模仿学生类，让学生自己完成 12345678910111213141516class Demo_Phone &#123;//测试类 public static void main(String[] args) &#123; //创建对象 Phone p = new Phone(); //调用对象中的属性并赋值 p.brand = \"锤子\"; p.price = 998; System.out.println(p.brand + \"...\" + p.price); //调用成员方法 p.call(); p.sendMessage(); p.playGame(); &#125;&#125; 一个对象的内存图 画图演示一个对象 按上节所述,↓java文件应该起名为Demo_Car.java 123456789101112131415161718192021class Demo_Car &#123; public static void main(String[] args) &#123; Car c1 = new Car(); //创建对象 //调用属性并赋值 c1.color = \"red\"; //为车的颜色赋值 c1.num = 8; //为车的轮胎数赋值 //调用行为 c1.run(); &#125;&#125;class Car &#123; //成员变量 String color; //车的颜色 int num; //车的轮胎数 public void run() &#123; //车运行 System.out.println(color + \"...\" + num); &#125;&#125; 二个对象的内存图 画图演示二个不同的对象 在上方main方法中增加如下代码 1234567891011//创建对象Car c2 = new Car(); //为车的颜色赋值c2.color = \"black\"; //为车的轮胎数赋值c2.num = 4; c2.run();//c2 = null;//用null把原来的地址值覆盖掉了 //c2.run(); //c2里面记录的是null,所以报出空指针异常 如果没有任何引用指向该对象,那么该对象就会变成垃圾,java中有完善的垃圾回收机制,会在不定时进行回收 三个引用两个对象的内存图 画图演示三个引用，有两个对象的引用指向同一个地址 在上方main方法中增加如下代码 12Car c3 = c2;c3.run(); 成员变量和局部变量的区别 在类中的位置不同 成员变量：在类中方法外 局部变量：在方法定义中或者方法声明上 在内存中的位置不同 成员变量：在堆内存(成员变量属于对象,对象进堆内存) 局部变量：在栈内存(局部变量属于方法,方法进栈内存) 生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 初始化值不同 成员变量：有默认初始化值 局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。 注意事项： 局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。 基本数据类型变量包括哪些:byte,short,int,long,float,double,boolean,char 引用数据类型变量包括哪些:数组,类,接口,枚举 123456789101112131415161718class Demo2_Person &#123; public static void main(String[] args) &#123; Person p = new Person(); p.speak(); &#125;&#125;class Person &#123; String name; //成员变量 int num; public void speak() &#123; int num = 10;//x和num都是局部变量 System.out.println(name); System.out.println(num); &#125;&#125; 思考题Java中的参数传递问题及图解 案例演示 看程序写结果，并画内存图解释 123456789101112131415161718192021222324252627282930313233/*基本数据类型的值传递,不改变原值,因为调用后就会弹栈,局部变量随之消失引用数据类型的值传递,改变原值,因为即使方法弹栈,但是堆内存数组对象还在,可以通过地址继续访问*/class Test_Array &#123; public static void main(String[] args) &#123; /*int a = 10; int b = 20; System.out.println(\"a:\"+a+\",b:\"+b); //a = 10,b = 20 change(a,b); System.out.println(\"a:\"+a+\",b:\"+b); //?*/ int[] arr = &#123;1,2,3,4,5&#125;; change(arr); System.out.println(arr[1]); &#125; public static void change(int a,int b) &#123;//a = 10, b= 20 System.out.println(\"a:\"+a+\",b:\"+b); //a = 10,b = 20 a = b; //a = 20 b = a + b; //b = 40 System.out.println(\"a:\"+a+\",b:\"+b); //a = 20, b = 40 &#125; public static void change(int[] arr) &#123; //1,4,3,8,5 for(int x=0; x&lt;arr.length; x++) &#123; if(arr[x]%2==0) &#123; arr[x]*=2; &#125; &#125; &#125;&#125; Java中到底是传值还是传址 既是传值,也是传地址,基本数据类型传递的值,引用数据类型传递的地址 java中只有传值,因为地址值也是值(出去面试都说这种,支持者是高斯林(java之父)) java虚拟机详解.docx百度云链接","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"markdown 异常记录","date":"2013-06-23T16:00:00.000Z","path":"2013/06/24/2013-06-24-markdown-exception-cache/","text":"不知道说什么 花括号错误编译 本来想输入下文代码 1int[][] arr = &#123;% raw %&#125;&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;&#125; &#123;% endraw %&#125;; 改成这样,记得把endraw%和}之间的空格去掉 1int[][] arr = &#123;% raw %&#125;&#123;% raw %&#125;&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;&#125;&#123;% endraw % &#125;&#123;% endraw %&#125;;","tags":[{"name":"markdown","slug":"markdown","permalink":"http://wxhaor.me/tags/markdown/"},{"name":"exception","slug":"exception","permalink":"http://wxhaor.me/tags/exception/"},{"name":"jekyll","slug":"jekyll","permalink":"http://wxhaor.me/tags/jekyll/"}]},{"title":"JavaSE - 二维数组及内存分配","date":"2013-06-22T16:00:00.000Z","path":"2013/06/23/2013-06-23-javase-method-array2-jvm/","text":"数组 数组 数组 二维数组概述和格式1的讲解 二维数组概述 二维数组格式1int[][] arr = new int[3][2]; 二维数组格式1的解释 注意事项 以下格式也可以表示二维数组 数据类型 数组名[][] = new 数据类型[m][n]; 数据类型[] 数组名[] = new 数据类型[m][n]; 注意下面定义的区别 12345678int x;//申明变量xint y;//申明变量yint x,y;//申明变量x,yint[] x;//申明一维数组xint[] y[];//申明二维数组xint[] x,y[];//x是一维数组,y是二维数组 案例演示定义二维数组，输出二维数组名称，一维数组名称，一个元素 123456789101112/*这是一个二维数组这个二维数组中有3个一维数组每个一维数组中有2个元素[[I@19bb25a //二维数组的地址值[I@da6bf4 //一维数组的地址值0 //元素值*/System.out.println(arr);//二维数组System.out.println(arr[0]);//二维数组中的第一个一维数组System.out.println(arr[0][0]);//二维数组中的第一个一维数组的第一个元素 二维数组格式 内存图解 画图演示画图讲解上面的二维数组名称，一维数组名称，一个元素的值的问题 123System.out.println(arr); //打印二维数组System.out.println(arr[0]); //打印二维数组中的第一个一维数组System.out.println(arr[0][0]); //打印二维数组中的第一个一维数组中的第一个元素 二维数组格式 讲解及其内存图解 二维数组格式2int[][] arr = new int[3][]; 二维数组格式2的解释 案例演示讲解格式，输出数据，并画内存图 1234567891011int[][] arr = new int[3][];//这是一个二维数组,这个二维数组中有三个一维数组,三个一维数组都没有被赋值System.out.println(arr[0]);System.out.println(arr[1]);System.out.println(arr[2]);arr[0] = new int[3];//第一个一维数组中可以存储三个int值arr[1] = new int[5];//第二个一维数组中可以存储五个int值System.out.println(\"------------------\");System.out.println(arr[0]);System.out.println(arr[1]);System.out.println(arr[2]); 二维数组格式 讲解及其内存图解 二维数组格式3 1int[][] arr = &#123;% raw %&#125;&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;&#125; &#123;% endraw %&#125;; 二维数组格式3的解释 案例演示讲解格式，输出数据，并画内存图 1234int[][] arr = &#123;% raw %&#125;&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;&#125;&#123;% endraw %&#125;; //这是一个二维数组,这个二维数组中每个大括号都代表一个一维数组System.out.println(arr); //[[I@19bb25a,二维数组的地址值System.out.println(arr[0]); //[I@da6bf4,一维数组的地址值System.out.println(arr[0][0]); //1,一维数组中的元素值 二维数组练习 遍历 案例演示 需求：二维数组遍历 外循环控制的是二维数组的长度，其实就是一维数组的个数。 内循环控制的是一维数组的长度。 12345678int[][] arr =&#123;% raw %&#125;&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;&#125;&#123;% endraw %&#125;;for (int i = 0;i &lt; arr.length ;i++ ) &#123;//获取到每个二维数组中的一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) &#123;//获取每个一维数组中的元素 System.out.print(arr[i][j] + \" \"); &#125; System.out.println();&#125; 二维数组练习 求和 案例演示 123456需求：公司年销售额求和某公司按照季度和月份统计的数据如下：单位(万元)第一季度：22,66,44第二季度：77,33,88第三季度：25,45,65第四季度：11,66,99 12345678910int[][] arr = &#123;% raw %&#125;&#123;&#123;22,66,44&#125;,&#123;77,33,88&#125;,&#123;25,45,65&#125;,&#123;11,66,99&#125;&#125;&#123;% endraw %&#125;;int sum = 0;//定义变量,记录每次相加的结果for (int i = 0;i &lt; arr.length ;i++ ) &#123;//获取每一个一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) &#123;//获取每一个一维数组中的元素 sum = sum + arr[i][j];//累加 &#125;&#125;System.out.println(sum);","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - 数组及其循环和内存分配","date":"2013-06-21T16:00:00.000Z","path":"2013/06/22/2013-06-22-javase-method-array-jvm/","text":"数组 数组 数组 数组概述和定义格式说明 为什么要有数组(容器) 为了存储同种数据类型的多个值 数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。 数组定义格式数据类型[] 数组名 = new 数据类型[数组的长度]; 1234567891011121314//数据类型[] 数组名 = new 数据类型[数组的长度];int[] arr = new int[5];//可以存储五个int类型的数据/*左边:int:数据类型[]:代表的数组,几个中括号就代表几维数组arr:合法的标识符右边:new:创建新的实体或对象int:数据类型[]:代表的数组5:代表数组的长度 数组的初始化动态初始化 什么是数组的初始化就是为数组开辟连续的内存空间，并为每个数组元素赋予值 如何对数组进行初始化 动态初始化 只指定长度，由系统给出初始化值 int[] arr = new int[5]; 静态初始化 给出初始化值，由系统决定长度 动态初始化的格式：数据类型[] 数组名 = new 数据类型[数组长度]; 代码演示输出数组名称和数组元素 1234567int[] arr = new int[5];//动态初始化,在内存中开辟连续的5块空间System.out.println(arr[0]);//系统给出默认初始化值,整数类型的都是0arr[0] = 10;System.out.println(arr[0]); System.out.println(arr);//[I@19bb25a 整数类型:byte,short,int,long默认初始化值都是0 浮点类型:float,double默认初始化值都是0.0 布尔类型:boolean默认初始化值false 字符类型:char默认初始化值’\\u0000’ char在内存中占的两个字节,是16个二进制位 \\u0000,每一个0其实代表的是16进制的0,那么四个0就是代表16个二进制位 [I@19bb25a的意思 [代表是数组,几个就代表几维 I代表是int类型 @是固定的 19bb25a代表的是数组的地址值 Java中的内存分配以及栈和堆的区别 栈 存储局部变量局部变量:定义在方法声明上和方法中的变量 堆存储new出来的数组或对象 方法区面向对象部分讲解 本地方法区 和系统相关 寄存器 给CPU使用 数组的内存图解 一个数组 画图演示 一个数组 1234567int[] arr = new int[3];//动态初始化,创建3块连续的空间System.out.println(arr);arr[0] = 10;arr[1] = 20;System.out.println(arr[0]);System.out.println(arr[1]); 数组的内存图解 二个数组 画图演示二个不同的数组 123456789101112131415161718int[] arr1 = new int[3];//创建数组,长度为3int[] arr2 = new int[3];//创建数组,长度为3System.out.println(arr1);//打印数组的地址值System.out.println(arr2);arr1[0] = 10;//给第一个数组中第一个元素赋值arr2[1] = 20;//给第二个数组中第二个元素赋值System.out.println(arr1[0]);System.out.println(arr1[1]);System.out.println(arr1[2]);System.out.println(\"--------------------------------------\");System.out.println(arr2[0]);System.out.println(arr2[1]);System.out.println(arr2[2]); 数组的内存图解 三个引用两个数组 画图演示 三个引用，有两个数组的引用指向同一个地址 123456789101112131415161718192021222324252627282930int[] arr1 = new int[3];int[] arr2 = new int[5];int[] arr3 = arr2;System.out.println(arr1);System.out.println(arr2);System.out.println(arr3);arr1[0] = 10;arr1[1] = 20;arr2[1] = 30;arr3[1] = 40;arr3[2] = 50;System.out.println(arr1[0]);System.out.println(arr1[1]);System.out.println(arr1[2]);System.out.println(\"-------------------------------\");System.out.println(arr2[0]);System.out.println(arr2[1]);System.out.println(arr2[2]);System.out.println(arr2[3]);System.out.println(arr2[4]);System.out.println(\"-------------------------------\");System.out.println(arr3[0]);System.out.println(arr3[1]);System.out.println(arr3[2]);System.out.println(arr3[3]);System.out.println(arr3[4]); 数组的初始化静态初始化及内存图 静态初始化的格式： 格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…}; 简化格式： 数据类型[] 数组名 = {元素1,元素2,…}; 案例演示 对数组的解释 输出数组名称和数组元素 画图演示 一个数组 123456789101112//数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,…&#125;;//int[] arr = new int[5]&#123;11,22,33,44,55&#125;; //不允许动静结合int[] arr2 = &#123;11,22,33,44,55&#125;; //静态初始化的简写形式//int[] arr; //声明数组引用//arr = new int[]&#123;11,22,33,44,55&#125;;//int[] arr2;//arr2 = &#123;11,22,33,44,55&#125;; //简写形式声明和赋值在同一行System.out.println(arr2);System.out.println(arr2[4]); 都会默认初始化为0在赋值 数组操作的两个常见小问题越界和空指针 案例演示 ArrayIndexOutOfBoundsException:数组索引越界异常原因：你访问了不存在的索引。 NullPointerException:空指针异常 原因：数组已经不在指向堆内存了。而你还用数组名去访问元素。 int[] arr = {1,2,3}; arr = null; System.out.println(arr[0]); 12345int[] arr = new int[5];//0x0011//System.out.println(arr[-1]);//当访问数组中不存在的索引,会出现索引越界异常arr = null;System.out.println(arr[0]); //当数组引用赋值为null,再去调用数组中的元素就会出现空指针异常 数组的操作 遍历 案例演示 数组遍历：就是依次输出数组中的每一个元素。 数组的属性:arr.length数组的长度 数组的最大索引:arr.length - 1; 123456789101112131415161718192021222324252627282930313233343536class Demo_Array &#123; public static void main(String[] args) &#123; int[] arr = &#123;11,22,33,44,55&#125;; /*System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[3]); System.out.println(arr[4]);*/ for (int i = 0;i &lt; 5 ;i++ ) &#123; System.out.println(arr[i]); &#125; System.out.println(\"---------------\"); //arr.length 代表的是数组的长度 System.out.println(arr.length); for (int i = 0;i &lt; arr.length ;i++ ) &#123; System.out.println(arr[i]); &#125; int[] arr2 = &#123;3,4,5&#125;; print(arr2); &#125; /* 数组的遍历 1,返回值类型void 2,参数列表int[] arr */ public static void print(int[] arr) &#123; for (int i = 0;i &lt; arr.length ;i++ ) &#123; System.out.print(arr[i] + \" \"); &#125; &#125;&#125; 数组的操作 获取最值 案例演示数组获取最值(获取数组中的最大值最小值) 1234567891011121314151617181920212223class Demo_Array &#123; public static void main(String[] args) &#123; int[] arr = &#123;33,77,22,44,55&#125;; int max = getMax(arr); System.out.println(max); &#125; /* 获取数组中最大值 1,返回值类型int 2,参数列表int[] arr */ public static int getMax(int[] arr) &#123; int max = arr[0]; for (int i = 1;i &lt; arr.length ;i++ ) &#123;//从数组的第二个元素开始遍历 if (max &lt; arr[i]) &#123;//如果max记录的值小于的数组中的元素 max = arr[i];//max记录住较大的 &#125; &#125; return max; &#125;&#125; 数组的操作 反转 案例演示 数组元素反转(就是把元素对调) 1234567891011121314151617181920212223242526272829303132333435363738class Demo_Array &#123; public static void main(String[] args) &#123; int[] arr = &#123;11,22,33,44,55&#125;; reverseArray(arr); print(arr); &#125; /* 数组元素反转 1,明确返回值类型void 2,明确参数列表int[] arr */ public static void reverseArray(int[] arr) &#123; for (int i = 0;i &lt; arr.length / 2 ; i++) &#123; //arr[0]和arr[arr.length-1-0]交换 //arr[1]和arr[arr.length-1-1]交换 //arr[2]和arr[arr.lentth-1-2] //... int temp = arr[i]; arr[i] = arr[arr.length-1-i]; arr[arr.length-1-i] = temp; &#125; &#125; /* 数组遍历 1,明确返回值类型void 2,明确参数列表int[] arr */ public static void print(int[] arr) &#123; for (int i = 0;i &lt; arr.length ;i++ ) &#123;//遍历数组中的每一个元素 System.out.print(arr[i] + \" \");//打印在控制台 &#125; &#125;&#125; 数组的操作 查表法 案例演示数组查表法(根据键盘录入索引,查找对应星期) 1234567891011121314151617181920import java.util.Scanner;class Demo_Array &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入对应的星期范围在1-7\"); int week = sc.nextInt(); System.out.println(\"星期\" + getWeek(week)); &#125; /* 根据索引返回对应的星期 1,返回值类型char 2,参数列表int week */ public static char getWeek(int week) &#123; char[] arr = &#123;' ','一','二','三','四','五','六','日'&#125;;//定义了一张星期表 return arr[week];//通过索引获取表中的元素 &#125; 数组的操作 基本查找 案例演示数组元素查找(查找指定元素第一次在数组中出现的索引) 12345678910111213141516171819202122class Demo_Array &#123; public static void main(String[] args) &#123; int[] arr = &#123;11,22,33,44,55,66,77&#125;; int index = getIndex(arr,88); System.out.println(index); &#125; /* 查找元素索引 1,返回值类型int 2,明确参数列表,int[] arr,int value */ public static int getIndex(int[] arr,int value) &#123; for (int i = 0;i &lt; arr.length ;i++ ) &#123;//数组的遍历 if (arr[i] == value) &#123;//如果数组中的元素与查找的元素匹配 return i; &#125; &#125; return -1; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - 方法","date":"2013-06-18T16:00:00.000Z","path":"2013/06/19/java-se/2013-06-19-javase-method-structure/","text":"敲黑板 重点 方法概述和格式说明 A:为什么要有方法 提高代码的复用性 B:什么是方法 完成特定功能的代码块。 C:方法的格式 1234修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) &#123; 方法体语句; return 返回值; &#125; 方法的格式说明 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。方便我们的调用。 参数： 实际参数：就是实际参与运算的。 形式参数；就是方法定义上的，用于接收实际参数的。 参数类型：就是参数的数据类型 参数名：就是变量名 方法体语句：就是完成功能的代码。 return：结束方法的。 返回值：就是功能的结果，由return带给调用者。 方法之求和案例及其调用 如何写一个方法 明确返回值类型 明确参数列表 代码演示 需求：求两个数据之和的案例 123456789101112131415161718192021222324252627282930313233343536373839404142class Test &#123; public static void main(String[] args) &#123; /*int a = 10; int b = 20; int sum = a + b; System.out.println(sum); int c = 30; int d = 40; int sum2 = c + d; System.out.println(sum2);*/ int sum = add(10,20); System.out.println(sum); &#125; /* 求两个整数的和 1,整数的和结果应该还是整数 2,有两个未知内容参与运算 如何写方法 1,明确返回值类型 2,明确参数列表 * 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 * 返回值类型：就是功能结果的数据类型。 * 方法名：符合命名规则即可。方便我们的调用。 * 参数： * 实际参数：就是实际参与运算的。 * 形式参数；就是方法定义上的，用于接收实际参数的。 * 参数类型：就是参数的数据类型 * 参数名：就是变量名 * 方法体语句：就是完成功能的代码。 * return：结束方法的。 * 返回值：就是功能的结果，由return带给调用者。 */ public static int add(int a,int b) &#123;//int a = 10,int b = 20 int sum = a + b; return sum; //如果有返回值必须用return语句带回 &#125; 方法调用图解 12345678910111213141516171819202122class Test &#123; public static void main(String[] args) &#123; int sum = add(10,20);//1.调用add,把 10和20分别传递给a和b //5.讲方法返回值返回给sum System.out.println(sum); //盘子 = 炒菜(地沟油,苏丹红,镉大米,烂白菜); &#125; public static int add(int a,int b) &#123;//2.赋值a=10,b=20 int sum = a + b;//3.执行语句 return sum;//4.通过return 将sum结果返回 &#125;&#125;/* 厨师 有 炒菜功能 盘子 炒菜(油,调料,米,菜) &#123; 炒菜的动作 return 一盘菜; &#125; */ 方法的注意事项 方法调用(有具体返回值) 单独调用,一般来说没有意义，所以不推荐。 输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。 赋值调用,推荐方案。 注意事项 方法不调用不执行 方法与方法是平级关系，不能嵌套定义 方法定义的时候参数之间用逗号隔开 方法调用的时候不用在传递数据类型 如果方法有明确的返回值，一定要有return带回一个值 12add(30,40);//有返回值方法的单独调用,没有意义System.out.println(add(30,40));//这样调用是可以,but如果需要用这个结果不推荐这样调用 方法的练习 需求A：键盘录入两个数据，返回两个数中的较大值 需求B：键盘录入两个数据，比较两个数是否相等 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;class Test &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in);//创建键盘录入对象 System.out.println(\"请输入第一个整数:\"); int x = sc.nextInt();//将键盘录入的整数存储在x中 System.out.println(\"请输入第二个整数:\"); int y = sc.nextInt();//将键盘录入的整数存储在y中 int max = getMax(x,y); System.out.println(max); boolean b = isEquals(x,y); System.out.println(b); &#125; /* 返回连个整数的较大值 1,明确返回值类型 int 2,明确参数列表 int a,int b */ public static int getMax(int a,int b) &#123; return a &gt; b ? a : b; &#125; /* 判断两个整数是否相等 1,明确返回值类型 boolean 2,明确参数列表 int a,int b */ public static boolean isEquals(int a,int b) &#123;//isEquals 是否相等 return a == b; &#125;&#125; 方法之输出星形及其调用 代码演示 需求：根据键盘录入的行数和列数，在控制台输出星形 方法调用：(无返回值,void) 单独调用 输出调用(错误) 赋值调用(错误) 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;class Test &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in);//创建键盘录入对象 System.out.println(\"请输入行数:\"); int row = sc.nextInt(); //将键盘录入的行数存储在row中 System.out.println(\"请输入列数:\"); int column = sc.nextInt();//将键盘录入的列数存储在column中 //System.out.println(print(row,column));//错误: 此处不允许使用 '空' 类型,返回值是void的方法不能输出调用 //返回值是void的方法只能单独调用 print(row,column); &#125; /* 在控制台输出矩形星形 1,明确返回值类型,经分析没有具体的返回值类型,void 2,明确参数列表int a,int b */ public static void print(int a,int b) &#123; for (int i = 1;i &lt;= a ;i++ ) &#123;//行数 for (int j = 1;j &lt;= b ;j++ ) &#123;//列数 System.out.print(\"*\"); &#125; System.out.println(); &#125; //return ; //如果返回值类型是void,return可以省略,即使省略系统也会默认给加上,形式是return; &#125;&#125; 方法的练习 需求：根据键盘录入的数据输出对应的乘法表 123456789101112131415161718192021222324import java.util.Scanner;class Test &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in);//创建键盘录入对象 System.out.println(\"请录入一个整数,范围在1-9之间\"); int num = sc.nextInt(); //将键盘录入的整数存储在num中 print99(num); &#125; /* 打印99乘法表 1,返回值类型void 2,参数列表,int a */ public static void print99(int a) &#123; for (int i = 1;i &lt;= a ;i++ ) &#123;//行数 for (int j = 1;j &lt;= i ;j++ ) &#123;//列数 System.out.print(j + \"*\" + i + \"=\" + (i * j) + \"\\t\" ); &#125; System.out.println(); &#125; &#125;&#125; 方法重载概述和基本使用 方法重载概述 求和案例 2个整数 3个整数 4个整数 方法重载： 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 参数列表不同： 参数个数不同 参数类型不同 参数的顺序不同(算重载,但是在开发中不用) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*重载:方法名相同,参数列表不同,与返回值类型无关重载的分类1,参数个数不同2,参数类型不同 顺序不同*/class Demo4_Overload &#123;//overload重载 public static void main(String[] args) &#123; double sum1 = add(10,20.1); System.out.println(sum1); int sum2 = add(10,20,30); System.out.println(sum2); double sum3 = add(12.3,13); System.out.println(sum3); &#125; /* 求两个整数的和 1,返回值类型int 2,参数列表 int a,int b */ public static double add(int a,double b) &#123; return a + b; &#125; /* 求三个整数的和 1,返回值类型int 2,参数列表 int a,int b,int c */ public static int add(int a,int b,int c) &#123; return a + b + c; &#125; /* 求两个小数的和 1,返回值类型double 2,参数列表 double a,double b */ public static double add(double a,int b) &#123; return a + b; &#125;&#125; 方法重载练习比较数据是否相等 需求：比较两个数据是否相等。 参数类型分别为两个int类型，两个double类型，并在main方法中进行测试 123456789101112131415161718192021222324252627class Test_Overload &#123; public static void main(String[] args) &#123; boolean b1 = isEquals(10,10); System.out.println(b1); boolean b2 = isEquals(10.5,10.5); System.out.println(b2); &#125; /* 比较两个数据是否相等 1,返回值类型boolean 2,参数列表int a,int b */ public static boolean isEquals(int a,int b) &#123; return a == b; &#125; /* 比较两个数据是否相等 1,返回值类型boolean 2,参数列表double a,double b */ public static boolean isEquals(double a,double b) &#123; return a == b; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - 循环结构及控制跳转","date":"2013-06-16T16:00:00.000Z","path":"2013/06/17/java-se/2013-06-17-javase-loop-structure/","text":"循环结构及控制跳转 循环结构概述和for语句的格式及其使用 循环结构的分类for,while,do…while 循环结构for语句的格式： 123for(初始化表达式;条件表达式;循环后的操作表达式) &#123; 循环体;&#125; 执行流程： 执行初始化语句 执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 执行循环体语句; 执行循环后的操作表达式 回到B继续。 在控制台输出10次”helloworld” 123456789101112131415//在控制输出10次helloworld,这样做不推荐,因为复用性太差/*System.out.println(\"helloworld\");System.out.println(\"helloworld\");System.out.println(\"helloworld\");System.out.println(\"helloworld\");System.out.println(\"helloworld\");System.out.println(\"helloworld\");System.out.println(\"helloworld\");System.out.println(\"helloworld\");System.out.println(\"helloworld\");System.out.println(\"helloworld\");*/for (int i = 1;i &lt;= 10 ;i++ ) &#123; System.out.println(\"helloworld\");&#125; 循环结构for语句的练习获取数据 代码演示 需求：请在控制台输出数据1-10 需求：请在控制台输出数据10-1 注意事项 判断条件语句无论简单还是复杂结果是boolean类型。 循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。 一般来说：有左大括号就没有分号，有分号就没有左大括号 12345678for (int i = 1;i &lt;= 10 ;i++ )&#123; System.out.println(\"i = \" + i);&#125;System.out.println(\"-----------------------\");for (int i = 10;i &gt;= 1 ;i-- ) &#123; System.out.println(\"i = \" + i);&#125; 求和思想需求：求出1-10之间数据之和 1234567//1-10的和int sum = 0;for (int i = 1;i &lt;= 10 ;i++ ) &#123; sum = sum + i;&#125;System.out.println(\"sum = \" + sum); 需求：求出1-100之间偶数和 需求：求出1-100之间奇数和 1234567891011121314151617181920//1-100的偶数和/*int sum = 0;for (int i = 1;i &lt;= 100 ;i++ ) &#123; if (i % 2 == 0) &#123; sum = sum + i; &#125;&#125;System.out.println(\"sum = \" + sum);*///1-100的奇数和int sum = 0;for (int i = 1;i &lt;= 100 ;i+=2 ) &#123; /*if (i % 2 != 0) &#123; sum = sum + i; &#125;*/ sum = sum + i;&#125;System.out.println(\"sum = \" + sum); 水仙花 需求：在控制台输出所有的”水仙花数” 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 举例：153就是一个水仙花数。 153 = 111 + 555 + 333 = 1 + 125 + 27 = 153 123456789//三位数是100到999之间for(int i = 100;i &lt; 1000 ;i++)&#123; int ge = i % 10;//个位 int shi = i / 10 % 10;//十位 int bai = i / 100 ;//百位 if(ge * ge * ge + shi * shi * shi + bai * bai * bai == i)&#123; System.out.println(i); &#125;&#125; 统计思想需求：统计”水仙花数”共有多少个 12345678910int count = 0;for(int i = 100;i &lt; 1000 ;i++)&#123; int ge = i % 10;//个位 int shi = i / 10 % 10;//十位 int bai = i / 100 ;//百位 if(ge * ge * ge + shi * shi * shi + bai * bai * bai == i)&#123; count++;//满足条件自增,计数器思想 &#125; System.out.println(count);&#125; 循环结构while语句格式和基本使用循环结构while语句的格式：123456789101112 while循环的基本格式： while(判断条件语句) &#123; 循环体语句; &#125;完整格式：初始化语句; while(判断条件语句) &#123; 循环体语句; 控制条件语句;&#125; 执行流程： 执行初始化语句 执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 执行循环体语句; 执行控制条件语句 回到b继续。 需求：请在控制台输出数据1-10 12345int x = 1;while (x &lt;= 10) &#123; System.out.println(\"x = \" + x); x++;&#125; 练习求和思想 求1-100之和 123456int sum = 0;int i = 1;while (i &lt;= 100) &#123; sum += i;//sum = sum + i; i++;//让变量i自增&#125; 统计思想 统计”水仙花数”共有多少个 1234567891011121314int count = 0;//计数器int i = 100;while (i &lt;= 999) &#123; int ge = i % 10; int shi = i / 10 % 10; int bai = i / 100; if (i == ge * ge * ge + shi * shi * shi + bai * bai * bai) &#123; count ++; &#125; i++;&#125;System.out.println(\"count =\" + count); 问题:某屌丝为了追求女神,写了一段代码示爱,但是女神也会java,改动一下把屌丝拒绝 while (j &lt;= 10000) ; //加分号 12345int j = 1;while (j &lt;= 10000) &#123; System.out.println(\"I Love You!!!\"); j++;&#125; 循环结构do…while语句的格式和基本使用循环结构do…while语句的格式：12345678910do &#123; 循环体语句; &#125;while(判断条件语句); 完整格式； 初始化语句; do &#123; 循环体语句; 控制条件语句; &#125;while(判断条件语句); 执行流程： 执行初始化语句 执行循环体语句; 执行控制条件语句 执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 回到b继续。 需求：请在控制台输出数据1-10 123456int i = 11;do &#123; System.out.println(\"i = \" + i); i++;&#125;while (i &lt;= 10); 循环结构三种循环语句的区别 A:代码演示 三种循环语句的区别: do…while循环至少执行一次循环体。 而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。 123456789101112int i = 11;do &#123; System.out.println(&quot;i = &quot; + i); i++;&#125;while (i &lt;= 10);//↑dowhile---↓whileint j = 11;while (j &lt;= 10) &#123; System.out.println(&quot;j = &quot; + j); j++;&#125; for循环和while循环的区别： 如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用谁就用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。 12345678910111213for (int i = 1;i &lt;= 10 ;i++ ) &#123; System.out.println(\"i = \" + i);&#125;//for语句执行后变量会被释放,不能再使用//System.out.println(\"i = \" + i); //-----------int i = 1;while (i &lt;= 10) &#123; System.out.println(\"i = \" + i); i++;&#125;//while语句执行后,初始化变量还可以继续使用System.out.println(\"i = \" + i); 循环结构注意事项之死循环 一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。 两种最简单的死循环格式 while(true){…} for(;;){…} 12345678//while语句的无限循环while (true) &#123; System.out.println(\"hello world\"); //for语句的无限循环for (; ; ) &#123; System.out.println(\"hello world\");&#125; 循环结构循环嵌套输出4行5列的星星 需求：请输出一个4行5列的星星(*)图案。 注意：System.out.println(““);和System.out.print(““);的区别 如图： 1234******************** 结论： 外循环控制行数，内循环控制列数 123456for (int i = 1;i &lt;= 4 ;i++ ) &#123;//外循环决定的是行数 for (int j = 1;j &lt;= 5 ;j++ ) &#123;//内循环决定的是列数 System.out.print(\"*\"); &#125; System.out.println();&#125; 正三角形需求：请输出下列的形状 12345 *************** 123456for (int i = 1;i &lt;= 5 ; i++) &#123; //外循环决定行数 for (int j = 1;j &lt;= i ;j++ ) &#123; //内循环决定列数 System.out.print(\"*\"); &#125; System.out.println(); //将光标换到下一行的行首&#125; 循环结构九九乘法表需求：在控制台输出九九乘法表。 123456for (int i = 1;i &lt;= 9 ;i++ ) &#123; //行数 for (int j = 1;j &lt;= i ;j++ ) &#123; //列数 System.out.print(j + \"*\" + i + \"=\" + (i * j) + \"\\t\" ); &#125; System.out.println();&#125; 代码优化 注意： 123456&apos;\\x&apos; x表示任意，\\是转义符号,这种做法叫转移字符。&apos;\\t&apos; tab键的位置&apos;\\r&apos; 回车&apos;\\n&apos; 换行&apos;\\&quot;&apos;&apos;\\&apos;&apos; windows \\r\\n 回车换行 mac \\r 回车换行 Linux \\n 回车换行 12System.out.println(\"\\\"\");//转义双引号System.out.println('\\'');//转义单引号 控制跳转语句break语句break的使用场景 只能在switch和循环中 123456for (int x = 1;x &lt;= 10 ;x++ ) &#123; if (x == 4) &#123; break;//跳出循环 &#125; System.out.println(\"x = \" + x);&#125; continue语句continue的使用场景 只能在循环中 1234567for (int x = 1;x &lt;= 10 ;x++ ) &#123; if (x == 4) &#123; continue;//终止本次循环,继续下次循环 &#125; System.out.println(\"x = \" + x);&#125; 标号 标号:标记某个循环对其控制 标号组成规则:其实就是合法的标识符 1234567891011outer: for (int i = 1;i &lt;= 10 ;i++ ) &#123; //outer就是标号,只要是合法的标识符即可 System.out.print(\"i = \" + i); inner: for (int j = 1;j &lt;= 10 ;j++ ) &#123; System.out.println(\"j = \" + j); break outer;//标号一般用于跳出外层循环 &#125; System.out.println(); //以下代码是否会报错 http://blog.wxhao2.com //不会,前面是标号,后面是注释 练习填空123456for(int x=1; x&lt;=10; x++) &#123; if(x%3==0) &#123; //在此处填写代码 &#125; System.out.println(“Java基础班”); &#125; 我想在控制台输出2次:“Java基础班“ 我想在控制台输出7次:“Java基础班“ 我想在控制台输出13次:“Java基础班“ 12345break;//2次continue;//7次System.out.println(“Java基础班”);//13次 return语句 return的作用 返回 其实它的作用不是结束循环的，而是结束方法的。 代码演示 return和break以及continue的区别? return是结束方法 break是跳出循环 continue是终止本次循环继续下次循环 12345678for (int i = 1;i &lt;= 10 ;i++ ) &#123; if (i == 4) &#123; //break;//停止循环 return;//返回的意思,用来返回方法 &#125;&#125;System.out.println(\"循环结束了\");","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - 顺序结构与选择结构","date":"2013-06-14T16:00:00.000Z","path":"2013/06/15/java-se/2013-06-15-javase-sequence-choice-structure/","text":"顺序结构与选择结构 顺序结构语句 什么是流程控制语句 流程控制语句：可以控制程序的执行流程。 流程控制语句的分类 顺序结构 选择结构 循环结构 执行流程： 从上往下，依次执行。 1234System.out.println(\"Hello World!11111\");System.out.println(\"Hello World!3333\");System.out.println(\"Hello World!22222\");System.out.println(\"Hello World!44444\"); 选择结构if语句 格式及其使用 选择结构的分类 if语句 switch语句 执行流程： 先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体； 如果是false，就不执行语句体； 1234567int age = 17;if (age &gt;= 18) &#123; System.out.println(\"可以浏览本网站\");&#125;System.out.println(\"完了\"); 选择结构if语句 注意事项注意事项1 比较表达式无论简单还是复杂，结果必须是boolean类型 if语句控制的语句体如果是一条语句，大括号可以省略； 如果是多条语句，就不能省略。建议永远不要省略。 一般来说：有左大括号就没有分号，有分号就没有左大括号 1234567int age = 17;if (age &gt;= 18 &amp;&amp; age &lt;= 60) &#123; System.out.println(\"可以浏览本网站\"); //int x = 10; 是两句话,int x声明是一句,x = 10 赋值是一句&#125;System.out.println(\"完了\"); 注意事项212345if(比较表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; 执行流程： 首先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体1； 如果是false，就执行语句体2； 代码演示 获取两个数据中较大的值 判断一个数据是奇数还是偶数,并输出是奇数还是偶数 注意事项：else后面是没有比较表达式的，只有if后面有。 123456789101112131415161718192021222324252627/*int x = 0;if (x == 1) &#123; System.out.println(\"男厕所欢迎您\");&#125;else &#123; System.out.println(\"女厕所欢迎您\");&#125;*///a:获取两个数据中较大的值/*int x = 10;int y = 20;int z;if (x &gt; y) &#123; z = x;&#125;else &#123; z = y;&#125;System.out.println(z);*///b:判断一个数据是奇数还是偶数,并输出是奇数还是偶数int num = 11;if (num % 2 == 0) &#123; System.out.println(num + \"是一个偶数\");&#125;else &#123; System.out.println(num + \"是一个奇数\");&#125; if语句的格式和三元的相互转换问题 三元运算符实现的，都可以采用if语句实现。反之不成立。 什么时候if语句实现不能用三元改进呢? 当if语句控制的操作是一个输出语句的时候就不能。 为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。 123456789101112131415161718int x = 10;int y = 20;int z;if (x &gt; y) &#123; //z = x; System.out.println(x + \"是最大值\");&#125;else &#123; //z = y; System.out.println(y + \"是最大值\");&#125;//System.out.println(z);int a = 20;int b = 30;int c = (a &gt; b)? a : b; 选择结构if使用1234567891011if(比较表达式1) &#123; 语句体1; &#125;else if(比较表达式2) &#123; 语句体2; &#125;else if(比较表达式3) &#123; 语句体3; &#125; ... else &#123; 语句体n+1; &#125; 执行流程： 首先计算比较表达式1看其返回值是true还是false， 如果是true，就执行语句体1，if语句结束。 如果是false，接着计算比较表达式2看其返回值是true还是false， 如果是true，就执行语句体2，if语句结束。 如果是false，接着计算比较表达式3看其返回值是true还是false， 如果都是false，就执行语句体n+1。 注意事项: 最后一个else可以省略,但是建议不要省略,可以对范围外的错误值提示 12345678int x = 2;if (x == 1) &#123; System.out.println(\"男厕所欢迎您\");&#125;else if (x == 0) &#123; System.out.println(\"女厕所欢迎您\");&#125;else &#123; System.out.println(\"无法识别您的性别\");&#125; 选择结构if语句练习需求：键盘录入一个成绩，判断并输出成绩的等级。90-100 优80-89 良70-79 中60-69 及0-59 差 123456789101112131415161718192021222324import java.util.Scanner;class Test &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); //需求：键盘录入一个成绩，判断并输出成绩的等级。 System.out.println(\"请输入学生成绩范围在1到100之间\"); int x = sc.nextInt(); if (x &gt;= 90 &amp;&amp; x &lt;= 100) &#123; System.out.println(\"优\"); &#125;else if (x &gt;= 80 &amp;&amp; x &lt;= 89 ) &#123; System.out.println(\"良\"); &#125;else if (x &gt;= 70 &amp;&amp; x &lt;= 79 ) &#123; System.out.println(\"中\"); &#125;else if (x &gt;= 60 &amp;&amp; x &lt;= 69 ) &#123; System.out.println(\"及\"); &#125;else if (x &gt;= 0 &amp;&amp; x &lt;= 59 ) &#123; System.out.println(\"差\"); &#125;else &#123; System.out.println(\"成绩录入错误\"); &#125; &#125;&#125; 键盘录入x的值，计算出y的并输出。 x&gt;=3y = 2 * x + 1; -1&lt;x&lt;3y = 2 * x; x&lt;=-1y = 2 * x - 1; 123456789101112//需求： 键盘录入x的值，计算出y的并输出System.out.println(\"请输入一个整数:\");int x = sc.nextInt();int y = 0;//不初始化,条件不满足时会报错if (x &gt;= 3) &#123; y = 2 * x + 1;&#125;else if (x &gt; -1 &amp;&amp; x &lt; 3) &#123; y = 2 * x;&#125;else if (x &lt;= -1) &#123; y = 2 * x - 1;&#125;System.out.println(y); 选择结构if语句的嵌套使用 需求：获取三个数据中的最大值 if语句的嵌套使用。 123456789101112131415161718int a = 40;int b = 50;int c = 30;if (a &gt; b) &#123; if (a &gt; c) &#123; System.out.println(a + \"是最大值\"); &#125;else &#123; System.out.println(c + \"是最大值\"); &#125;&#125;else &#123; //b &gt;= a if (b &gt; c) &#123; System.out.println(b + \"是最大值\"); &#125;else &#123; System.out.println(c + \"是最大值\"); &#125;&#125; 选择结构switch语句的格式及其解释 switch语句的格式 123456789101112switch(表达式) &#123; case 值1： 语句体1; break; case 值2： 语句体2; break; // … default： 语句体n+1; break;&#125; byte可以作为switch的表达式吗? 基本数据类型可以接收byte,short,char,int long可以作为switch的表达式吗? 不可以 String可以作为switch的表达式吗? 引用数据类型可以接收枚举(JDK1.5)String字符串(JDK1.7) 执行流程 先计算表达式的值 然后和case后面的匹配，如果有就执行对应的语句，否则执行default控制的语句 12345678910111213String name = \"rose\";String gender = \"妖\";switch (gender) &#123;case \"男士\": System.out.println(name + \"是一位\" + gender + \"喜欢吃饭睡觉打dota\"); break;case \"女士\": System.out.println(name + \"是一位\" + gender + \"喜欢逛街购物美容\"); break;default: System.out.println(name + \"是一位\" + gender + \"打雌性激素维持美貌容颜\"); break;&#125; 选择结构switch语句的练习 整数(给定一个值,输出对应星期几) 123456789101112131415161718192021222324252627int week = 1;switch (week) &#123;case 1: System.out.println(\"星期一\"); break;case 2: System.out.println(\"星期二\"); break;case 3: System.out.println(\"星期三\"); break;case 4: System.out.println(\"星期四\"); break;case 5: System.out.println(\"星期五\"); break;case 6: System.out.println(\"星期六\"); break;case 7: System.out.println(\"星期日\"); break;default: System.out.println(\"对不起没有对应的星期\"); break;&#125; 选择结构switch语句的注意事项 case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 default可以省略吗? 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。 特殊情况： case就可以把值固定。 比如:A,B,C,D break可以省略吗? 最后一个可以省略,其他最好不要省略 会出现一个现象：case穿透。 最终建议不要省略 default一定要在最后吗? 不是，可以在任意位置。但是建议在最后。 switch语句的结束条件 遇到break就结束了 执行到switch的右大括号就结束了 选择结构switch语句练习看程序写结果: 123456789101112int x = 2;int y = 3;switch(x)&#123; default: y++; break; case 3: y++; case 4: y++;&#125;System.out.println(\"y=\"+y);//4 看程序写结果:1234567891011int x = 2;int y = 3;switch(x)&#123; default: y++; case 3: y++; case 4: y++;&#125;System.out.println(\"y=\"+y);//6 选择结构if语句和switch语句的区别 总结switch语句和if语句的各自使用场景 switch建议判断固定值的时候用 if建议判断区间或范围的时候用 代码演示 分别用switch语句和if语句实现下列需求： 键盘录入月份，输出对应的季节 一年有四季3,4,5春季6,7,8夏季9,10,11秋季12,1,2冬季 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;class Test &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); //创建键盘录入对象 System.out.println(\"请输入月份\"); int month = sc.nextInt(); //将键盘录入的结果存储在month /*switch (month) &#123; case 3: case 4: case 5: System.out.println(month + \"月是春季\"); break; case 6: case 7: case 8: System.out.println(month + \"月是夏季\"); break; case 9: case 10: case 11: System.out.println(month + \"月是秋季\"); break; case 12: case 1: case 2: System.out.println(month + \"月是冬季\"); break; default: System.out.println(\"对不起没有对应的季节\"); break; &#125;*/ //用if语句来完成月份对应季节 if (month &gt; 12 || month &lt; 1) &#123; System.out.println(\"对不起没有对应的季节\"); &#125;else if (month &gt;= 3 &amp;&amp; month &lt;= 5) &#123; System.out.println(month + \"月是春季\"); &#125;else if (month &gt;= 6 &amp;&amp; month &lt;= 8) &#123; System.out.println(month + \"月是夏季\"); &#125;else if (month &gt;= 9 &amp;&amp; month &lt;= 11) &#123; System.out.println(month + \"月是秋季\"); &#125;else &#123; System.out.println(month + \"月是冬季\"); &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"JavaSE - Scanner键盘录入","date":"2013-06-13T16:00:00.000Z","path":"2013/06/14/java-se/2013-06-14-javase-scanner/","text":"Scanner键盘录入 算是一个初级阶段比较有趣的了 (括弧笑) 键盘录入的基本格式讲解 为什么要使用键盘录入数据 为了让程序的数据更符合开发的数据 让程序更灵活一下 如何实现键盘录入呢? 先照格式来。 导包 格式：import java.util.Scanner; 位置：在class上面。 创建键盘录入对象 格式：Scanner sc = new Scanner(System.in); 通过对象获取数据 格式：int x = sc.nextInt(); 键盘录入1个整数，并输出到控制台。 键盘录入2个整数，并输出到控制台。 12345678910111213141516171819import java.util.Scanner;class Test &#123; public static void main(String[] args) &#123; /*Scanner sc = new Scanner(System.in);//创建键盘录入对象 System.out.println(\"请输入一个整数:\"); int x = sc.nextInt();//将键盘录入的数据存储在x中 System.out.println(x);*/ //录入两个整数 Scanner sc = new Scanner(System.in);//创建键盘录入对象 System.out.println(\"请输入第一个整数:\"); int x = sc.nextInt();//将键盘录入的数据存储在x中 System.out.println(x); System.out.println(\"请输入第二个整数:\"); int y = sc.nextInt();//将键盘录入的数据存储在y中 System.out.println(y); &#125;&#125; 键盘录入的练习练习1 代码演示键盘录入练习：键盘录入两个数据，并对这两个数据求和，输出其结果 代码演示键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值 123456789101112131415161718192021222324import java.util.Scanner;//导入包中的类Scannerclass Test &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in);//创建键盘录入对象 //键盘录入练习：键盘录入两个数据，并对这两个数据求和，输出其结果 /*System.out.println(\"请输入第一个整数:\"); int x = sc.nextInt();//将键盘录入的数据存储在x中 System.out.println(\"请输入第二个整数:\"); int y = sc.nextInt();//将键盘录入的数据存储在y中 int sum = x + y; System.out.println(sum);*/ //键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值 System.out.println(\"请输入第一个整数:\"); int x = sc.nextInt();//将键盘录入的数据存储在x中 System.out.println(\"请输入第二个整数:\"); int y = sc.nextInt();//将键盘录入的数据存储在y中 int max = (x &gt; y) ? x : y;//获取x和y中的最大值 System.out.println(\"max = \" + max); &#125;&#125; 练习2 键盘录入练习：键盘录入两个数据，比较这两个数据是否相等 键盘录入练习：键盘录入三个数据，获取这三个数据中的最大值 123456789101112131415161718192021222324252627282930import java.util.Scanner;//导包class Test &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in);//创建键盘录入对象 //键盘录入练习：键盘录入两个数据，比较这两个数据是否相等 /*System.out.println(\"请输入第一个整数:\"); int x = sc.nextInt();//将键盘录入的数据存储在x中 System.out.println(\"请输入第二个整数:\"); int y = sc.nextInt();//将键盘录入的数据存储在y中 //boolean b = (x == y)? true : false; boolean b = (x == y); System.out.println(b);*/ //键盘录入练习：键盘录入三个数据，获取这三个数据中的最大值 System.out.println(\"请输入第一个整数:\"); int x = sc.nextInt();//将键盘录入的数据存储在x中 System.out.println(\"请输入第二个整数:\"); int y = sc.nextInt();//将键盘录入的数据存储在y中 System.out.println(\"请输入第三个整数:\"); int z = sc.nextInt();//将键盘录入的数据存储在y中 //定义临时变量记录住比较出前两个变量中的最大值 int temp = (x &gt; y) ? x : y; //将比较后的结果与第三个变量中的值比较,比较出三个数中的最大值 int max = (temp &gt; z) ? temp : z; System.out.println(max); &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"Java语言基础 - 运算符","date":"2013-06-12T16:00:00.000Z","path":"2013/06/13/java-se/2013-06-13-java-basics-operator/","text":"java语言中的加减乘除 算术运算符的基本用法 什么是运算符就是对常量和变量进行操作的符号。 运算符的分类 算术运算符 赋值运算符 比较(关系或条件)运算符 逻辑运算符 位运算符 三目(元)运算符 算数运算符有哪些+,-,*,/,%,++,– 注意事项： +号在java中有三种作用,代表正号,做加法运算,字符串的连接符 整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型 /获取的是除法操作的商，%获取的是除法操作的余数 %运算符 当左边的绝对值小于右边绝对值时,结果是左边 当左边的绝对值等于右边或是右边的倍数时,结果是0 当左边的绝对值大于右边绝对值时,结果是余数 %运算符结果的符号只和左边有关系,与右边无关 任何一个正整数%2结果不是0就是1可以用来当作切换条件 123Sysout.out.print(10/3);//整数相除结果只能是整数Sysout.out.print(10/3.0);//如果想得到小数,把其中一个数变成小数,另一个数在运算时会自动类型提升Sysout.out.print(3%5);// 算术运算符++和–的用法 ++,–运算符的作用 自加（++）自减（–）运算 ++:自加。对原有的数据进行+1 –:自减。对原有的数据进行-1 代码演示 单独使用：放在操作数的前面和后面效果一样。(这种用法是我们比较常见的) 参与运算使用： 放在操作数的前面，先自增或者自减，然后再参与运算。 放在操作数的后面，先参与运算，再自增或者自减。 123456789int a = 3;//a++;//a=a+1//++a;//a=a+1int b;b=a++;//当++在变量后面时,会先将值取出来做赋值操作,再自身+1sysout(a);//4sysout(b);//3 算术运算符++和–的练习 代码演示请分别计算出a,b,c的值 12345678int a = 10;int b = 10;int c = 10;a = b++;//10,b=11 c = --a;//9,a=9 b = ++a;//10,a=10 a = c--;//9,c=8 代码演示请分别计算出x,y的值? 123int x = 4;// 4 6 60int y = (x++)+(++x)+(x*10); 以下程序问哪句会报错,为什么 123byte b = 10;b++;// 底层要得到结果 b=(byte)(b+1)b = b + 1;//自动提升为int 赋值运算符的基本用法 赋值运算符有哪些 基本的赋值运算符：=把=右边的数据赋值给左边。 扩展的赋值运算符：+=,-=,*=,/=,%=+= 把左边和右边做加法，然后赋值给左边。 123int a=3;//右边常量赋值给左边变量,左边必须是变量//3=a//报错a+=4;//7,a=a+4 赋值运算符的面试题 代码演示看下面的程序是否有问题，如果有问题，请指出并说明理由。 1short s=1;s = s+1;//提升int,损失精度 1short s=1;s+=1;//2,s=(short)(s+1),底层要得到结果 关系运算符的基本用法及其注意事项 关系运算符有哪些(比较运算符,条件运算符)==,!=,&gt;,&gt;=,&lt;,&lt;= 注意事项： 无论你的操作是简单还是复杂，结果是boolean类型。 “==”不能写成”=”。 逻辑运算符 逻辑运算符有哪些 &amp;,|,^,! &amp;&amp;,|| 代码演示 123456789101112131415161718192021222324252627//int x = 10;//5 &lt; x &lt; 15//x &gt; 5 &amp; x &lt; 15int a = 10;int b = 20;int c = 30;//逻辑与 &amp; 并且 and 遇 false则falseSystem.out.print(a &lt; b &amp; b &lt;c);//true &amp; true = trueSystem.out.print(a &lt; b &amp; b &lt;c);//true &amp; false = falseSystem.out.print(a &lt; b &amp; b &lt;c);//false &amp; true = falseSystem.out.print(a &lt; b &amp; b &lt;c);//false &amp; false = false//逻辑或 或or 遇true则trueSystem.out.print(a &lt; b | b &lt;c);//true | true = trueSystem.out.print(a &lt; b | b &lt;c);//true | false = trueSystem.out.print(a &lt; b | b &lt;c);//false | true = trueSystem.out.print(a &lt; b | b &lt;c);//false | false = false//逻辑异或 两边相同为false,两边不同为trueSystem.out.print(a &lt; b ^ b &lt;c);//true ^ true = falseSystem.out.print(a &lt; b ^ b &lt;c);//true ^ false = trueSystem.out.print(a &lt; b ^ b &lt;c);//false ^ true = trueSystem.out.print(a &lt; b ^ b &lt;c);//false ^ false = false//逻辑非System.out.print(!true);//false 逻辑运算符的基本用法 注意事项： 逻辑运算符一般用于连接boolean类型的表达式或者值。 表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。 算术表达式：a + b 比较表达式：a == b(条件表达式) 结论： &amp;逻辑与:有false则false。 |逻辑或:有true则true。 ^逻辑异或:相同为false，不同为true。 !逻辑非:非false则true，非true则false。 特点：偶数个不改变本身。 逻辑运算符&amp;&amp;和&amp;的区别 &amp;&amp;和&amp;的区别? a:最终结果一样。 b:&amp;&amp;具有短路效果。左边是false，右边不执行。 &amp;是无论左边是false还是true,右边都会执行 同理||和|的区别? 最终结果相同 ||具有短路效果,左边为true,右边不执行 开发中常用谁?&amp;&amp;,||,! 1234567891011//最终结果一样System.out.print(a &lt; b &amp;&amp; b &lt;c);//true &amp;&amp; true = trueSystem.out.print(a &lt; b &amp;&amp; b &lt;c);//true &amp;&amp; false = falseSystem.out.print(a &lt; b &amp;&amp; b &lt;c);//false &amp;&amp; true = falseSystem.out.print(a &lt; b &amp;&amp; b &lt;c);//false &amp;&amp; false = false//&amp;&amp;具有短路效果。左边是false，右边不执行。int x = 3;int y = 4;System.out.print((++x ==3)&amp; (++y ==4));//false , x=4 ,y=5System.out.print((++x ==3) &amp;&amp; (++y ==4));//false , x=4 ,y=5 位运算符的基本用法 位运算符有哪些&amp;,|,^,~ ,&gt;&gt;,&gt;&gt;&gt;,&lt;&lt; 位运算符的基本用法 &amp;, | ,^,~ 的用法 &amp;:有0则0 |:有1则1 ^:相同则0，不同则1 ~:按位取反 1234567891011121314151617181920212223242526272829303132333435/* 110&amp; 011-------- 010 = 2*/System.out.println(6 &amp; 3);//2/* 110| 011-------- 111 = 7*/System.out.println(6 | 3);//7/* 110^ 011-------- 101 = 5*/System.out.println(6 ^ 3);//5/* 00000000 00000000 00000000 00000110 --------~ 11111111 11111111 1111111111111001 补码- 00000000 00000000 00000000 00000001 11111111 11111111 1111111111111000 反码10000000 00000000 00000000 00000111 原码 -7*/System.out.println(~6);//-7 位异或运算符的特点及面试题 位异或运算符的特点 ^的特点：一个数据对另一个数据位异或两次，该数本身不变。 12System.out.println(10 ^ 5 ^ 10);//5System.out.println(5 ^ 5 ^ 10);//10 请自己实现两个整数变量的交换(不需要定义第三方变量) 1234567891011121314151617int x = 10;int y = 5;//需要第三方变量,开发推荐用这种int temp = y;x = y;y = temp;//不需要定义第三方变量,有弊端,有可能超过int取值返回x = x + y;y = x - y;x = x - y ;//不需要定义第三方变量,通过 ^x = x ^ y; // 10 ^ 5y = x ^ y; // 10 ^ 5 ^ 5 = 10x = x ^ y; // 10 ^ 5 ^ 5 =5 位运算符的基本用法及面试题代码演示 >>,>>>,\\&lt;\\&lt;的用法: \\&lt;\\&lt;:左移 左边最高位丢弃，右边补齐0 >>:右移最高位是0，左边补齐0;最高为是1，左边补齐1 >>>:无符号右移 无论最高位是0还是1，左边补齐0 最有效率的算出2 * 8的结果 12345678910111213141516//向左移动几位,就是乘以2的几次幂System.out.println(12 &lt;&lt; 1); //24System.out.println(12 &lt;&lt; 2); //48/* 00000000 00000000 00000000 00001100 12补码 (0)000000 00000000 00000000 00011000 24补码(00)000000 00000000 00000000 00110000 48补码*///向友移动几位,就是除以2的几次幂System.out.println(12 &gt;&gt; 1); //6System.out.println(12 &gt;&gt; 2); //3//最有效率的算出2 * 8的结果//计算时会先转二进制码System.out.println(2 &lt;&lt; 3); 三元运算符的基本用法 三元运算符的格式(关系表达式) ? 表达式1 : 表达式2; 三元运算符的执行流程 代码演示获取两个数中的最大值 12345int x = 10;int y = 5;int z;z = (x &gt; y) ? x : y;System.out.println(\"z = \" + z); 三元运算符的练习 比较两个整数是否相同 获取三个整数中的最大值 12345678910111213141516171819//比较两个整数是否相同int x = 10;int y = 10;//boolean b = (x == y) ? true : false;boolean b = (x == y);System.out.println(\"b = \" + b);//获取三个整数中的最大值int a = 10;int b = 20;int c = 30;//先比较任意两个数的值,找出这两个数中的最大值int temp = (a &gt; b) ? a : b;//用前两个数的最大值与第三个数比较,获取最大值int max = (temp &gt; c) ? temp : c;System.out.println(\"max =\" + max);","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"Java语言基础-变量及数据类型","date":"2013-06-10T16:00:00.000Z","path":"2013/06/11/java-se/2013-06-11-java-basics-variable-datatype/","text":"java基础中的基础 变量的概述及格式 什么是变量在程序执行的过程中，在某个范围内其值可以发生改变的量 变量的定义格式数据类型 变量名 = 变量值; 为什么要定义变量用来不断的存放同一类型的常量，并可以重复使用 数据类型的概述和分类 为什么有数据类型Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间 Java中数据类型的分类 基本数据类型 引用数据类型 基本数据类型分类(4类8种) 整数型 byte 占一个字节 -128到127 short 占两个字 -2^15~2^15-1 int 占四个字节 -2^31~2^31-1 long 占八个字节 -2^63~2^63-1 浮点型 float 占四个字节 -3.403E38~3.403E38 单精度 double 占八个字节-1.798E308~1.798E308 双精度 字符型 char 占两个字节 0~65535 布尔型boolean 理论上是占八分之一个字节,因为一个开关就可以决定是true和false了,但是java中boolean类型没有明确指定他的大小 定义不同数据类型的变量 定义不同基本数据类型的变量，并输出 赋值时候注意float类型,long类型 123456789101112131415161718192021222324252627//整数类型//占一个字节,-128到127byte b = 10; //占两个字节short s = 20;//占四个字节,整形默认数据类型int i= 30;//占八个字节,如果long类型加L进行标示最好大写,l(小L)和1(一)相似long x = 8888888888L;//浮点类型//占四个字节,必须加Ffloat f=12.3F;//占八个字节,浮点默认数据类型,可以加Ddouble d=33.4;//字符类型//占两个字节char c='a';//布尔类型//没有明确指出大小//理论站8分之1byteboolean bl=true;boolean bl=false; 使用变量的注意事项 作用域问题同一个区域不能使用相同的变量名 初始化值问题局部变量在使用之前必须赋值 一条语句可以定义几个变量int a,b,c…; 123456789101112131415class test &#123; public static void main(String[] args)&#123; int x = 10; //int x = 5; int y;//使用必须赋值,不使用可以不赋值 //System.out.print(y) int a,b,c,d; a=10; b=2; c=1; d=100; &#125;&#125; 数据类型转换之隐式转换 代码演示 int + int byte + int 1234int x=3;int b=4;x = x + b ;System.out.print(x);//7 Java中的默认转换规则取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再运算 数据类型转换之强制转换 强制转换问题 int a = 10; byte b = 20; b = a + b; 1234int x=3;int b=4;b = x + b ;System.out.print(x);//报错,损失精度 强制转换的格式b = (byte)(a + b); 1234int x=3;int b=4;(byte)b = x + b ;System.out.print(x);//7 强制转换的注意事项如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同 123456789101112//00000000 00000000 00000000 10000010 130二进制,强转丢失精度//10000010 -126补码,计算机用补码计算//00000001 减一求反码(上面的减此行的1)//10000001 -126反码//11111110 -126原码byte b = (byte)(126 + 4);System.out.print(b);//-126//00000000 00000000 00000001 00101100 300的二进制,强转丢精度//00101100 byte b = (byte)300;System.out.print(b);//44 变量相加和常量相加的区别 看下面的程序是否有问题，如果有问题，请指出并说明理由。 1234byte b1 = 3;byte b2 = 4;byte b3 = b1 + b2;sysout//报错,可能会损失精度 从两方面去回答 b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中(编译阶段无法判断)JVM是无法判断里面具体的值 byte类型(或者short,char)的变量在进行运算的时候,会自动类型提升为int类型 补充 123byte b3 = 3 + 4;//byte b4 = 7;java编译有常量优化sysout//7 3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了 long与float的取值范围谁大谁小进行混合运算的时候,byte,short,char不会相互转换,都会自动类型提升为int类型,其他类型进行混合运算的是小的数据类型提升为大的 byte,short,char – int – long – float – double long: 8个字节 float：4个字节 IEEE754 4个字节是32个二进制位 1位是符号位 8位是指数位 00000000 11111111 0到255 1到254 -126到127 23位是尾数位 每个指数位减去127 它们底层的存储结构不同。 float表示的数据范围比long的范围要大 long：2^63-1 float：3.410^38 &gt; 210^38 &gt; 28^38 = 22^3^38 = 2*2^114 &gt; 2^63-1 代码演示123456789101112131415161718192021222324252627float f = 12.3f;long x = 12345;f = x; //隐式转换sysout//12345.0x=f;sysout//报错,可能损失精度/*float 占4和字节IEEE 754规定:32个二进制位规定:1位符号位规定:8位代表指数位(多少次幂) 00000000 - 11111111 0 - 255 规定:指数位0代表0规定:指数位255代表无穷大 剩下 1 - 254 指数位都减去127 即:2^-126 - 2^127 规定:23位代表尾数位(小数,\".\"后面的数,决定不了大小,最大无限接近1)*/ IEEE 754文档 字符和字符串参与运算 演示 12345System.out.println('a');//aSystem.out.println('a'+1);//98 为什么a字符提升为int为97,因为有ASCII码表System.out.println((byte)('a'+1));//bSystem.out.println(\"hello\"+'a'+1);//任何数据类型用+号与字符串相连接都会产生新的字符串System.out.println('a'+1+\"hello\");//JAVA优化机制 通过看结果知道’a’的值是多少,由此引出ASCII码表 ASCII ASCII码表的概述 记住三个值： ‘0’ 48 ‘A’ 65 ‘a’ 97 +号 在有字符串参与中被称为字符串连接符 12System.out.println(\"5+5=\"+5+5);//5+5=55System.out.println(\"5+5=\"+(5+5));//括号提升优先级 char数据类型 大小为 0到65535 Java语言中的字符char可以存储一个中文汉字吗?为什么呢? 可以,因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节 所以,Java中的字符可以存储一个中文汉字 12char c='a';char c1=97;//0-65535,与上面输出相同","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"Java语言基础之进制及原反补码","date":"2013-06-08T16:00:00.000Z","path":"2013/06/09/java-se/2013-06-09-java-basics-hex-yfb/","text":"蛋疼的 原反补码 进制概述什么是进制 进制：就是进位制，是人们规定的一种进位方法。 对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。 例如:一周有七天,七进制,一年有十二个月,十二进制 二,八,十,十六进制 十进制的由来 十进制的由来是因为人类有十个手指 二进制的由来 其实二进制来源与中国,请看史料记载 18世纪德国数理哲学大师莱布尼兹从他的传教士朋友鲍威特寄给他的拉丁文译本《易经》中，读到了八卦的组成结构，惊奇地发现其基本素数（0）（1），即《易经》的阴爻(yao)和阳爻，其进位制就是二进制，并认为这是世界上数学进制中最先进的。20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，其运算模式正是二进制。它不但证明了莱布尼兹的原理是正确的，同时也证明了《易经》数理学是很了不起的。 八进制的由来 任何数据在计算机中都是以二进制的形式存在的。二进制早期由电信号开关演变而来。一个整数在内存中一样也是二进制的，但是使用一大串的1或者0组成的数值进行使用很麻烦。 所以就想把一大串缩短点，将二进制中的三位用一位表示。这三位可以取到的最大值就是7.超过7就进位了，这就是八进制。 十六进制的由来 但是对于过长的二进制变成八进制还是较长，所以出现的用4个二进制位表示一位的情况，四个二进制位最大是15，这就是十六进制。 不同进制表现同一个数据的形式特点 进制越大，表现形式越短 123451byte=8bit1k=1024b1m=1024k1g=1024m1t=1024g 不同进制数据的表现形式 二进制的数据表现形式由0,1组成。以0b(b可以大写也可以小写)开头(JDK1.7版本可以表示二进制了) 八进制的数据表现形式由0,1,…7组成。以0开头 十进制的数据表现形式由0,1,…9组成。整数默认是十进制的 十六进制的数据表现形式由0,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头 12340b100//二进制 sysout=40100//八进制 sysout=64100//十进制 sysout=1000x100//十六进制 sysout=256 进制的转换任意进制到十进制的转换任意进制到十进制的转换原理 系数：就是每一位上的数据。 基数：X进制，基数就是X。 权：在右边，从0开始编号，对应位上的编号即为该位的权。 结果：把系数*基数的权次幂相加即可。 十进制到任意进制的转换十进制到任意进制的转换原理除积倒取余 快速的进制转换法 8421码及特点8421码是中国大陆的叫法，8421码是BCD代码中最常用的一种。在这种编码方式中每一位二值代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。 通过8421码的方式进行二进制和十进制的相互转换 二进制到八进制的简易方式 二进制到十六进制的简易方式 原码反码补码为什么要学习原码反码补码学习强制类型转换时,如果不知道有原反补会看不懂结果 正数的原码/反码/补码相同 粗体文本 有符号数据表示法的几种方式 原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 通过一个字节,也就是8个二进制位表示+7和-7 0(符号位)0000111 1(符号位)0000111 反码正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码正数的补码与其原码相同；负数的补码是在其反码的末位加1。 原码反码补码的练习 已知原码求补码0b10110100 已知补码求原码0b11101110","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"学习Java语言前的准备","date":"2013-06-06T16:00:00.000Z","path":"2013/06/07/java-se/2013-06-07-java-basics/","text":"Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 Java语言概述 Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 Java语言发展史 詹姆斯·高斯林（James Gosling）1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司，1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。 SUN(Stanford University Network，斯坦福大学网络公司) Java语言版本 JDK 1.1.4 Sparkler 宝石 1997-09-12 JDK 1.1.5Pumpkin南瓜 1997-12-13 JDK 1.1.6Abigail阿比盖尔–女子名1998-04-24 JDK 1.1.7Brutus布鲁图–古罗马政治家和将军1998-09-28 JDK 1.1.8Chelsea切尔西–城市名1999-04-08 J2SE 1.2Playground运动场1998-12-04 J2SE 1.2.1none无1999-03-30 J2SE 1.2.2Cricket蟋蟀1999-07-08 J2SE 1.3Kestrel美洲红隼(sǔn)2000-05-08 J2SE 1.3.1Ladybird瓢虫2001-05-17 J2SE 1.4.0Merlin灰背隼2002-02-13 J2SE 1.4.1grasshopper蚱蜢2002-09-16 J2SE 1.4.2Mantis螳螂2003-06-26 JAVASE 5.0 (1.5.0)Tiger老虎 JAVASE 5.1 (1.5.1)Dragonfly蜻蜓 JAVASE 6.0 (1.6.0)Mustang野马/ JAVASE 7.0 (1.7.0)Dolphin海豚 Java语言平台 J2SE(Java 2 Platform Standard Edition)标准版是为开发普通桌面和商务应用程序提供的解决方案,该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发 J2ME(Java 2 Platform Micro Edition)小型版是为开发电子消费产品和嵌入式设备提供的解决方案 J2EE(Java 2 Platform Enterprise Edition)企业版是为开发企业环境下的应用程序提供的一套解决方案,该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 Java语言特点 简单性 解释性 面向对象 高性能 分布式处理 多线程 健壮性 动态 结构中立 安全性 开源 跨平台 Java语言跨平台原理 write once ,run anywhere!(一处编译,到处运行) 只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。 JRE和JDK的概述 什么是JRE 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 JRE=JVM+类库。 什么是JDK JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。 其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等 JDK=JRE+JAVA的开发工具。 为什么JDK中包含一个JRE 因为写完程序需要看程序输出 JDK,JRE,JVM的作用和关系 JRE=JVM+类库 JDK=JRE+JAVA开发工具类 安装javaJDK的下载和安装过程 JDK的下载官网 http://www.oracle.com JDK的安装 a: 傻瓜式安装 双击安装程序，然后一路next即可(但是不建议) b: 安装的推荐方式 安装路径不要有中文或者特殊符号如空格等。 所有和开发相关的软件最好安装目录统一。 举例：我的JDK安装路径D:\\develop\\Java\\jdk1.7.0_72 当提示安装JRE时，可以选择不安装。建议还是安装上。 c: 安装流程 可以先在d盘建立一个文件夹develop 然后安装 验证安装是否成功 通过DOS命令，切换到JDK安装的bin目录下。 D:\\develop\\Java\\jdk1.7.0_72\\bin 然后分别输入javac和java，如果正常显示非错误内容,说明安装成功 JDK安装路径下的目录解释 bin目录 该目录用于存放一些可执行程序。 如 javac.exe（java编译器）、java.exe(java运行工具)，jar.exe(打包工具)和* javadoc.exe(文档生成工具)等。 db目录: db目录是一个小型的数据库。 从JDK 6.0开始，Java中引用了一个新的成员JavaDB，这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4.0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。 jre目录:jre是 Java Runtime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及一个bin目录，但不包含开发环境中的开发工具。 include目录:由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。 lib目录:lib是library的缩写，意为 Java 类库或库文件，是开发工具使用的归档包文件。 src.zip文件:src.zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码，通过该文件可以查看Java基础类的源代码。 helloworldJava开发工具介绍 记事本(微软操作系统自带) Editplus/Notepad++ Eclipse MyEclipse HelloWorld案例的编写和运行 A:定义类 B:写main方法 C:写输出语句 D:Java程序开发运行与工作原理 E:编译和运行程序 12345class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"HelloWorld\"); &#125;&#125; HelloWorld案例常见问题 A:找不到文件 a:文件扩展名隐藏导致编译失败 b:文件名写错了 B:单词拼写问题 a:class写成Class b:String写成string c:System写成system d:main写成mian C:括号匹配问题 a:把类体的那对大括号弄掉一个 b:把方法体的那对大括号弄掉一个 c:把输出语句的那对小括号弄掉一个 D:中英文问题 a:提示信息：错误: 非法字符: \\????的格式 注意：java编程中需要的基本上都是英文字符 Java语言的书写格式(约定俗成) 大括号要对齐,并且成对写 左大括号前面有空格 遇到左大括号要缩进,Tab 方法和程序块之间加空行让程序看起来清晰 并排语句之间加空格,例如for语句 运算符两侧加空格 java 环境变量path环境变量的作用及配置方式方式1: 在JDK的bin目录下开发程序容易产生的问题 如果文件过多，不方便管理 删除自己写过的不需要的文件，可能不小心把JDK自带的工具给删除了 如何解决问题呢notepad这样的命令为什么在任何路径下都能够执行,配置path环境变量 配置方式 xp系统右键点击桌面计算机→选择属性→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 win7/win8系统右键点击桌面计算机→选择属性→选择高级系统设置→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 方式2: 先配置JAVA_HOME 再修改path 最后说一下path是有先后顺序关系的 classpath环境变量的作用及其配置*为什么要配置classpath 找到class文件并执行 classpath配置的原理 同上 如何配置classpath 同上 JDK1.5之后不需要配置,默认将当前编译路径当成classpath path和classpath的区别 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 classpath配置的java的类文件,就是.class文件 java 语法概述注释概述及其分类 什么是注释 用于解释说明程序的文字 12345 //1.单行注释//可以嵌套 /*2.多行注释(不能嵌套)*/ 注释的作用 解释说明程序 帮助我们调试错误(注释出错代码) 关键字的概述和使用 什么是关键字 被Java语言赋予特定含义的单词 关键字的特点 组成关键字的字母全部小写 常见关键字 public static void class 等 关键字的注意事项 goto和const作为保留字存在,目前并不使用,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 标识符的概述和组成规则 什么是标识符就是给类,接口,方法,变量等起名字时使用的字符序列 标识符的组成规则 英文大小写字母 数字字符 $和_ 标识符注意事项 不能使用关键字 不能数字开头 标识符中常见的命名规则概述:就是给类,接口,方法,变量等起名字时使用的字符序列 包最好是域名倒过来,要求所有的字母小写 类或者接口 如果是一个单词首字母大写 如果是多个单词每个单词首字母大写(驼峰标识) 方法或者变量 如果是一个单词全部小写 如果是多个单词,从第二个单词首字母大写 常量 如果是一个单词,所有字母大写 如果是多个单词,所有的单词大写,用下划线区分每个单词 组成规则 英文大小写字母 数字字符 $和_ 注意事项 不能以数字开头 不能是JAVA关键字 区分大小写 常量的概述和使用 什么是常量在程序执行的过程中其值不可以发生改变 Java中常量的分类字面值常量自定义常量 字面值常量的分类 字符串常量 用双引号括起来的内容 整数常量 所有整数 小数常量所有小数 字符常量用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号 布尔常量较为特殊，只有true和false 空常量 null 12345System.out.print(\"abc\");//字符串常量System.out.print(123);//整数常量System.out.print(12.3);//小数常量System.out.print('a');//字符常量(''中必须放单个数字/字母/符号,不能为空)System.out.print(ture);//布尔常量(true/false)","tags":[{"name":"java","slug":"java","permalink":"http://wxhaor.me/tags/java/"},{"name":"JAVASE","slug":"JAVASE","permalink":"http://wxhaor.me/tags/JAVASE/"}]},{"title":"计算机基础","date":"2013-06-05T16:00:00.000Z","path":"2013/06/06/wxhao/2013-06-06-computer-basics/","text":"计算机基础知识概述作为一个将要从事计算机行业的人,有必要巩固一下计算机的基础知识 什么是计算机 计算机（Computer）全称：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。 应用举例 科学计算 数据处理 自动控制 计算机辅助设计 人工智能 多媒体应用 计算机网络 … 什么是硬件 计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。 冯.诺依曼体系结构,计算机的硬件分成5大组成部件： 运算器 控制器 存储器 输入设备 输出设备 计算机的硬件的作用 运算器和控制器是计算机的核心，合称中央处理单元（Central Processing Unit，CPU）或处理器。CPU的内部还有一些高速存储单元，被称为寄存器。其中运算器执行所有的算术和逻辑运算；控制器负责把指令逐条从存储器中取出，经译码后向计算机发出各种控制命令；而寄存器为处理单元提供操作所需要的数据。 存储器是计算机的记忆部分，用来存放程序以及程序中涉及的数据。它分为内部存储器和外部存储器。内部存储器用于存放正在执行的程序和使用的数据，其成本高、容量小，但速度快。外部存储器可用于长期保存大量程序和数据，其成本低、容量大，但速度较慢。 输入设备和输出设备统称为外部设备，简称外设或I/O设备，用来实现人机交互和机间通信。微型机中常用的输入设备有键盘、鼠标等，输出设备有显示器、打印机等。 什么是软件计算机软件(Computer Software)是使用计算机过程中必不可少的东西，计算机软件可以使计算机按照事先预定好的顺序完成特定的功能 计算机软件按照其功能划分为: 系统软件: DOS(Disk Operating System), Windows, Linux, Unix, Mac, Android, iOS 应用软件: office QQ聊天 YY语言 扫雷 软件开发和计算机语言概述 什么是软件开发按照特定顺序组织的计算机数据和指令的集合 什么是开发软件的制作过程 什么是软件开发借助开发工具与计算机语言制作软件 什么是计算机语言人与计算机之间进行信息交流沟通的一种特殊语言 计算机语言的分类 机器语言：机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。 汇编语言：汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。 高级语言：使用普通英语进行编写源代码，通过编译器将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。高级语言包括C,C++,C#,JAVA 人机交互人机交互的两种方式: 命令行方式需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令 图形化界面方式这种方式简单直观，使用者易于接受，容易上手操作 键盘功能键和快捷键键盘功能键 Tab Shift Ctrl Alt 空格 Enter Window 上下左右键 PrtSc(PrintScreen)屏幕截图 键盘快捷键 Ctrl+A全选 Ctrl+C复制 Ctrl+V粘贴 Ctrl+X剪切 Ctrl+Z撤销 Ctrl+S保存 如何打开DOS控制台xp下如何打开DOS控制台 开始–程序–附件–命令提示符 开始–运行–cmd–回车 win+r–cmd–回车 win7下如何打开DOS控制 开始–所有程序–附件–命令提示符 开始–搜索程序和文件–cmd–回车 win+r–cmd–回车 win8下如何打开DOS控制台 鼠标左击开始–下箭头–命令提示符 鼠标右击开始–搜索–cmd–回车 鼠标右击开始–运行–cmd–回车 win+r–cmd–回车 常见的DOS命令讲解 d: 盘符切换 dir(directory) 列出当前目录下的文件以及文件夹 cd (change directory) 改变指定目录(进入指定目录) cd.. 退回到上一级目录 cd\\ 退回到根目录 cls (clear screen)清屏 exit 退出dos命令行(分割线上的需要掌握,下的了解) ========================================================= md (make directory) 创建目录 rd (remove directory) 删除目录 del (delete) 删除文件,删除一堆后缀名一样的文件*.txt notepad 创建文件 删除带内容的文件夹 rd + /s 文件夹名称(询问是否删除) rd + /q + /s 文件夹名称(直接删除)","tags":[{"name":"computer","slug":"computer","permalink":"http://wxhaor.me/tags/computer/"}]},{"title":"markdown基本语法","date":"2013-06-04T16:00:00.000Z","path":"2013/06/05/wxhao/2013-06-05-markdown-basics/","text":"一门编写博客的轻量级标记语言 概述 Markdown 是一种轻量级的标记语言，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 认识 Markdown在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 CloudApp 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 Tumblr，也支持 Mou 这类 Markdown 工具的直接上传。 使用 Markdown 的优点 专注你的文字内容而不是排版样式，安心写作。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。 可读、直观、学习成本低。 Markdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。 我该用什么工具？ Windows 下的 Markdown，有两款还算不错 一款叫做 MarkdownPad 另一款叫做 typora iOS 端很多 app 早已经支持了 Markdown 录入，例如 Drafts，Day One，iA writer 等，另外 Ulysses for iPad 现在已经上架，可以说是 iOS 平台最好的编辑器了。 在 Web端，我推荐cmd markdown产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown(也有客户端,笔者就用的这款和MarkdownPad) ，同样支持左右两栏的实时预览，字体优雅，简洁。 Markdown 语法的简要规则标题123456# 标题## 标题### 标题#### 标题##### 标题###### 标题 列表123456789101112## 有序 1. 有序列表 2. 有序列表 3. 有序列表 4. 有序列表 5. 有序列表## 无序 - 无序列表 - 无序列表 - 无序列表 - 无序列表 - 无序列表 引用1234&gt; 这里是引用要注意符号和文本之间的空格 图片与链接1234[插入链接](http://blog.wxhao2.com/)![帅气的我,哈哈](http://blog.wxhao2.com/img/avatar-wxhao.jpg) 粗体与斜体1234**这里是粗体** *这里是斜体*","tags":[{"name":"markdown","slug":"markdown","permalink":"http://wxhaor.me/tags/markdown/"}]},{"title":"欢迎来到我的博客","date":"2013-06-02T16:00:00.000Z","path":"2013/06/03/life/2013-06-03-my-frist-blog/","text":"为什么要写博客欢迎来到我的第一篇博客 每个人写博客都有着不尽相同的目的,我开始动笔主要源于： 沉淀知识 记录生活 装逼,哈哈 怎么开始写博客学会写作Blog的技巧 没有人天生会写博客，我刚开始的时候也不知道该怎么写(虽然现在也不知道) 经过不断的尝试，现在我知道怎么可以写出自己想要的东西。 生活: 就跟小学写日记一样,文笔看个人 知识: 尽量写的让以后自己看得懂(因为我主要是给自己记笔记的),当然你要是总结归纳能力强,也可以写的大家都看的懂 选择Blog平台 网上的免费Blog提供商(如:简书/CSDN等) 使用jekyll或者hexo托管在GitHub上 租服务器用WordPress或者jpress搭建博客系统","tags":[{"name":"life","slug":"life","permalink":"http://wxhaor.me/tags/life/"}]}]